<!-- TOC titleSize:1 tabSpaces:2 depthFrom:1 depthTo:6 withLinks:1 updateOnSave:1 orderedList:0 skip:0 title:1 charForUnorderedList:* -->
# Table of Contents
- [Table of Contents](#table-of-contents)
- [Normal forms](#normal-forms)
  - [Boyce-Codd normal form](#boyce-codd-normal-form)
  - [Third normal form](#third-normal-form)
<!-- /TOC -->

# Normal forms
**Brief**. Given a relation schema, we need to decide whether it is a good design or whether we need to decompose it into smaller relations

$\to$ Such a decision must be guided by an understanding of what problems, if any, arise from the current schema

**Normal forms**.
* *Normal forms*. Proposed to provide the guidance above
    * *Explain*. If a relation schema is in one of these normal forms
        
        $\to$ We know that certain kinds of problems cannot arise
* *Normal forms based on FDs*.
    * First normal form (1NF)
    * Second normal form (2NF)
    * Third normal form (3NF)
    * Boyce-Codd normal form (BCNF)
* *Increasing restrictive requirements of normal forms*.
    * Every relation in BCNF is also in 3NF
    * Every relation in 3NF is also in 2NF
    * Every relation in 2NF is in 1NF
* *Brief introduction about normal forms*.
    * A relation is in first normal form if every field contains only atomic values, i.e. not lists or sets
    * 2NF is mainly of historical interest
    * 3NF and BCNF are important from a database design standpoint

**FDs' role**. If more detailed ICs are specified, we may be able to detect more subtle redundancies as well

## Boyce-Codd normal form
**Boyce-Codd normal form**.
* *Assumptions*.
    * $R$ is a relation schema
    * $X$ is a subset of the attributes of $R$
    * $A$ is an attribute of $R$
* *Conclusion*. R is in Boyce-Codd normal form if for every FD $X \to A$ holding over $R$, one of the following statements is true
    * $A \in X$, i.e. it is a trivial FD, or
    * $X$ is a superkey
* *Interpretation*. The only nontrivial dependencies are those in which a key determines some attribute(s)

    $\to$ Each tuple can be seen as an entity or relationship, identified by a key and described by the remaining attributes
    * *Kent's quote*. Each attribute must describe the key, the whole key, and nothing but the key

    <div style="text-align:center">
        <img src="https://i.imgur.com/huqn5r6.png">
        <figcaption>FDs in a BCNF relation</figcaption>
    </div>

**Checking if a relation is in BCNF**. Consider a set $F$ of FDs, to check if $R$ is in Boyce-Codd normal form

$\to$ It suffices to check whether the left side of each dependency in $F$ is a superkey
* *Explain*. Due to the interpretation of BCNF

**BCNF and redundancy detection**. BCNF ensures that no redundancy can be detected using FD information alone

$\to$ BCNF is the most desirable normal form, from the point of view of redundancy, if we take into account only FD information
* *Explain*. Since we take into account only FD information, and no redundancy can be detected given them

    $\to$ The relation turns out to have the least redundancy conditionally on the FD information
* *Data in a BCNF relation*. If a relation is in BCNF
    
    $\to$ Every field of every tuple records a piece of information that cannot be inferred, using only FDs, from the values in all other fields in all tuples of the relation instance

## Third normal form
**Third normal form**.
* *Assumptions*.
    * $R$ is a relation schema
    * $X$ is a subset of the attributes of $R$
    * $A$ is an attribute of $R$
* *Conclusion*. $R$ is in third normal form if for every FD $X \to A$ holding over R, one of the following statements is true
    * $A \in X$, i.e. it is a trivial FD, or
    * $X$ is a superkey, or
    * $A$ is part of some key for $R$
* *3NF versus BCNF*. 3NF is similar to BCNF, with the only difference being the third condition, i.e.
    
    $\to$ Every BCNF relation is also in 3NF
* *Interpretation of the last condition*. Recall that a key for a relation is a minimal set of attributes uniquely determining all other attributes
    
    >**NOTE**. $A$ must be part of a key, i.e. any key, if there are several
    >
    >$\to$ It is not enough for $A$ to be part of a superkey

**Checking if a relation is in 3NF**. Finding all keys of a relation schema is known to be an NP-complete problem, 

$\to$ Determining whether a relation schema is in 3NF is NP-complete as well

**Violation of 3NF**. There are two cases a dependency $X \to A$ can violate 3NF
* X is a proper subset of some key K. Such a dependency is sometimes called a partial dependency. In this case we store (X, A) pairs redundantly. As an example, consider the Reserves relation with attributes SBDC from Section 15.3.4. The only key is SBD, and we have the FD S ! C. We store the credit card number for a sailor as many times as there are reservations for that sailor.
* X is not a proper subset of any key. Such a dependency is sometimes called a transitive dependency because it means we have a chain of dependencies K ! X ! A. The problem is that we cannot associate an X value with a K value unless we also associate an A value with an X value. As an example, consider the Hourly Emps relation with attributes SNLRWH from Section 15.3.1. The only key is S, but there is an FD R ! W, which gives rise to the chain S ! R ! W. The consequence is that we cannot record the fact that employee S has rating R without knowing the hourly wage for that rating. This condition leads to insertion, deletion, and update anomalies.


Partial dependencies are illustrated in Figure 15.9, and transitive dependencies are
illustrated in Figure 15.10. Note that in Figure 15.10, the set X of attributes may or
may not have some attributes in common with KEY; the diagram should be interpreted
as indicating only that X is not a subset of KEY.
The motivation for 3NF is rather technical. By making an exception for certain dependencies involving key attributes, we can ensure that every relation schema can be
decomposed into a collection of 3NF relations using only decompositions that have
certain desirable properties (Section 15.6). Such a guarantee does not exist for BCNF
relations; the 3NF definition weakens the BCNF requirements just enough to make
this guarantee possible. We may therefore compromise by settling for a 3NF design.
As we shall see in Chapter 16, we may sometimes accept this compromise (or even
settle for a non-3NF schema) for other reasons as well.
Unlike BCNF, however, some redundancy is possible with 3NF. The problems associated with partial and transitive dependencies persist if there is a nontrivial dependency
X ! A and X is not a superkey, even if the relation is in 3NF because A is part of
a key. To understand this point, let us revisit the Reserves relation with attributes
SBDC and the FD S ! C, which states that a sailor uses a unique credit card to pay
for reservations. S is not a key, and C is not part of a key. (In fact, the only key is
SBD.) Thus, this relation is not in 3NF; (S, C) pairs are stored redundantly. However,
if we also know that credit cards uniquely identify the owner, we have the FD C !
S, which means that CBD is also a key for Reserves. Therefore, the dependency S !
C does not violate 3NF, and Reserves is in 3NF. Nonetheless, in all tuples containing
the same S value, the same (S, C) pair is redundantly recorded.
For completeness, we remark that the definition of second normal form is essentially
that partial dependencies are not allowed. Thus, if a relation is in 3NF (which precludes
both partial and transitive dependencies), it is also in 2NF.