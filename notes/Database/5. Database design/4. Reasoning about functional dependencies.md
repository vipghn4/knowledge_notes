<!-- TOC titleSize:1 tabSpaces:2 depthFrom:1 depthTo:6 withLinks:1 updateOnSave:1 orderedList:0 skip:0 title:1 charForUnorderedList:* -->
# Table of Contents
- [Table of Contents](#table-of-contents)
- [Reasoning about functional dependencies](#reasoning-about-functional-dependencies)
  - [Closure of a set of FDs](#closure-of-a-set-of-fds)
  - [Attribute closure](#attribute-closure)
<!-- /TOC -->

# Reasoning about functional dependencies
The discussion up to this point has highlighted the need for techniques that allow us to
carefully examine and further refine relations obtained through ER design (or, for that
matter, through other approaches to conceptual design). Before proceeding with the
main task at hand, which is the discussion of such schema refinement techniques, we
digress to examine FDs in more detail because they play such a central role in schema
analysis and refinement.
Given a set of FDs over a relation schema R, there are typically several additional FDs
that hold over R whenever all of the given FDs hold. As an example, consider:
Workers(ssn, name, lot, did, since)
We know that ssn ! did holds, since ssn is the key, and FD did ! lot is given to hold.
Therefore, in any legal instance of Workers, if two tuples have the same ssn value, they
must have the same did value (from the first FD), and because they have the same did
value, they must also have the same lot value (from the second FD). Thus, the FD ssn
! lot also holds on Workers.
We say that an FD f is implied by a given set F of FDs if f holds on every relation
instance that satisfies all dependencies in F, that is, f holds whenever all FDs in F
hold. Note that it is not sufficient for f to hold on some instance that satisfies all
dependencies in F; rather, f must hold on every instance that satisfies all dependencies
in F.

## Closure of a set of FDs
The set of all FDs implied by a given set F of FDs is called the closure of F and is
denoted as F +. An important question is how we can infer, or compute, the closure
of a given set F of FDs. The answer is simple and elegant. The following three rules,
called Armstrong’s Axioms, can be applied repeatedly to infer all FDs implied by

a set F of FDs. We use X, Y, and Z to denote sets of attributes over a relation schema
R:
Reflexivity: If X ⊇ Y, then X ! Y.
Augmentation: If X ! Y, then XZ ! YZ for any Z.
Transitivity: If X ! Y and Y ! Z, then X ! Z.
Armstrong’s Axioms are sound in that they generate only FDs in F + when applied
to a set F of FDs. They are complete in that repeated application of these rules will
generate all FDs in the closure F +. (We will not prove these claims.) It is convenient
to use some additional rules while reasoning about F +:
Union: If X ! Y and X ! Z, then X ! YZ.
Decomposition: If X ! YZ, then X ! Y and X ! Z.
These additional rules are not essential; their soundness can be proved using Armstrong’s Axioms.
To illustrate the use of these inference rules for FDs, consider a relation schema ABC
with FDs A ! B and B ! C. A trivial FD is one in which the right side contains
only attributes that also appear on the left side; such dependencies always hold due
to reflexivity. Using reflexivity, we can generate all trivial dependencies, which are of
the form:
X ! Y, where Y ⊆ X, X ⊆ ABC, and Y ⊆ ABC.
From transitivity we get A ! C. From augmentation we get the nontrivial dependencies:
AC ! BC, AB ! AC, AB ! CB.
As a second example, we use a more elaborate version of the Contracts relation:
Contracts(contractid, supplierid, projectid, deptid, partid, qty, value)
We denote the schema for Contracts as CSJDPQV. The meaning of a tuple in this
relation is that the contract with contractid C is an agreement that supplier S (supplierid) will supply Q items of part P (partid) to project J (projectid) associated with
department D (deptid); the value V of this contract is equal to value.
The following ICs are known to hold:
1. The contract id C is a key: C ! CSJDPQV.
2. A project purchases a given part using a single contract: JP ! C.
3. A department purchases at most one part from a supplier: SD ! P.
Several additional FDs hold in the closure of the set of given FDs:
From JP ! C, C ! CSJDPQV and transitivity, we infer JP ! CSJDPQV.
From SD ! P and augmentation, we infer SDJ ! JP.
From SDJ ! JP, JP ! CSJDPQV and transitivity, we infer SDJ ! CSJDPQV. (Incidentally, while it may appear tempting to do so, we cannot conclude SD ! CSDPQV,
canceling J on both sides. FD inference is not like arithmetic multiplication!)
We can infer several additional FDs that are in the closure by using augmentation or
decomposition. For example, from C ! CSJDPQV, using decomposition we can infer:
C ! C, C ! S, C ! J, C ! D, etc.
Finally, we have a number of trivial FDs from the reflexivity rule.

## Attribute closure
If we just want to check whether a given dependency, say, X ! Y, is in the closure of
a set F of FDs, we can do so efficiently without computing F +. We first compute the
attribute closure X+ with respect to F, which is the set of attributes A such that X
! A can be inferred using the Armstrong Axioms. The algorithm for computing the
attribute closure of a set X of attributes is shown in Figure 15.6.
closure = X;
repeat until there is no change: f
if there is an FD U ! V in F such that U ⊆ closure,
then set closure = closure [ V
g
Figure 15.6 Computing the Attribute Closure of Attribute Set X
This algorithm can be modified to find keys by starting with set X containing a single
attribute and stopping as soon as closure contains all attributes in the relation schema
By varying the starting attribute and the order in which the algorithm considers FDs,
we can obtain all candidate keys.