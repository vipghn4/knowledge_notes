<!-- TOC titleSize:1 tabSpaces:2 depthFrom:1 depthTo:6 withLinks:1 updateOnSave:1 orderedList:0 skip:0 title:1 charForUnorderedList:* -->
# Table of Contents
- [Table of Contents](#table-of-contents)
- [Normalization](#normalization)
  - [Decomposition into BCNF](#decomposition-into-bcnf)
    - [Redundancy in BCNF revisited](#redundancy-in-bcnf-revisited)
    - [Alternatives in decomposing to BCNF](#alternatives-in-decomposing-to-bcnf)
    - [BCNF and dependency-preservation](#bcnf-and-dependency-preservation)
  - [Decomposition into 3NF](#decomposition-into-3nf)
    - [Minimal cover for a set of FDs](#minimal-cover-for-a-set-of-fds)
    - [Dependency-preserving decomposition into 3NF](#dependency-preserving-decomposition-into-3nf)
    - [3NF synthesis](#3nf-synthesis)
<!-- /TOC -->

# Normalization
**Brief**. This chapter considers algorithms for converting relations to BCNF or 3NF
* *Lossless decomposition*. If a relation schema is not in BCNF

    $\to$ It is possible to obtain a lossless-join decomposition into a collection of BCNF relation schemas
* *Dependency-preserving decomposition*. 
    * *BCNF schemas*. There may not be any dependency-preserving decomposition into a collection of BCNF relation schemas
    * *3NF schemas*. There is always a dependency-preserving, lossless-join decomposition into a collection of 3NF relation schemas

## Decomposition into BCNF
**Lossless decomposition of a relation schema into a collection of BCNF relation schemas**.
* *Assumptions*.
    * $R$ is a relation schema, which is not in BCNF
    * $X \subset R$ is a set of attributes
    * $A$ is an attribute in $R$
    * $X\to A$ be an FD causing a violation of BCNF
    * $R − A$ denotes the set of attributes other than $A$ in $R$
    * $XA$ denotes the union of attributes in $X$ and $A$
* *Decomposition method*. 
    1. Decompose $R$ into $R − A$ and $XA$
    2. If either $R − A$ or $XA$ is not in BCNF
    
        $\to$ Decompose them further by a recursive application of the algorithm

**Proof of correctness**.
* *FDs violating BCNF*. An FD $X\to A$ violates BCNF if $A\notin X$, and $X$ is not a superkey

    $\to$ We can always decompose $R$ into smaller relation schemas $R-A$ and $XA$
* *Proof of losslessness*. Since $(R-A)\cap XA=X$ and $X\to A\in F$

    $\to$ The decomposition of $R$ into $R-A$ and $XA$ is lossless
* *Proof of BCNF*. 
    * Decomposing $R$ into $R-A$ and $XA$ will
        * Eliminate the FD $X\to A$, as well as all FDs relating exclusive attributes from both relation schemas
        * Result in two strictly smaller relation schemas $R-A$ and $XA$
    * Hence, by infinitely repeat the algorithm, we will come up with
        * Single-attribute relation schemas, which is obviously in BCNF, or
        * Relation schemas, which is in BCNF

**Visualization**. The steps in this decomposition process can be visualized as a tree

$\to$ The root is the original relation, and the leaves are the resulting BCNF relations that
* *Interpretation*. Each internal node is replaced by its children through a single decomposition step, which is guided by the FD shown just below the node

### Redundancy in BCNF revisited
The decomposition of CSJDQV into SDP, JS, and CJDQV is not dependency-preserving.
Intuitively, dependency JP ! C cannot be enforced without a join. One way to deal
with this situation is to add a relation with attributes CJP. In effect, this solution
amounts to storing some information redundantly in order to make the dependency
enforcement cheaper.
This is a subtle point: Each of the schemas CJP, SDP, JS, and CJDQV is in BCNF,
yet there is some redundancy that can be predicted by FD information. In particular,
if we join the relation instances for SDP and CJDQV and project onto the attributes
CJP, we must get exactly the instance stored in the relation with schema CJP. We saw
in Section 15.5.1 that there is no such redundancy within a single BCNF relation. The
current example shows that redundancy can still occur across relations, even though
there is no redundancy within a relation.

### Alternatives in decomposing to BCNF
Suppose that several dependencies violate BCNF. Depending on which of these dependencies we choose to guide the next decomposition step, we may arrive at quite
different collections of BCNF relations. Consider Contracts. We just decomposed it
into SDP, JS, and CJDQV. Suppose that we choose to decompose the original relation
CSJDPQV into JS and CJDPQV, based on the FD J ! S. The only dependencies
that hold over CJDPQV are JP ! C and the key dependency C ! CJDPQV. Since
JP is a key, CJDPQV is in BCNF. Thus, the schemas JS and CJDPQV represent a
lossless-join decomposition of Contracts into BCNF relations.
The lesson to be learned here is that the theory of dependencies can tell us when there is
redundancy and give us clues about possible decompositions to address the problem,
but it cannot discriminate between decomposition alternatives. A designer has to
consider the alternatives and choose one based on the semantics of the application

### BCNF and dependency-preservation
Sometimes, there simply is no decomposition into BCNF that is dependency-preserving.
As an example, consider the relation schema SBD, in which a tuple denotes that sailor
S has reserved boat B on date D. If we have the FDs SB ! D (a sailor can reserve a
given boat for at most one day) and D ! B (on any given day at most one boat can
be reserved), SBD is not in BCNF because D is not a key. If we try to decompose it,
however, we cannot preserve the dependency SB ! D.

## Decomposition into 3NF
Clearly, the approach that we outlined for lossless-join decomposition into BCNF will
also give us a lossless-join decomposition into 3NF. (Typically, we can stop a little
earlier if we are satisfied with a collection of 3NF relations.) But this approach does
not ensure dependency-preservation.
A simple modification, however, yields a decomposition into 3NF relations that is
lossless-join and dependency-preserving. Before we describe this modification, we need
to introduce the concept of a minimal cover for a set of FDs.

### Minimal cover for a set of FDs
A minimal cover for a set F of FDs is a set G of FDs such that:
1. Every dependency in G is of the form X ! A, where A is a single attribute.
2. The closure F + is equal to the closure G+.
3. 3. If we obtain a set H of dependencies from G by deleting one or more dependencies,
or by deleting attributes from a dependency in G, then F + 6= H+.
Intuitively, a minimal cover for a set F of FDs is an equivalent set of dependencies that
is minimal in two respects: (1) Every dependency is as small as possible; that is, each
attribute on the left side is necessary and the right side is a single attribute. (2) Every
dependency in it is required in order for the closure to be equal to F +.
As an example, let F be the set of dependencies:
A ! B, ABCD ! E, EF ! G, EF ! H, and ACDF ! EG.
First, let us rewrite ACDF ! EG so that every right side is a single attribute:
ACDF ! E and ACDF ! G.
Next consider ACDF ! G. This dependency is implied by the following FDs:
A ! B, ABCD ! E, and EF ! G.
Therefore, we can delete it. Similarly, we can delete ACDF ! E. Next consider ABCD
! E. Since A ! B holds, we can replace it with ACD ! E. (At this point, the reader
should verify that each remaining FD is minimal and required.) Thus, a minimal cover
for F is the set:
A ! B, ACD ! E, EF ! G, and EF ! H.
The preceding example suggests a general algorithm for obtaining a minimal cover of
a set F of FDs:
1. Put the FDs in a standard form: Obtain a collection G of equivalent FDs
with a single attribute on the right side (using the decomposition axiom).
2. Minimize the left side of each FD: For each FD in G, check each attribute in
the left side to see if it can be deleted while preserving equivalence to F +.
3. Delete redundant FDs: Check each remaining FD in G to see if it can be
deleted while preserving equivalence to F +.
Note that the order in which we consider FDs while applying these steps could produce
different minimal covers; there could be several minimal covers for a given set of FDs.
More important, it is necessary to minimize the left sides of FDs before checking for
redundant FDs. If these two steps are reversed, the final set of FDs could still contain
some redundant FDs (i.e., not be a minimal cover), as the following example illustrates.
Let F be the set of dependencies, each of which is already in the standard form:
ABCD ! E, E ! D, A ! B, and AC ! D.
Observe that none of these FDs is redundant; if we checked for redundant FDs first,
we would get the same set of FDs F. The left side of ABCD ! E can be replaced
by AC while preserving equivalence to F +, and we would stop here if we checked for
redundant FDs in F before minimizing the left sides. However, the set of FDs we have
is not a minimal cover:
AC ! E, E ! D, A ! B, and AC ! D.
From transitivity, the first two FDs imply the last FD, which can therefore be deleted
while preserving equivalence to F +. The important point to note is that AC ! D
becomes redundant only after we replace ABCD ! E with AC ! E. If we minimize
left sides of FDs first and then check for redundant FDs, we are left with the first three
FDs in the preceding list, which is indeed a minimal cover for F.

### Dependency-preserving decomposition into 3NF
Returning to the problem of obtaining a lossless-join, dependency-preserving decomposition into 3NF relations, let R be a relation with a set F of FDs that is a minimal
cover, and let R1; R2; : : : ; Rn be a lossless-join decomposition of R. For 1 ≤ i ≤ n,
suppose that each Ri is in 3NF and let Fi denote the projection of F onto the attributes
of Ri. Do the following:
Identify the set N of dependencies in F that are not preserved, that is, not
included in the closure of the union of Fis.
For each FD X ! A in N, create a relation schema XA and add it to the decomposition of R.
Obviously, every dependency in F is preserved if we replace R by the Ris plus the
schemas of the form XA added in this step. The Ris are given to be in 3NF. We can
show that each of the schemas XA is in 3NF as follows: Since X ! A is in the minimal
cover F, Y ! A does not hold for any Y that is a strict subset of X. Therefore, X
is a key for XA. Further, if any other dependencies hold over XA, the right side can
involve only attributes in X because A is a single attribute (because X ! A is an FD
in a minimal cover). Since X is a key for XA, none of these additional dependencies
causes a violation of 3NF (although they might cause a violation of BCNF).
As an optimization, if the set N contains several FDs with the same left side, say,
X ! A1; X ! A2; : : : ; X ! An, we can replace them with a single equivalent
FD X ! A1 : : : An. Therefore, we produce one relation schema XA1 : : : An, instead of
several schemas XA1; : : : ; XAn, which is generally preferable.
Consider the Contracts relation with attributes CSJDPQV and FDs JP ! C, SD ! P,
and J ! S. If we decompose CSJDPQV into SDP and CSJDQV, then SDP is in BCNF,
but CSJDQV is not even in 3NF. So we decompose it further into JS and CJDQV.
The relation schemas SDP, JS, and CJDQV are in 3NF (in fact, in BCNF), and the
decomposition is lossless-join. However, the dependency JP ! C is not preserved. This
problem can be addressed by adding a relation schema CJP to the decomposition.

### 3NF synthesis
We have assumed that the design process starts with an ER diagram, and that our use
of FDs is primarily to guide decisions about decomposition. The algorithm for obtaining a lossless-join, dependency-preserving decomposition was presented in the previous
section from this perspective|a lossless-join decomposition into 3NF is straightforward, and the algorithm addresses dependency-preservation by adding extra relation
schemas.
An alternative approach, called synthesis, is to take all the attributes over the original
relation R and a minimal cover F for the FDs that hold over it, and to add a relation
schema XA to the decomposition of R for each FD X ! A in F.
The resulting collection of relation schemas is in 3NF and preserves all FDs. If it is
not a lossless-join decomposition of R, we can make it so by adding a relation schema
that contains just those attributes that appear in some key. This algorithm gives us
a lossless-join, dependency-preserving decomposition into 3NF, and has polynomial
complexity|polynomial algorithms are available for computing minimal covers, and
a key can be found in polynomial time (even though finding all keys is known to be
NP-complete). The existence of a polynomial algorithm for obtaining a lossless-join,
dependency-preserving decomposition into 3NF is surprising when we consider that
testing whether a given schema is in 3NF is NP-complete.
As an example, consider a relation ABC with FDs F = fA ! B, C ! Bg. The first
step yields the relation schemas AB and BC. This is not a lossless-join decomposition
of ABC; AB \ BC is B, and neither B ! A nor B ! C is in F +. If we add a schema
AC, we have the lossless-join property as well. Although the collection of relations
AB, BC, and AC is a dependency-preserving, lossless-join decomposition of ABC, we
obtained it through a process of synthesis, rather than through a process of repeated
decomposition. We note that the decomposition produced by the synthesis approach
is heavily dependent on the minimal cover that is used.
As another example of the synthesis approach, consider the Contracts relation with
attributes CSJDPQV and the following FDs:
C ! CSJDPQV, JP ! C, SD ! P, and J ! S.
This set of FDs is not a minimal cover, and so we must find one. We first replace C
! CSJDPQV with the FDs:
C ! S, C ! J, C ! D, C ! P, C ! Q, and C ! V.
The FD C ! P is implied by C ! S, C ! D, and SD ! P; so we can delete it. The
FD C ! S is implied by C ! J and J ! S; so we can delete it. This leaves us with a
minimal cover:
C ! J, C ! D, C ! Q, C ! V, JP ! C, SD ! P, and J ! S.
Using the algorithm for ensuring dependency-preservation, we obtain the relational
schema CJ, CD, CQ, CV, CJP, SDP, and JS. We can improve this schema by combining
relations for which C is the key into CDJPQV. In addition, we have SDP and JS in
our decomposition. Since one of these relations (CDJPQV) is a superkey, we are done.
Comparing this decomposition with the one that we obtained earlier in this section,
we find that they are quite close, with the only difference being that one of them has
CDJPQV instead of CJP and CJDQV. In general, however, there could be significant
differences.
Database designers typically use a conceptual design methodology (e.g., ER design)
to arrive at an initial database design. Given this, the approach of repeated decompositions to rectify instances of redundancy is likely to be the most natural use of FDs
and normalization techniques. However, a designer can also consider the alternative
designs suggested by the synthesis approach.