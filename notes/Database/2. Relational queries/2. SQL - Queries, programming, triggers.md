<!-- TOC titleSize:1 tabSpaces:2 depthFrom:1 depthTo:6 withLinks:1 updateOnSave:1 orderedList:0 skip:0 title:1 charForUnorderedList:* -->
# Table of Contents
- [Table of Contents](#table-of-contents)
- [SQL - Queries, programming, triggers](#sql---queries-programming-triggers)
  - [The form of a basic SQL example](#the-form-of-a-basic-sql-example)
    - [Expressions and strings in the `SELECT` command](#expressions-and-strings-in-the-select-command)
  - [`UNION`, `INTERCEPT`, and `EXCEPT`](#union-intercept-and-except)
  - [Nested queries](#nested-queries)
    - [Introduction to nested queries](#introduction-to-nested-queries)
    - [Correlated nested queries](#correlated-nested-queries)
  - [Aggregate operators](#aggregate-operators)
    - [The `GROUP BY` and `HAVING` clauses](#the-group-by-and-having-clauses)
  - [Null values](#null-values)
    - [Comparisons using null values](#comparisons-using-null-values)
    - [Logical connectivities `AND`, `OR`, and `NOT`](#logical-connectivities-and-or-and-not)
    - [Impact on SQL constructs](#impact-on-sql-constructs)
    - [Outer joins](#outer-joins)
    - [Disallowing null values](#disallowing-null-values)
  - [Embedded SQL](#embedded-sql)
    - [Declaring variables and exceptions](#declaring-variables-and-exceptions)
    - [Embedding SQL statements](#embedding-sql-statements)
  - [Cursors](#cursors)
    - [Basic cursor definition and usage](#basic-cursor-definition-and-usage)
    - [Properties of cursors](#properties-of-cursors)
  - [Dynamic SQL](#dynamic-sql)
  - [ODBC and JDBC](#odbc-and-jdbc)
    - [Architecture](#architecture)
  - [Complex integrity constraints in SQL-92](#complex-integrity-constraints-in-sql-92)
    - [Constrasints over a single table](#constrasints-over-a-single-table)
    - [Domain constraints](#domain-constraints)
    - [Assertions - ICs over several tables](#assertions---ics-over-several-tables)
  - [Triggers and active databases](#triggers-and-active-databases)
  - [Designing and active databases](#designing-and-active-databases)
    - [Why triggers can be hard to understand](#why-triggers-can-be-hard-to-understand)
    - [Constraints versus triggers](#constraints-versus-triggers)
    - [Other uses of triggers](#other-uses-of-triggers)
- [Appendix](#appendix)
  - [Concepts](#concepts)
<!-- /TOC -->

# SQL - Queries, programming, triggers
**Structured Query Language (SQL)**. The most widely used commercial relational database language
* *History*. 
    * SQL was originally developed at IBM in the SEQUEL-XRM and System-R projects, from 1974 to 1977
    * Almost immediately, other vendors introduced DBMS products based on SQL
        
        $\to$ SQL is now a de facto standard
    * SQL continues to evolve in response to changing needs in the database area
* *SQL 92*. The ANSI/ISO standard for SQL

**Key aspects**.
* *Data Definition Language (DDL)*. This subset of SQL supports the creation, deletion, and modification of definitions for tables and views
    * *Integrity constraints*. Can be defined on tables, either when the table is created or later
    * *Protection*. The DDL also provides commands for specifying access rights or privileges to tables and views
    * *Indexing*. Although the standard does not discuss indexes
        
        $\to$ commercial implementations also provide commands for creating and deleting indexes
* *Data Manipulation Language (DML)*. This subset of SQL allows users to pose queries and to insert, delete, and modify rows
* *Embedded and dynamic SQL*. 
    * *Embedded SQL features*. Allow SQL code to be called from a host language, e.g. C or COBOL
    * *Dynamic SQL features*. Allow a query to be constructed, and executed, at run-time
* *Triggers*. Actions executed by the DBMS whenever changes to the database meet conditions specified in the trigger
* *Security*. SQL provides mechanisms to control users’ access to data objects, e.g. tables and views
* *Transaction management*. Various commands allow a user to explicitly control aspects of how a transaction is to be executed
* *Client-server execution and remote database access*. These commands control how a client application program can connect to an SQL database server, or access data from a database over a network

>**NOTE**. The ease of expressing queries in SQL has played a major role in the success of relational
database systems

**Active database**. Have a collection of triggers, which are specified by the DBA
* *Trigger*. Describe actions to be taken when certain situations arise
    
    $\to$ The DBMS monitors the database, detects these situations, and invokes the trigger

**Underlying example**. This section will present queries using the following table definitions

```sql
Sailors(sid: integer, sname: string, rating: integer, age: real)
Boats(bid: integer, bname: string, color: string)
Reserves(sid: integer, bid: integer, day: date)
```

## The form of a basic SQL example
**Brief**. This section presents the syntax of a simple SQL query and explains its meaning
through a conceptual evaluation strategy
* *Conceptual evaluation strategy*. A way to evaluate the query, which is intended to be easy to understand, rather than efficient

    $\to$ The DBMS would typically execute a query in a different and more efficient way

**Basic form of SQL query**. The following query intuitively corresponds to a relational algebra expression involving selections, projections, and cross-products

```sql
SELECT [ DISTINCT ] select-list -- specify columns to be retained in the result
FROM from-list -- specify a cross-product of tables
WHERE qualification -- specify selection conditions on table mentioned in FROM
```

* *Example*.

    ```sql
    SELECT DISTINCT S.sname, S.age
    FROM Sailors AS S
    WHERE S.rating > 7
    ```

* *`SELECT` and `WHERE`*. The `SELECT` clause is actually used to do projection, whereas selections in the relational algebra sense are expressed using the `WHERE` clause
    
    >**NOTE**. This mismatch between the naming of the selection and projection operators in relational algebra and the syntax of SQL is an unfortunate historical accident

* *Arguments to the query*.
    * *`from-list` in the `FROM` clause*. A list of table names
        * *Range variable*. A table name can be followed by a range variable
            
            $\to$ The range variable is particularly useful when the same table name appears more than once in the from-list
    * *`select-list`*. A list of expressions involving column names of tables named in the `from-list`
        * *Range variable*. Column names can be prefixed by a range variable
    * *`qualification` in the `WHERE` clause*. A boolean combination, i.e. an expression using `AND`, `OR`, and `NOT`, of conditions of the form

        $$\text{expression op expression}$$
        
        where $\text{op}\in\{<,\leq,=,<>,\geq,>\}$
        * *Expression*. A column name, a constant, or an arithmetic (or string) expression
* *Query output*. A multiset, or set, of rows, each of which is a tuple of desired tuple attributes

**Conceptual evaluation strategy for basic SQL query**.
1. Compute the cross-product of the tables in the `from-list`
2. Delete those rows in the cross-product that fail the qualification conditions
3. Delete all columns that do not appear in the `select-list`
4. If `DISTINCT` is specified, eliminate duplicate rows

**Keywords**.
* *`DISTINCT`*. Without the keyword `DISTINCT`, we would get a copy of the desired tuples, and the answer would be a multiset of rows
    * *Multiset*. An unordered collection of elements, and there could be several copies of each element, and the number of copies is significant
* *`AS`*. Used to introduce a range variable

### Expressions and strings in the `SELECT` command
**Expressions**. SQL supports a more general version of the `select-list` than just a list of columns

$\to$ Each item in a `select-list` can be of the form 

```sql
expression AS column_name
```

* *Expression `expression`*. Can be one of the forms
    * Any arithmetic or string expression over column names, possibly prefixed by range
variables, and constants
    * Aggregates, e.g. sum and count
    * Expressions over date and time values
    * Other built-in functions, e.g. `sqrt`, `sin`, and `mod`
* *Examples*.

    ```sql
    SELECT S.sname, S.rating+1 AS rating
    FROM Sailors S, Reserves R1, Reserves R2
    WHERE S.sid = R1.sid AND S.sid = R2.sid
    AND R1.day = R2.day AND R1.bid <> R2.bid
    ```

    or

    ```sql
    SELECT S1.sname AS name1, S2.sname AS name2
    FROM Sailors S1, Sailors S2
    WHERE 2*S1.rating = S2.rating-1
    ```

**Strings**.
* *String comparisons*. We can use comparison operators `=`, `<`, `>`, etc.
* *String sorting*. If we need to sort strings by an order other than alphabetical
    
    $\to$ SQL-92 supports a general concept of a collation, or sort order, for a character set
    * *Collation*. Allow users to specify which characters are less than which others
        
        $\to$ This provides great flexibility in string manipulation
* *Pattern matching*. SQL provides support for pattern matching through the `LIKE` operator and the wild-card symbols
    * *Wild-card symbols*.
        * `%` stands for zero or more arbitrary characters
            * *Example*. `AB%` denotes a pattern that will match every string that contains at least three characters, with the leading characters are `AB`
        * `_` stands for exactly one, arbitrary, character
    * *Blanks and `LIKE`*. Blanks can be significant for the `LIKE` operator, depending on the collation for the underlying character set
        * *Example*. `"Jeff" = "Jeff "` could be true, while `"Jeff" LIKE "Jeff "` is false
    * *Example*.

        ```sql
        SELECT S.age
        FROM Sailors S
        WHERE S.sname LIKE ‘B_%B’
        ```

## `UNION`, `INTERCEPT`, and `EXCEPT`
**Set-manipulation operations**. SQL provides three set-manipulation constructs extending the basic query form presented earlier
* *Motivation*. Since the answer to a query is a multiset of rows
    
    $\to$ It is natural to consider the use of operations such as union, intersection, and difference
* *Set-manipulation operations*. 
    * *Main operations*. SQL supports these operations via `UNION`, `INTERSECT`, and `EXCEPT`
    * *Other operations*. SQL also provides other set operations, i.e. 
        * `IN` to check if an element is in a given set
        * `op ANY`, `op ALL` to compare a value with the elements in a given set, using comparison operator `op`
            * *Examples*. `x = ANY(Salary)` or `x >= ANY(Salary)`
        * `EXISTS` to check if a set is empty, i.e. `EXISTS(table_name)` returns true if the `table_name` contains one or more records
        
        >**NOTE**. `IN` and `EXISTS` can be prefixed by `NOT`, with the obvious modification to their meaning

**Examples**. 
* *Example 1 - Set union*. Consider finding the names of sailors who have reserved a red or a green boat
    * *Query without `UNION`*. This is easily expressed via `OR` in `WHERE` clause

        ```sql
        SELECT S.sname
        FROM Sailors S, Reserves R, Boats B
             WHERE S.sid = R.sid AND R.bid = B.bid
             AND (B.color = ‘red’ OR B.color = ‘green’)
        ```

    * *Query with `UNION`*. Better solution

        ```sql
        SELECT S.sname
        FROM Sailors S, Reserves R, Boats B
        WHERE S.sid = R.sid AND R.bid = B.bid AND B.color = 'red'
        UNION
        SELECT S2.sname
        FROM Sailors S2, Boats B2, Reserves R2
        WHERE S2.sid = R2.sid AND R2.bid = B2.bid AND B2.color = 'green'
        ```

* *Example 2 - Set intersection*. Consider finding the names of sailors who have reserved both a red and a green boat
    * *Query without `INTERSECT`*. Difficult to understand, and inefficient to execute

        ```sql
        SELECT S.sname
        FROM Sailors S, Reserves R1, Boats B1, Reserves R2, Boats B2
        WHERE S.sid = R1.sid AND R1.bid = B1.bid
              AND S.sid = R2.sid AND R2.bid = B2.bid
              AND B1.color='red' AND B2.color = 'green'
        ```

    * *Query with `INTERSECT`*. Better solution

        ```sql
        SELECT S.sname
        FROM Sailors S, Reserves R, Boats B
        WHERE S.sid = R.sid AND R.bid = B.bid AND B.color = 'red'
        INTERSECT
        SELECT S2.sname
        FROM Sailors S2, Boats B2, Reserves R2
        WHERE S2.sid = R2.sid AND R2.bid = B2.bid AND B2.color = 'green'
        ```

        * *Problem*. If there are two sailors having the same name, one of whom reserved a red boat and the other reserved a green one
            
            $\to$ Their name is returned even though none of them has reserved both a red and a green boat
            * *Explain*. The problem arises since we are using `S.name`, which is not a key for `Sailors`, to identify sailors
        * *Solution*. Use `S.sid` instead
* *Example 3 - Set difference*. Consider finding the `sid`s of all sailors, who have reserved red boats but not green boats

    ```sql
    SELECT S.sid
    FROM Sailors S, Reserves R, Boats B
    WHERE S.sid = R.sid AND R.bid = B.bid AND B.color = 'red'
    EXCEPT
    SELECT S2.sid
    FROM Sailors S2, Reserves R2, Boats B2
    WHERE S2.sid = R2.sid AND R2.bid = B2.bid AND B2.color = 'green'
    ```

>**NOTE**. `UNION`, `INTERSECT`, and `EXCEPT` can be used on any two tables, which are union-compatible

**Multiset output relation**. 
* *Multiset output of `UNION`*. In contrast to the default, where duplicates are not eliminated unless `DISTINCT` is specified

    $\to$ The default for `UNION` queries is that duplicates are eliminated
    * *Retain duplicates in `UNION`*. Use `ALL`
* *Multiset output of `INTERSECT`*. One version of INTERSECT retains duplicates
* *Multiset output of `EXCEPT`*. One version of EXCEPT retains duplicates

## Nested queries
**Nested queries**. One of the most powerful features of SQL
* *Nested query*. A query with another query embedded within it
* *Subquery*. The embedded query in a nested query
    * *Subquery in nested query*. A subquery typically appears within the `WHERE` clause of a query, or sometimes in the `FROM` clause or the `HAVING` clause
* *Usage*. When writing a query, we sometimes need to express a condition referring to a table, which must computed
    
    $\to$ The query used to compute this subsidiary table is a subquery and appears as part of the main query

### Introduction to nested queries
**Understanding a nested query**. The best way is to think of nested queries in terms of a conceptual evaluation strategy
* *Conceptual evaluation strategy of nested queries*. 
    1. Construct the cross-product of the tables in the `FROM` clause of the top-level query
    2. For each row in the cross-product, while testing the qualification in the `WHERE` clause, (re)compute the subquery
        
    >**NOTE**. The subquery may contain another nested subquery
    >$\to$ We apply the same idea one more time, leading to an evaluation strategy with several levels of nested loops

* *Example*.

    ```sql
    SELECT S.sname
    FROM Sailors S
    WHERE S.sid IN ( SELECT R.sid
                     FROM Reserves R
                     WHERE R.bid = 103 )
    ```

### Correlated nested queries
**Correlated nested queries**. The subquery could depend on the row being examined in the outer query, in terms of our conceptual evaluation strategy
* *Example*. For each `Sailor` row `S`, we test whether the set of `Reserves` rows `R` such that `R.bid = 103 AND S.sid = R.sid` is nonempty

    ```sql
    SELECT S.sname
    FROM Sailors S
    WHERE EXISTS ( SELECT *
                   FROM Reserves R
                   WHERE R.bid = 103
                         AND R.sid = S.sid )
    ```

* *Correlation*. The occurrence of `S` in the subquery
* *Correlated queries*. Queries, where the subquery depends on the current row being examined

    $\to$ The subquery must be re-evaluated for each row

## Aggregate operators
**Aggregate operators**. We often want to perform some computation or summarization

$\to$ SQL allows the use of arithmetic expressions and aggregate values, e.g. `MIN` and `SUM`
* *Aggregate operations supported by SQL*. Consider any column `A` of a relation
    * `COUNT ([DISTINCT] A)`: The number of (unique) values in the `A` column
    * `SUM ([DISTINCT] A)`: The sum of all (unique) values in the `A` column
    * `AVG ([DISTINCT] A)`: The average of all (unique) values in the `A` column
    * `MAX (A)`: The maximum value in the `A` column
    * `MIN (A)`: The minimum value in the `A` column

    >**NOTE**. It does not make sense to specify `DISTINCT` in conjunction with `MIN` or `MAX`

* *Examples*.
    * *Basic example*.

        ```sql
        SELECT AVG (S.age)
        FROM Sailors S
        WHERE S.rating = 10
        ```

**Argmax operator**. Consider returning not only the maximum age but also the name of the sailors having that age
* *Naive approach*.

    ```sql
    SELECT S.sname, MAX (S.age)
    FROM Sailors S
    ```

    * *Problem*. This query is illegal in SQL, i.e. if the `SELECT` clause uses an aggregate operation
        
        $\to$ It must use only aggregate operations, unless the query contains a `GROUP BY` clause
* *Proper approach*.

    ```sql
    SELECT S.sname, S.age
    FROM Sailors S
    WHERE S.age = ( SELECT MAX (S2.age)
                    FROM Sailors S2 )
    ```

    * *Explain*. The subquery is guaranteed to return a single tuple with a single field
        
        $\to$ SQL converts such a relation to a field value for the sake of the comparison
* *Alternative approach*. This approach is not supported in many systems

    ```sql
    SELECT S.sname, S.age
    FROM Sailors S
    WHERE ( SELECT MAX (S2.age)
            FROM Sailors S2 ) = S.age
    ```

**Aggregate operations and `ANY` and `ALL`**. Aggregate operations offer an alternative to the ANY and ALL constructs
* *Example*. Consider finding the names of sailors who are older than the oldest sailor with a rating of 10
    * *With aggregation*.

        ```sql
        SELECT S.sname
        FROM Sailors S
        WHERE S.age > ( SELECT MAX ( S2.age )
                        FROM Sailors S2
                        WHERE S2.rating = 10 )
        ```
    
    * *Without aggregation*.

        ```sql
        SELECT S.sname
        FROM Sailors S
        WHERE S.age > ALL ( SELECT S2.age
                            FROM Sailors S2
                            WHERE S2.rating = 10 )
        ```
        
        * *Drawback*. This is more error prone, i.e. one could easily and incorrectly use `ANY` instead of `ALL`

### The `GROUP BY` and `HAVING` clauses
**`GROUP BY` clauses**. Often we want to apply aggregate operations to each of a number of groups of rows in a relation, where the number of groups depends on the relation instance
* *`HAVING` clause*. An optional clause included within `GROUP BY` clause, which can be used to specify qualifications over groups
    * *Example*. We may only be interested in rating levels of at least 6
* *`GROUP BY` clause*.

    ```sql
    SELECT [ DISTINCT ] select-list
    FROM from-list
    WHERE qualification
    GROUP BY grouping-list
    HAVING group-qualification
    ```


    * *`select-list` in the `SELECT` clause*. 
        * *Structure*. Consist of
            * A list of column names
            * A list of terms having the form 
                
                $$\text{aggop  ( column-name ) AS new-name}$$

                where `AS new-name` gives the column a name in the resulting table
        * *Aggregation operator*. Any of the aggregation operators can be used for $\text{aggop}$
    * *`grouping-list`*. Every column that appears in the column name list must appear in `grouping-list`
        * *Explain*. Each row in the resulting table corresponds to one group, which is a collection of rows agreeing on the values of columns in `grouping-list`
            * *Consequence*. If a column appears in the column name list, but not in `grouping-list`
                
                $\to$ It is not clear what value should be assigned to it in an answer row
    * *`group-qualification`*. The expressions appearing in `group-qualification` in `HAVING` clause must have a single value per group
        * *Explain*. `HAVING` clause determines whether an answer row is to be generated for a given group
            
            $\to$ A column appearing in `group-qualification` must appear as the argument to an aggregation operator, or it must also appear in `grouping-list`
* *Example*. Consider finding the age of the youngest sailor for each rating level
    * *Without `GROUP BY`*.

        ```sql
        SELECT MIN (S.age)
        FROM Sailors S
        WHERE S.rating = i
        ```

        where $i\in\{1,\dots,10\}$
        * *Drawback*. 
            * Writing 10 such queries is tedious
            * We may not know what rating levels exist in advance.
    * *With `GROUP BY`*

        ```sql
        SELECT S.rating, MIN (S.age)
        FROM Sailors S
        GROUP BY S.rating
        ```

**Examples**.

```sql
SELECT S.rating, MIN (S.age) AS minage
FROM Sailors S
WHERE S.age >= 18
GROUP BY S.rating
HAVING COUNT (*) > 1
```

or

```sql
SELECT B.bid, COUNT (*) AS sailorcount
FROM Boats B, Reserves R
WHERE R.bid = B.bid
GROUP BY B.bid
HAVING B.color = ‘red’
```

**Conceptual evaluation strategy**.
1. Construct the cross-product of tables in the `from-list`
2. Apply the qualification in the `WHERE` clause, e.g. `S.age >= 18`
3. Eliminate unwanted columns, i.e. only columns mentioned in the `SELECT` clause, the `GROUP BY` clause, or the `HAVING` clause are necessary
4. Sort the table according to the `GROUP BY` clause to identify the groups
5. Apply the `group-qualification` in the `HAVING` clause to eliminate invalid groups

    >**NOTE**. The order, in which the `WHERE` and `GROUP BY` clauses are considered is significant

6. Generate one answer row for each remaining group
    * *Answer row corresponding to a group*. Consist of 
        * A subset of the grouping columns
        * One or more columns generated by applying an aggregation operator
7.  If the query contains `DISTINCT` in the `SELECT` clause, duplicates are eliminated

## Null values
**Unknown column values**. In practice column values can be unknown

$\to$ We need is a special value denoting unknown
* *Null values*. SQL provides a special column value called `null` to indicate unknown values
    * *Usage*. Used when the column value is either unknown or inapplicable
    * *Drawback*. The presence of null values complicates many issues

### Comparisons using null values
**Comparisons using null values**. Since `null` indicates unknown

$\to$ It is reasonable to have all comparison with `null` evaluate to the value unknown
* *Consequence*. If we compare two `null` values using `<`, `>`, `=`, etc.
    
    $\to$ The result is always unknown

**Testing for `null`**. SQL provides a special comparison operator `IS NULL` to test whether a column value is `null`

### Logical connectivities `AND`, `OR`, and `NOT`
**Logical operations on `null`**. Once we have null values

$\to$ We must define the logical operators `AND`, `OR`, and `NOT` using a three-valued logic, in which expressions
evaluate to `true`, `false`, or `unknown
* *Idea*. We extend the usual interpretations of `AND`, `OR`, and `NOT` to cover the case when one of the arguments is `unknown` as follows
    * *`NOT` operation*. `NOT unknown` is defined to be `unknown`
    * *`OR` operation*. 
        * If either argument evaluates to `true`

            $\to$ `OR` of two arguments evaluates to `true`
        * If one argument evaluates to `false` and the other evaluates to `unknown`
            
            $\to$ `OR` of two arguments evaluates to `unknown` 
    * *`AND` operation*. 
        * If either argument evaluates to `false`

            $\to$ `AND` of two arguments evaluates to `false`
        * If one argument evaluates to `unknown` and the other evaluates to `true` or `unknown`
            
            $\to$ `AND` of two arguments evaluates to `unknown`

### Impact on SQL constructs
**`null` in `WHERE` clause**. The qualification in the `WHERE` clause eliminates rows, for which the qualification does not evaluate to `true`

$\to$ Any row evaluating to `false` or to `unknown` is eliminated
* *Consequence*. Eliminating rows evaluating to `unknown` has a subtle but significant impact on queries, especially nested queries involving `EXISTS` or `UNIQUE`

**`null` and duplicated rows**. Another prolem with `null` is the definition of when two rows in a relation instance are regarded as duplicates
* *Definition of duplication*. Two rows are duplicates if corresponding columns are either equal, or both contain `null`

    $\to$ Contrast this definition with the fact that if we compare two `null` values using `=`, the result is `unknown`
    * *Solution*. In the context of duplicates, the comparison is implicitly treated as `true`, which is an anomaly

**`null` and aggregated operations**. The arithmetic operations `+`, `−`, `∗`, and `=` all return `null` if one of their arguments is `null`

$\to$ However, `null`s can cause some unexpected behavior with aggregate operations
* *Example*. 
    * `COUNT(*)` handles null values just like other values, i.e. they get counted
    * All the other aggregate operations, e.g. `COUNT`, `SUM`, `AVG`, `MIN`, `MAX`, and variations using `DISTINCT)`, simply discard `null` values
    * If one of the operators above, other than `COUNT`, is applied to only `null` values
        
        $\to$ The result is `null`

### Outer joins
**Outer join**. An interesting variant of the join operation, which rely on null values
* *Idea*. Rows of a table without a matching row in another table appear exactly once in the result
    
    $\to$ The resulting columns inherited from the other table assigned `null` values
* *Left outer join*. Rows of a table without a matching in another row appear in the result, but not vice versa
* *Right outer join*. Rows of the other table without a matching row in the underlying table appear in the result,
but not vice versa
* *Full outer join*. Rows in both tables without a match in the other row appear in the result

### Disallowing null values
**Disallowing null values**. Use `NOT NULL` as part of the field definition, e.g. `sname CHAR(20) NOT NULL`

>**NOTE**. There is an implicit NOT NULL constraint for every field listed in a `PRIMARY KEY` constraint

## Embedded SQL
**Interactive SQL interface**. Users can directly enter SQL commands

$\to$ This approach is fine if the task can be accomplished entirely with SQL commands
* *Drawback*. Sometimes we need the greater flexibility of a general-purpose programming language, in addition to the data manipulation facilities provided by SQL

    $\to$ The SQL standard defines how SQL commands can be executed from within a program in a host language, e.g. C or Java

**Embedded SQL**. The use of SQL commands within a host language program
* *Embedded SQL details*. Depend on the host language
    * *Example*. Although similar capabilities are supported for a variety of host languages, the syntax sometimes varies
* *Embedding SQL commands*. Conceptually straightforward
    * *SQL statements*. Can be used wherever a statement in the host language is allowed, with a few restrictions
    * *Requirements*. 
        * SQL statements must be clearly marked so that a preprocessor can deal with them before invoking the compiler for the host language
        * Any host language variables used to pass arguments into an SQL command must be declared in SQL
        * Some special host language variables must be declared in SQL
            * *Explain*. Allow any error conditions arising during SQL execution to be communicated back to the main application program in the host language
* *Required features to facilitate embedded SQL*.
    * The data types recognized by SQL may not be recognized by the host language, and vice versa
        * *Solution*. Cast data values appropriately before passing them to or from SQL commands
    * SQL is set-oriented and programming languages do not typically have a data type for sets or multisets of rows
        * *Set-oriented SQL*. Commands operate on and produce tables, which are sets, or multisets, of rows
        * *Consequence*. The interface to the host language is constrained to be one row at a time
        * *Solution*. Use cursor mechanism

>**NOTE**. We assume that the host language is C for concreteness

### Declaring variables and exceptions
**Host-language variables in SQL statements**. 
* *Reference to host-language variables*. SQL statements can refer to variables defined in the host program
    * *Requirements*. 
        * Host-language variables must be prefixed by a colon `:` in SQL statements
        * Host-language variables must be declared between the commands 
            
            ```sql
            EXEC SQL BEGIN DECLARE SECTION
            ```
            
            and
            
            ```sql
            EXEC SQL END DECLARE SECTION
            ```

* *Declaration of host-language variables*. The declarations are similar to how they would look in a C program and,
as usual in C, are separated by semicolons
    * *Example*.

        ```sql
        EXEC SQL BEGIN DECLARE SECTION
        char c_sname[20];
        long c_sid;
        short c_rating;
        float c_age;
        EXEC SQL END DECLARE SECTION
        ```

    * *Explain*. The given code declared a collection of C variables, whose values are intended to be read and possibly set, in an SQL run-time environment when an SQL statement referring to them is executed
* *Example*. https://github.com/suhass90/Embedded-SQL-Programming-in-C/blob/master/sn0027Company.c

**Type mapping between host language and SQL**. The SQL-92 standard defines a type correspondence between the host language types and SQL types for a number of host languages

**Exceptions**. SQL needs some way to report what went wrong if an error condition arises when executing an SQL statement

$\to$ The SQL-92 standard recognizes two special variables for reporting errors, `SQLCODE` and `SQLSTATE`
* *`SQLCODE`*. Defined to return some negative value when an error condition arises, without specifying further what error a particular negative integer denotes.
* *`SQLSTATE`*. Associate predefined values with several common error conditions
    
    $\to$ This introduces some uniformity to how errors are reported

>**NOTE**. One of these two variables must be declared

* *Type mapping*. 
    * The appropriate C type for `SQLCODE` is `long`
    * The appropriate C type for `SQLSTATE` is `char[6]`

### Embedding SQL statements
**Embedding SQL statements**. All SQL statements that are embedded within a host program must be clearly marked, with the details dependent on the host language
* *Embedding SQL statements in C*. SQL statements must be prefixed by `EXEC SQL`
* *Allowed location for SQL statements*. Any place in the host language program, where a host language statement can appear
* *Examples*.
    
    ```sql
    EXEC SQL INSERT INTO Sailors VALUES (:c sname, :c sid, :c rating, :c age);
    ```

**Error checking**. The `SQLSTATE` variable should be checked for errors and exceptions after each embedded
SQL statement
* *`WHENEVER` command*. Provided by SQL to simplify this task, e.g.

    ```sql
    EXEC SQL WHENEVER [ SQLERROR j NOT FOUND ] [ CONTINUE j GOTO stmt ]
    ```

* *Explain*. After each embedded SQL statement is executed, the value of `SQLSTATE` should be checked
    * If `SQLERROR` is specified and the value of `SQLSTATE` indicates an exception
        
        $\to$ Control is transferred to `stmt`, which is presumably responsible for error/exception handling
    * Control is also transferred to `stmt` if `NOT FOUND` is specified, and the value of `SQLSTATE` is `02000`, i.e. `NO DATA`

## Cursors
**A major problem in embedding SQL statements**. SQL operates on sets of records, whereas the host languages do not cleanly support a set-of-records abstraction

$\to$ We need a mechanism allowing us to retrieve rows one at a time from a relation, i.e. a cursor

**Cursor**. We can declare a cursor on any relation or on any SQL query, i.e. since every query returns a set of rows
* *Operations on cursor*. Once a cursor is declared, we can
    * Open it, i.e. position the cursor just before the first row
    * Fetch the next row
    * Move the cursor to the next row by specifying additional parameters for the `FETCH` command
        * *Example*. Move the cursor to the row after the next $n$, to the first row, or to the previous row, etc. 
    * Close the cursor
* *Conclusion*. A cursor essentially allows us to retrieve the rows in a table by positioning the cursor at a particular row and reading its contents

    $\to$ The cursor acts like a file descriptor

### Basic cursor definition and usage
**Cursors**. Enable us to examine in the host language program a collection of rows computed by an embedded SQL statement
* *Explain*.
    * We usually need to open a cursor if the embedded statement is a `SELECT`
        
        >**NOTE**. We can avoid opening a cursor if the answer contains a single row
    
    * `INSERT`, `DELETE`, and `UPDATE` statements typically do not require a cursor
        
        >**NOTE**. Some variants of `DELETE` and `UPDATE` use a cursor

* *Query without cursor*. The `INTO` clause assigns the columns of the single answer row to the host variables
    
    $\to$ We do not need a cursor to embed the query in a host language program

    ```sql
    EXEC SQL SELECT S.sname, S.age
    INTO :c sname, :c age
    FROM Sailors S
    WHERE S.sid = :c sid;
    ```

* *Query with cursor*. Consider a query returning a collection of rows
    * *`INTO` clause approach*. Not adequate since we must deal with several rows
    * *Cursor approach*.

        ```sql
        DECLARE sinfo CURSOR FOR
        SELECT S.sname, S.age
        FROM Sailors S
        WHERE S.rating > :c_minrating;
        ```

    * *Explain*. This code can be included in a C program, and once it is executed
        
        $\to$ The cursor `sinfo` is defined
        * *Consequence*. We can open the cursor with the following statement

            ```sql
            OPEN sinfo;
            ```
        
        >**NOTE**. The value of `c_minrating` associated with the cursor is the value of this variable when we open the cursor
    
    * *Processing order*. 
        * The cursor declaration is processed at compile time
        * The `OPEN` command is executed at run-time

**Interpretation of cursor**. A cursor can be thought of as pointing to a row in the collection of answers to the
associated query
* *Opening a cursor*. When a cursor is opened, it is positioned just before the first row
* *Reading a cursor*. Use the `FETCH` command to read the first row of cursor sinfo into host language variables, i.e.
    
    ```sql
    FETCH sinfo INTO :c sname, :c age;
    ```

    * *Execution detrails*. When the `FETCH` statement is executed
        1. The cursor is positioned to point at the next row
        2. The column values in the row are copied into the corresponding host variables
    * *Consequence*. By repeatedly executing the `FETCH` statement
        
        $\to$ We can read all the rows computed by the query, one row at a time
    * *Additional parameter*. Allow us to position a cursor in flexible ways
    * *Termination condition for reading a cursor*. How do we know when we have looked at all the rows associated with the cursor?
        * *Idea*. Look at `SQLCODE` or `SQLSTATE` 
        * *Example*. `SQLSTATE` is set to `02000` to denote `NO DATA`
            
            $\to$ There are no more rows if the `FETCH` statement positions the cursor after the last row
* *Close a cursor*. When we are done with a cursor, we can close it

    ```sql
    CLOSE sinfo;
    ```

* *Reopening a cursor*. The cursor can be opened again if needed

    $\to$ The value of `:c_minrating` associated with the cursor would be the value of the host variable `c_minrating` at that time

### Properties of cursors
**General form of a cursor declaration**.

```sql
DECLARE cursorname [INSENSITIVE] [SCROLL] CURSOR FOR
some query
[ ORDER BY order-item-list ]
[ FOR READ ONLY j FOR UPDATE ]
```

* *Read-only cursor* A cursor can be declared to be a read-only cursor, i.e. `FOR READ ONLY`
* *Updatable cursor*. If the cursor is on a base relation or an updatable view
    
    $\to$ It is updatable, i.e. `FOR UPDATE`
    * *Consequence*. Simple variants of the `UPDATE` and `DELETE` commands allow us to update or delete the row, on which the cursor is positioned
    * *Example*.

        ```sql
        UPDATE Sailors S
        SET S.rating = S.rating - 1
        WHERE CURRENT of sinfo;
        ```

        and

        ```sql
        DELETE Sailors S
        WHERE CURRENT of sinfo;
        ```

    >**NOTE**. A cursor is updatable by default unless it is a scrollable or insensitive cursor, in which case it is read-only by default

* *Scrollable cursor (`SCROLL`)*. Variants of the `FETCH` command can be used to position the cursor in flexible ways

    $\to$ Otherwise, only the basic `FETCH` command, which retrieves the next row, is allowed
* *Insensitive cursor (`INSENSITIVE`)*. The cursor behaves as if it is ranging over a private copy of the collection of answer rows
    
    $\to$ Otherwise, and by default, other actions of some transaction could modify these rows, creating unpredictable behavior
    * *Example*. Consider fetching rows using the `sinfo` cursor, which is concurrently modified using the following command

        ```sql
        UPDATE Sailors S
        SET S.rating = S.rating - 1
        ```

        * *Scenario*. Consider a `Sailors` row, which 
            * Have not yet been fetched
            * The original rating value would have met the condition in the `WHERE` clause of the associated query
            * The new rating value does not meet the condition in `WHERE`
        * *Consequence*.
            * If `INSENSITIVE` is specified, the behavior is as if all answers were computed and stored when `sinfo` was opened
                
                $\to$ The update command has no effect on the rows fetched by `sinfo`, if it is executed after `sinfo` is opened
            * If `INSENSITIVE` is not specified, the behavior is implementation dependent in the situation

**Fetching order**. The row fetching order is unspecified, but the optional `ORDER BY` clause can be used to specify a sort order

>**NOTE**. Columns mentioned in the `ORDER BY` clause cannot be updated through the cursor

* *Order-item-list*. A list of order-items
    * *Order-item*. A column name, optionally followed by one of the keywords `ASC` or `DESC`
* *Requirements*. Every column mentioned in the `ORDER BY` clause must also appear in the select-list of the associated query
    
    $\to$ Otherwise it is not clear what columns we should sort on
* *`ASC` and `DESC` keywords*. Control whether the result should be sorted w.r.t that column in ascending or descending order
    * *Default sort order*. `ASC`
* *Execution order*. `ORDER BY` clause is applied as the last step in evaluating the query

## Dynamic SQL
**Problem of interest**.
* *Scenario*. Consider an application, which needs to access data from a DBMS
    * The application must accept commands from a user 
    * The application, based on what the user needs, generate appropriate SQL statements to retrieve the necessary data
* *Problem*. We cannot predict in advance what SQL statements need to be executed

**Dynamic SQL**. Provided by SQL to deal with the problem above
* *Main commands*. `PREPARE` and `EXECUTE`
* *Example*.

    ```sql
    char c_sqlstring[] = f"DELETE FROM Sailors WHERE rating>5"g;
    EXEC SQL PREPARE readytogo FROM :c sqlstring;
    EXEC SQL EXECUTE readytogo;
    ```

    * *Explain*.
        1. Declare the C variable `c_sqlstring` and initializes its value to the string representation of an SQL command
        2. Parse and compile `c_sqlstring` as an SQL command, with the resulting executable bound
to the SQL variable `readytogo`
        3. Execute the command
* *Preparation overhead*. The preparation of a dynamic SQL command occurs at run-time and is a run-time overhead
    
    $\to$The use of dynamic SQL should be limited to situations, in which it is essential

## ODBC and JDBC
**DBMS-specific embedded SQL**. A DBMS-specific preprocessor transforms the embedded SQL statements into function calls in the host language
* *Consequence*. The details of the translation vary across DBMS
    
    $\to$ The final executable works only with one specific DBMS

**Open DataBase Connectivity (ODBC) and Java DataBase Connectivity (JDBC)**. Enable the integration of SQL with a general-purpose programming language
* *Idea*. Expose database capabilities in a standardized way to the application programmer through an API
* *Difference from embedded SQL*. 
    * ODBC and JDBC allow a single executable to access different DBMSs without recompilation
        
        $\to$ Applications using ODBC or JDBC are DBMS-independent at the source code level, and at the executable level
    * Using ODBC or JDBC an application can access several different DBMSs simultaneously
* *Portability at executable levle of ODBC and JDBC*. Achieved by introducing an extra level of indirection
    * *Idea*. All direct interaction with a specific DBMS happens through a DBMS specific driver
    * *DBMS driver*. A software program that translating the ODBC or JDBC calls into DBMS-specific calls
    * *Dynamically loaded driver*. Since it is only known at run-time which DBMSs the application is going to access
        
        $\to$ Drivers are loaded dynamically on demand
    * *Driver manager*. Existing drivers are registered with a driver manager, which manages the set of existing drivers
* *Driver interaction with non-SQL DBMS*. A driver does not necessarily need to interact with a DBMS understanding SQL
    
    $\to$ The driver only needs to translate the SQL commands from the application into equivalent commands understandable by the DBMS
* *Data source*. A data storage subsystem, with which a driver interacts

**Interaction with data source via ODBC and JDBC**. An application interacting with a data source through ODBC or JDBC performs the following steps
1. A data source is selected, the corresponding driver is dynamically loaded, and a connection with the data source is established
    * *Number of open connections*. There is no limit on the number of open connections
        
        $\to$ An application can have several open connections to different data sources
    * *Transaction semantics of data source connection*. Changes from one connection are only visible to other connections after the connection has committed its changes
2. While a connection is open, transactions are executed by
    1. Submitting SQL statements
    2. Retrieving results
    3. Processing errors
    4. Committing or rolling back
3. The application disconnects from the data source to terminate the interaction

### Architecture
**ODBC/JDBC architecture**. Have four main components, i.e. the application, the
driver manager, several data source specific drivers, and the corresponding data sources
* *Application component*. 
    * Initiate and terminate the connection with the data source
    * Set transaction boundaries, submit SQL statements, and retrieve the results
        
        $\to$ All through a well-defined interface as specified by the ODBC/JDBC API
* *Driver manager component*. 
    * Load ODBC/JDBC drivers and to pass ODBC/JDBC function calls from the application to the correct driver
    * Handle ODBC/JDBC initialization and information calls from the applications and can log all function calls
    * Perform some rudimentary error checking
    * Establish the connection with the data source
    * Translate data, error formats, and error codes from a data-source-specific form into the ODBC/JDBC standard
* *Data source component*. Process commands from the driver and returns the results

**Architectural scenarios**. Depending on the relative location of the data source and the application

$\to$ Several architectural scenarios are possible
* *Types of drivers in JDBC*. Depending on the architectural relationship between the application and the data source
    1. *Bridges*. Translate JDBC function calls into function calls of another API, which is not native to the DBMS
    2. *Direct translation to the native API*. Translate JDBC function calls directly into method invocations of the API of one specific data source
        
        $\to$ The driver is dynamically linked, and is specific to the data source
    3. *Network bridges*. Talk over a network to a middle-ware server translating the JDBC requests into DBMS-specific method invocations
        
        $\to$ The driver on the client site, i.e. the network bridge, is not DBMS-specific
    4. *Direct translation over sockets*. Communicate with the DBMS through Java sockets
        
        $\to$ The driver on the client side is DBMS-specific

## Complex integrity constraints in SQL-92

### Constrasints over a single table
**Constrasints over a single table**. Use table constraints, which have the form `CHECK` conditional-expression
* *Example*.

    ```sql
    CREATE TABLE Sailors ( sid INTEGER,
                           sname CHAR(10),
                           rating INTEGER,
                           age REAL,
                           PRIMARY KEY (sid),
                           CHECK ( rating >= 1 AND rating <= 10 ))
    ```

### Domain constraints
**Domain constraints**. A user can define a new domain using the `CREATE DOMAIN` statement, which makes use of `CHECK` constraints, e.g.

```sql
CREATE DOMAIN ratingval INTEGER DEFAULT 0
CHECK ( VALUE >= 1 AND VALUE <= 10 )
```

* *Explain*.
    * `INTEGER` is the base type for the domain `ratingval`
        
        $\to$ Every `ratingval` value must be of this type
    * Values in `ratingval` are further restricted by using a `CHECK` constraint
    * `VALUE` refers to a value in the domain, i.e. we constrain the values of the domain
    * `DEFAULT` is optional and is used to associate a default value with a domain
        * *Explain*. If the domain ratingval is used for a column in some relation, and no value is entered for this column in an inserted tuple
            
            $\to$ The associated default value `0` is used
        * *Domain default value and table default value*. If a default value is specified for the column as part of the table definition
            
            $\to$ This takes precedence over the default value associated with the domain
        * *Usage*. Minimize data entry errors, i.e. common default values are automatically filled in rather than being typed in
* *Using domain constraints*. Once a domain is defined, the name of the domain can be used to restrict column values in a table
    * *Example*. 

        ```sql
        CREATE TABLE Sailors ( sid INTEGER,
                               sname CHAR(10),
                               rating ratingval,
                               age REAL,
                               PRIMARY KEY (sid))
        ```

**Support for domains in SQL-92**. SQL-92’s support for the concept of a domain is limited in an important respect
* *Comparing values from different domains*. Comparisons between two values from different domains with the same base type always succeed

    $\to$ Such comparisons should be fail instead

### Assertions - ICs over several tables
**Problem with table constraints**.
* Although the conditional expression in the `CHECK` clause can refer to other tables
    
    $\to$ Table constraints are associated with a single table, 
* Table constraints are required to hold only if the associated table is nonempty
    * *Consequence*. When a constraint involves two or more tables
    
        $\to$ The table constraint mechanism is cumbersome and not desired

**Assertion**. Supported by SQL, to introduce constraints not associated with any one table

## Triggers and active databases
**Trigger**. A procedure, which is automatically invoked by the DBMS in response to specified changes to the database, and is typically specified by the DBA
* *Active database*. A database having a set of associated triggers
* *Trigger description*. Contain three parts
    * *Event*. A change to the database that activates the trigger
    * *Condition*. A query or test that is run when the trigger is activated
    * *Action*. A procedure that is executed when the trigger is activated and its condition is true
* *Trigger and daemon*. A trigger can be thought of as a ‘daemon’ monitoring a database
    
    $\to$ The daemon is executed when the database is modified in a way that matches the event specification

**Trigger condition**. Can be a true/false statement or a query

$\to$ If the condition part evaluates to true, the action associated with the trigger is executed
* *Boolean representation of a query*. A query is interpreted as true if the answer set is nonempty, and false if the query has no answers

**Trigger action**. 
* *Possible actions*. A trigger action can 
    * Examine the answers to the query in the condition part of the trigger
    * Refer to old and new values of tuples modified by the statement activating the trigger
    * Execute new queries
    * Make changes to the database
    * Execute a series of data-definition commands, e.g. create new tables, change authorizations
    * Execute transaction-oriented commands, e.g. commit
    * Call host-language procedures
* *Execution order relative to parent statement*. An important issue is when the action part of a trigger executes in relation to the statement that activated the trigger
    * *Explain*. Depending on exactly what the trigger does
        
        $\to$ We may want its action to execute before changes are made, or after
* *Other types of action scheduling*. 
    * A trigger can be scheduled to execute instead of the activating statement
    * A trigger can be scheduled to execute in deferred fashion, at the end of the transaction containing the activating statement
    * A trigger can be scheduled to execute in asynchronous fashion, as part of a separate transaction

**Row-level and statement-level trigger**.
* *Row-level trigger*. The triggering event defined to occur for each modified record
* *Statement-level trigger*. The triggering event is defined just once per statement, regardless of the number of records changed

## Designing and active databases
**Usage of triggers**. Triggers offer a powerful mechanism for dealing with changes to a database, but they
must be used with caution
* *Explain*. 
    * The effect of a collection of triggers can be very complex
    * Maintaining an active database can become very difficult
* *Consequence*. A judicious use of integrity constraints can replace the use of triggers

### Why triggers can be hard to understand
**Execution of a trigger inside a statement**. In an active database system, when the DBMS is about to execute a statement that modifies the database
1. It checks whether some trigger is activated by the statement
2. If there is some, the DBMS processes the trigger by evaluating its condition part
    
    $\to$ If the condition evaluates to true, the DBMS executes the action part
3. If a statement activates more than one trigger
    
    $\to$ The DBMS typically processes all of them, in some arbitrary order

**Chained triggers**. The execution of the action part of a trigger could in turn activate another trigger. In particular
* *Recursive triggers*. The execution of the action part of a trigger could activate the same trigger
* *Consequence*. The effect of a collection of triggers is difficult to understand, due to
    * The potential for such chain activations
    * The unpredictable order in which a DBMS processes activated triggers

### Constraints versus triggers
**Constraints versus triggers**. A common use of triggers is to maintain database consistency

$\to$ In such cases, we should always consider whether using an integrity constraint will achieve the same goals
* *Benefits of constraints*. 
    * The meaning of a constraint is not defined operationally, unlike the effect of a trigger
        * *Consequences*. 
            * A constraint is easier to understand
            * The DBMS is given more opportunities to optimize execution
    * A constraint prevents the data from being made inconsistent by any kind of statement
        
        $\to$ This contrasts a trigger, which is activated by a specific kind of statement
        * *Consequence*. A constraint easier to understand
* *Benefits of triggers*. Allo us to maintain database integrity in more flexible ways

### Other uses of triggers
**Other uses of triggers**. Many potential uses of triggers go beyond integrity maintenance
* *Triggers as alerts*. Triggers can alert users to unusual events, as reflected in updates to the database
* *Trigger as event logger*. Triggers can generate a log of events to support auditing and security checks
* *Triggers as statistic collector*. Triggers can be used to gather statistics on table accesses and modifications

# Appendix
## Concepts
**Levels of SQL-92**. 
* *Problem*. When the standard is updated, DMBS vendors are usually not able to immediately conform to the new standard in their next product releases
    * *Explain*. They have to address issues, e.g. performance improvements and better system management
    * *Consequence*. Three SQL-92 levels have been defined, i.e. Entry SQL, Intermediate SQL, and Full SQL. Of these
* *Levels of SQL-92*.
    * *Entry SQL*. Closest to the previous standard, i.e. SQL-89
        
        $\to$ This is the easiest for a vendor to support
    * *Intermediate SQL*. Include about half of the new features of SQL-92
    * *Full SQL*. The complete language
* *Purposes*.
    * To make it possible for vendors to achieve full compliance with the standard in steps
    * To make it possible for customers to get an idea of how complete a vendor’s support for SQL-92 really is, at each of these steps

**Regular expressions in SQL**. Reflecting the increased importance of text data,

$\to$ SQL-1999 includes a more powerful version of the `LIKE` operator called `SIMILAR`
* *`SIMILAR` operator*. Allow a rich set of regular expressions to be used as patterns while searching text
    
    $\to$ The regular expressions are similar to those supported by the Unix OS for string searches, although the syntax is a little different

**Transaction boundary**. Where the transaction starts, or is committed or rollbacked
* *Transaction (unit of work)*. A sequence of one or more SQL operations grouped together as a single unit, usually within an application process
    * *Atomicity*. A transaction is indivisible, i.e. either all of its work is carried out, or none of its work is carried out
    * *Number of SQL operations*. A given transaction can perform any number of SQL operations, depending on what is considered a "single step" within the business logic
        * *Effects of long transactions*. A sign of a poorly written application
            * The more database concurrency decreases
            * The more resource locks are acquired
* *Points of data consistency*. The initiation and termination of a single transaction defines points of data consistency within a database
    * *Commit and rollback*. 
        * *Commit*. The effects of all operations performed within a transaction are applied to the database and made permanent
        * *Rollback*. The effects of all operations performed are backed out
            
            $\to$ The database is returned to the state it was in before the transaction was initiated
    * *Transaction initiation*. 
        * Transactions are initiated the first time an executable SQL statement is executed after a connection to a database has been made, or
        * Transactions are initiated immediately after a pre-existing transaction has been terminated
    * *Transaction termination*. Once initiated
        * Transactions can be implicitly terminated using automatic commit
            * *Explain*. 
                * Each executable SQL statement is treated as a single transaction
                * Any changes made by the statement are applied to the database if the statement executes successfully or discarded if the statement fails
        * Transactions can be explicitly terminated by using `COMMIT` or `ROLLBACK` SQL statement
    * *Locality of commit and rollback*. Commit and rollback operations only have an effect on changes made within the transaction they terminate
        * *Consequence*. To evaluate the effects of a series of transactions
            
            $\to$ We must identify where each transaction begins, and when and how each transaction is terminated
* *Transaction commit and system failure*.
    * *Uncommited changes*. Changes made by a transaction that have not been committed
        * Usually inaccessible to other users and applications
        * Can be backed out with a rollback operation
    * *Committed changes*. Once changes made by a transaction have been committed
        * They become accessible to all other users and/or applications
        * They can only be removed by executing new `UPDATE` or `DELETE` SQL statements, i.e. from a new transaction
    * *Problem of interest*. A system failure may occur before a transaction's changes can be committed
        * *System failure without DBMS failure*. The DBMS backs out all uncommitted changes, by replaying information stored in the transaction log files
            
            $\to$ The database is returned to the state it was in just before the unexpectedly terminated transaction began
        * *System failure with DBMS failure*. The next time the database is restarted
            
            $\to$ The DBMS will try to roll back all open transactions it finds in the database's transaction log files
            
            >**NOTE**. Only after this succeeds will the database be placed online again, i.e. accessible to users and applications

* *Transaction management and savepoints*.
    * *Transaction size*. It is often desirable to limit the amount of work performed within a single transaction
        * *Drawbacks of large transaction*.
            * Locks acquired on behalf of the transaction cannot be released in a timely manner
                * *Explain*. When locks are held by one transaction
                    
                    $\to$ Other transactions may be forced to wait for those locks to be freed before they can continue
            * If a large number of changes are made within a single transaction
                
                $\to$ It can take a considerable amount of time to back those changes, if the transaction is rolled back
        * *Drawbacks of small transactions*. 
            * If business rules have to cross several transaction boundaries
                
                $\to$ The opportunity for data inconsistency to occur will be increased
            * Each time a `COMMIT` statement is used to terminate a transaction
                
                $\to$ The DBMS must perform extra work to commit the current transaction and start a new one
            * Portions of an operation might be committed, hence be visible to other applications before the operation is completed
    * *Savepoints*. Used to allow an application to break work being performed by a large transaction into one or more subsets
        * *Benefits*. 
            * An application avoids the exposure to "dirty data", which might occur when multiple commits are performed
            * Provide granular control over an operation, i.e. as long as the savepoints used are not nested
                
                $\to$ We can use as many savepoints as you want within a single transaction
* *Reference*. https://flylib.com/books/en/4.528.1.38/1/