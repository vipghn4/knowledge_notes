---
title: 7. Input output
tags: Computer architecture
---

<!-- TOC titleSize:2 tabSpaces:2 depthFrom:1 depthTo:6 withLinks:1 updateOnSave:1 orderedList:0 skip:0 title:1 charForUnorderedList:* -->
## Table of Contents
- [Input output](#input-output)
  - [External devices](#external-devices)
    - [Keyboard / monitor](#keyboard--monitor)
    - [Disk drive](#disk-drive)
  - [I/O modules](#io-modules)
    - [Module function](#module-function)
    - [I/O module structure](#io-module-structure)
  - [Programmed I/O](#programmed-io)
    - [Overview of programmed I/O](#overview-of-programmed-io)
    - [I/O command](#io-command)
    - [I/O instructions](#io-instructions)
  - [Interrupt-driven I/O](#interrupt-driven-io)
    - [Interrupt processing](#interrupt-processing)
    - [Design issues](#design-issues)
    - [Intel 82C59A interrupt controller](#intel-82c59a-interrupt-controller)
<!-- /TOC -->

# Input output
**I/O module**. Each module interfaces to the system bus or central switch, and controls one or more peripheral devices

<div style="text-align:center">
    <img src="https://i.imgur.com/Hd75lb9.png">
    <figcaption>I/O module</figcaption>
</div>

* *Structure*.
    * A set of mechanical connectors wiring a device into the system bus 
    * Logic for performing a communication function between the peripheral and the bus 
* *Why don't peripherals directly connect to the system bus*.
    * *Explain*.
        * There are a wide variety of peripherals with various methods of operation

            $\to$ It is impractical to incorporate the necessary logic within the processor to control a range of devices
        * The data transfer rate of peripherals is often much slower than that of the memory or processor
            
            $\to$ It is impractical to use the high-speed system bus to communicate directly with a peripheral
        * The data transfer rate of some peripherals is faster than that of the memory or processor

            $\to$ The mismatch would lead to inefficiencies if not managed properly
        * Peripherals often use different data formats and word lengths than the computer to which they are attached
    * *Consequence*. An I/O module is required
* *Major functions*.
    * Interface to the processor and memory via the system bus, or central switch
    * Interface to one or more peripheral devices by tailored data links

## External devices
**I/O operations**. Accomplished through a wide classificaiton of external devices, which provide a means of exchanging data between the external environment and the computer
* *Links*. An external device attaches to the computer by a link to an I/O module
    * *Usage*. Exchange control, status, and data between the I/O module and the external device
* *Peripheral device*. An external device connected to an I/O module

**Types of external devices**.
* *Human readable*. Suitable for communicating with the computer user
    * *Example*. Video display terminals (VDTs) and printers
* *Machine readable*. Suitable for communicating with equipment
    * *Example*. Magnetic disk and tape systems, and sensors and actuators (in robotics)
* *Communication*. Suitable for communicating with remote devices
    * *Explain*. Communication devices allow a computer to exchange data with a remote device, which may be a human-readable device, a machine-readable device, or even another computer

**The nature of an external device**.

<div style="text-align:center">
    <img src="https://i.imgur.com/hTMmGYc.png">
    <figcaption>Block diagram of an external device</figcaption>
</div>

* *Interface to the I/O module*. Control, data, and status signals
    * *Control signals*. Determine the function which the device will perform, e.g. 
        * Send data to the I/O module, i.e. INPUT or READ
        * Accept data from the I/O module, i.e. OUTPUT or WRITE
        * Report status
        * Perform some control function particular to the device, e.g. position a disk head
    * *Data signals*. A set of bits to be sent to or received from the I/O module
    * *Status signals*. Indicate the state of the device, e.g. READY or NOT-READY
* *Control logic associated with the device*. Control the device's operation in response to direction from the I/O module
* *Transducer*. Convert data from electrical to other forms of energy (during output), and from other forms to electrical (during input)
    * *Transducer buffer*. Typically, a buffer is associated with the transducer to temporarily hold data being transferred between the I/O module and the external environment
    * *Common buffer size*. 8 to 16 bits

### Keyboard / monitor
**Keyboard / monitor**. The most common means of computer/user interaction
* *Mechanism*. 
    1. The user provides input through the keyboard
    2. The input is then transmitted to the computer, and may also displayed on the monitor
    3. The monitor displays data provided by the computer
* *Basic unit of exchange*. The character, associated with a code of typically 7 or 8 bits in length
    * *Most commonly used text code*. IRA (international reference alphabet)
        * *Text code representation*. Each character in represented by a unique 7-bit binary code

            $\to$ 128 different characters can be represented
    * *Types of characters*.
        * *Printable characters*. The alphabet, numeric, and special characters which can be printed on paper or displayed on a screen
        * *Control characters*. 
            * Control the printing or displaying of characters
                * *Example*. Carriage return, i.e. `<CR>` or "Enter" 
            * Concern with communications procedures
* *Hardware implementation*.
    1. The user depresses a key to generate an electronic signal
    2. The signal is interpreted by the transducer in the keyboard and translated into the bit pattern of the corresponding IRA code
    3. The bit pattern is transmitted to the I/O module in the computer
    4. At the computer, the text can be stored in the same IRA code
    5. On output, IRA code characters are transmitted to an external device from the I/O module
    6. The transducer at the device interpretes the IRA code and sends the required electronic signals to the output device to display the indicated character, or perform the requested control function

### Disk drive
**Disk drive**. 
* *Structure*. Contain 
    * Electronics for exchanging data, control, and status signals with an I/O module
    * Electronics for controlling the disk read/write mechanism
* *Fixed-head disk*. The transducer is capable of converting between the magnetic patterns on the moving disk surface and bitsin the device's buffer
* *Moving-head disk*. The transducer is capable of causing the disk arm to move radially in and out across the disk's surface

## I/O modules
### Module function
**Types of major functions or requirements for an I/O module**.
* Control and timing
* Processor communication
* Device communication
* Data buffering
* Error detection

**Control and timing**.
* *Motivation*. During any period of time, the processor may communicate with one or more external devices in unpredictable patterns, depending on the program's need for I/O

    $\to$ Internal resources, e.g. main memory and the system bus, must be shared among a number of activities, including data I/O
* *Consequence*. The I/O function includes a control and timing requirement, to coordinate the flow of traffic between internal resources and external devices
* *Contorl of transfer of data from an external device to the processor*.
    1. The processor interrogates the I/O module to check the status of the attached device
    2. The I/O model returns the device status
    3. If the device is operational and ready to transmit

        $\to$ The processor requests the transfer of data, by means of a command to the I/O module
    4. The I/O module obtains a unit of data, e.g. 8 or 16 bits, from the external device
    5. The data are transferred from the I/O module to the processor

        >**NOTE**. If the system employs a bus, then each of the interaction between the processor and the I/O module involves one or more bus arbitrations

**Processor communication**. The I/O module must communicate with the processor and with the external device
* *Types of processor communication*.
    * *Command decoding*. The I/O module accepts commands from the processor, typically sent as signals on the control bus
    * *Data*. Data are exchanged between the processor and the I/O module over the data bus
    * *Status reporting*. Since peripheral are slow, it is important to know the status of the I/O module, i.e. BUSY or READY
    * *Address recognition*. I/O devices have addresses, just as memory words

        $\to$ An I/O module must recognize one unique address for each peripheral it controls

**Device communication**. The I/O module must be able to perform device communication, involving commands, status information, and data

**Data buffering**. 

>**NOTE**. This is an essential task of an I/O module

* *Motivation*. The transfer rate into and out of main memory or the processor is quite high, but the rate is orders of magnitude lower for many peripheral devices and covers a wide range
* *Buffering mechanism*.
    * *Slow output device*. If an output device has a buffer, the computer can fill it quickly then go to other things, while the output devices does its output
    * *Slow input device*. The device trickles data into a buffer in the computer, and when it is completed, the OS gives the whole buffer, all at once to the application
* *Example*.
    * *Memory-to-peripheral data flow*.
        1. Data coming from main memory are sent to an I/O module in a rapid burst
        2. The data are buffered in the I/O module, and then sent to the peripheral device at its data rate
    * *Peripheral-to-memory data flow*. Data are buffered so as not to tie up the memory in a slow transfer operation
* *Consequence*. 
    * The I/O module must be able to operate at both device and memory speeds
    * If the I/O device operates at a rate higher than the memory access rate, then the I/O module performs the required buffering operation

**Error detection**. An I/O module is often responsible for error detection and subsequently reporting errors to the processor
* *Example types of errors*.
    * Mechanical and electrical malfunctions reported by the device, e.g. paper jam, bad disk track, etc.
    * Unintentional changes to the bit pattern as it is transmitted from device to I/O module

### I/O module structure

>**NOTE**. I/O modules vary considerably in complexity and the number of external devices they control

**General block diagram of an I/O module**.

<div style="text-align:center">
    <img src="https://i.imgur.com/c4XWwju.png">
    <figcaption>Block diagram of an I/O module</figcaption>
</div>

* *Connection to the computer*. The I/O module connects to the rest of the computer through a set of signal lines, e.g. system bus lines
* *Data buffering*. Data transferred to and from the module are buffered in one or more data registers
* *Status register*. Function as a control register, to accept detailed information from the processor
* *Device addressing*. The I/O module must be able to recognize and generate addresses associated with the devices it controls
    * *I/O module address*. Each I/O module has a unique address, or a set of addresses if it controls more than one external device
* *I/O logic*. The I/O module contains logic specific to the interface with each device it controls

**Functionality encapsulation**. An I/O module functions to allow the processor to view a wide range of devices in a simple-minded way
* *Explain*.
    * The I/O module may hide the details of timing, formats, and the electromechanics of an external device

        $\to$ The processor can function in terms of simple read and write commands, and possibly open and close file commands

        >**NOTE**. In its simplest form, the I/O module may still leave much of the work of controlling a device visible to the processor

* *I/O channel or I/O processor*. An I/O module which takes on most of detailed processing burden, presenting a high-level interface to the processor
    * *Usage*. Commonly seen on mainframes
* *I/O controller or device controller*. An I/O module which is quite primitive and requires detailed control
    * *Usage*. Commonly seen on microcomputers

## Programmed I/O
**Types of I/O mechanism**.
* *I/O mechanisms*.
    * *Programmed I/O*. Data are exchanged between the processor and the I/O module
        * *Idea*. The processor executes a program which gives it direct control of the I/O operation, i.e.
            * Sensing device status
            * Sending a read or write command
            * Transferring the data
        * *Drawback*. When the processor issues a command to the I/O module, it must wait until the I/O operation is complete

            $\to$ If the processor is faster than the I/O module, this is wasteful of processor time
    * *Interrupt-driven I/O*. The processor issues an I/O command, continues to execute other instructions, and is interrupted by the I/O module when the latter has completed its work
* *Processor modes*.
    * *Typical mode*. The processor is responsible for extracting data from main memory for output, and storing data in main memory for input
    * *Direct memory access (DMA)*. The I/O module and main memory exchange data directly, without processor involvement

### Overview of programmed I/O
**Programmed I/O mechanism**.
* *Procedure*.
    1. When the processor is executing a program and encounters an instruction relating to I/O

        $\to$ It executes that instruction by issuing a command to the appropriate I/O module
    2. When programmed I/O, the I/O module will perform the requested action and then set the appropriate bits in the I/O status register
* *Processor alerting*. The I/O module takes no further action to alert the processor, i.e. it does not interrupt the processor

    $\to$ It is the processor;s responsibility to periodically check the status of the I/O module until it finds that the operation is complete

### I/O command
**Types of I/O commands which an I/O module may receive**.
* *Control*. Used to activate a peripheral and tell it what to do
* *Test*. Used to test various status conditions associated with an I/O module and its peripherals
* *Read*. Cause the I/O module to obtain an item of data from the peripheral and place it in an internal buffer, i.e. a data register

    $\to$ The processor can then obtain the data item by requesting that I/O module place it on the data bus
* *Write*. Cause the I/O module to take an item of data, e.g. byte or word, from the data bus, and subsequently transmit that data item to the peripheral

**Techniques for input of a block of data**. Status-checking cycle is a time-consuming process which keeps the processor busy needlessly

<div style="text-align:center">
    <img src="https://i.imgur.com/4JVJWp8.png">
    <figcaption>Three techniques for input of a block of data</figcaption>
</div>

### I/O instructions
**I/O commands and I/O instructions**/ There is a close correspondence between the I/O-related instructions fetched from memory by the processor, and the I/O commands which the processor issues to an I/O module to execute the instructions
* *Explain*. The instructions are easily mapped into I/O commands, and there is often a simple one-to-one relationship

**Device addresses**. Since there will be many I/O devices connected through I/O modules to the system, each device has a unique identifier or address

$\to$ When the processor issues an I/O command, the command contains the address of the desired device
* *Consequence*. Each I/O module must interpret the address lines to determine if the command is for itself

**Addressing modes**. When the processor, main memory, and I/O share a common bus, two modes of addressing are possible
* *Memory-mapped I/O*. There is a single address space for memory locations and I/O devices
    * *Explain*. The processor treats the status and data registers of I/O modules as memory locations, and uses the same machine instructions to access both memory and I/O devices
    * *Bus lines*. A single read line and a single write line are required on the bus
* *Isolated I/O*. Address space for I/O is isolated from that for memory
    * *Bus lines*. A singleThe bus is equipped with memory read and write, plus input and output command lines
    * *I/O data addressing*. The command line specifies whether the address refers to a memory location or an I/O device

        $\to$ The full range of addresses may be available to both, e.g. 10 address lines can support 1024 memory locations and 1024 I/O addresses
    
    >**NOTE**. With isolated I/O, the I/O ports are accessible only by special I/O commands, which activate the I/O command lines on the bus

**The interface for I/O device with memory-mapped and isolated I/O**.

<div style="text-align:center">
    <img src="https://i.imgur.com/WOyg8iI.png">
    <figcaption>Memory-mapped and isolated I/O</figcaption>
</div>

## Interrupt-driven I/O
**Procedure**.
* *Overall procedure*.
    1. The processor issues an I/O command to a module and then to on to do some other useful work
    2. The I/O module then interrupts the processor to request service when it is ready to exchange data with the processor
    3. The processor then executes the data transfer, then resumes its former processing
* *I/O module's view*.
    1. The I/O module receives a READ command from the processor
    2. The I/O module proceeds to read data in from an associated peripheral
    3. Once the data are in the module's data register, the module signals an interrupt to the processor over a control line
    4. The module then waits until its data are requested by the processor
    5. When the request is made, the module places its data on the data bus and is then ready for another I/O operation
* *Processor's point of view*.
    1. The processor issues a READ command, then goes off and does something else
    2. At the end of each instruction cycle, the processor checks for interrupts
    3. When the interrupt from the I/O module occurs, the processor saves the context, e.g. PC and processor registers, of the current program, and process the interrupt
    4. The processor reads the word of data from the I/O module and stores in memory
    5. The processor then restores the context of the program it was working on, or some other program, and resumes execution

### Interrupt processing
**Interrupts**. The occurrence of an interrupt triggers a number of events, both in the processor hardware and in software

<div style="text-align:center">
    <img src="https://i.imgur.com/Guvf0Lr.png">
    <figcaption>Simple interrupt handling</figcaption>
</div>

**Interrupt handling procedure**. When an I/O device completes an I/O operation, the following sequence of hardware event occurs
1. The device issues an interrupt signal to the processor
2. The processor finishes execution of the current instruction before responding to the interrupt
3. The processor tests for an interrupt, determines that there is one, and sends an acknowledgement signal to the device which issued the interrupt
    * *The acknowledgement signal*. Allow the device to remove its interrupt signal
4. The processor needs to prepare to transfer control to the interrupt routine, i.e.
    * *Explain*. The processor saves information required to resume the current program at the point of interrupt
        * *The minimum information required*. 
            * The status of the processor, which is contained in a register called *the program status word* (PSW)
            * The location of the next instruction to be executed, which is contained in the PC
        * *Saved information location*. The information above can be pushed onto the system control stack
5. The processor now loads the program counter with the entry location of the interrupt-handling program, which will respond to the current interrupt
    * *Types of interrupt-handling programs*. Depending on the comnputer architecture and OS design
        * *Option 1*. There is a single program
        * *Option 2*. There is one program for each type of interrupt
        * *Option 3*. One program for each device, and each type of interrupt
    * *Interrupt-handling choosing*. If there is more than one interrupt-handling routine, the processor must determine which one to invoke
        * *Option 1*. Which interrupt to choose is included in the original interrupt signal
        * *Option 2*. The processor have to issue a request to the device issuing the interrupt to get a response containing the required information
    * *Consequence*. Once the program counter has been loaded, the processor proceeds to the next instruction cycle begining with an instruction fetch

        $\to$ Control is transferred to the interrupt-handler program, since the instruction fetch is determined by the contents of the program counters
6. The contents of the processor registers, and any other state information, need to be saved before the interrupt-handling routine

    <div style="text-align:center">
        <img src="https://i.imgur.com/79o1cpU.png">
        <figcaption>Changes in memory and registers for an interrupt</figcaption>
    </div>

    * *Explain*. The interrupt handler begins by saving the contents of all registers on the stack

        $\to$ The stack pointer is updated to point to the new top of stack, and the PC is updated to point to the beginning of the interrupt service routine
7. The interrupt handler next processes the interrupt, e.g. 
    * Examination of status information related to the I/O operation or other event causing an interrupt
    * Sending additional commands or acknowledgements to the I/O device
8. When the interrupt processing is complete, the saved register values are retrieved from the stack, and restored to the registers
9. The PSW and PC values are restored from the stack

    $\to$ The next instruction to be executed will be from the previously interrupted program

**State saving and restoration**. It is important to save all the state information about the interrupted program for later resumption
* *Explain*. The interrupt is not a routine called from the program, but it can occur at any time, and therefore at any point in the execution of a user program

    $\to$ Its occurrence is unpredictable

### Design issues
**Main design issues arising in implementing interrupt I/O**.
* *Device identification*. Since there will almost invariably be multiple I/O modules, how does the processor determine which device issued the interrupt?
* **. If multiple interrupts have occurred, how does the processor decide which one to process?

**Device identification**. There are several types of techniques commonly used
* *Multiple interrupt lines*. Provide multiple interrupt lines between the processor and the I/O modules
    * *Drawback*. It is impractical to dedicate more than a few bus lines or processor pins to interrupt lines

        $\to$ If multiple lines are used, it is likely that each line will have multiple I/O modules attached to it
        * *Consequence*. One of the other techniques must be used on each line
* *Software poll*. When the processor detects an interrupt, it branches to an interrupt-service routine, whose job it is to poll each I/O module to determine which module caused the interrupt
    * *Poll format*.
        * *Option 1*. The poll could be in the form of a separate command line, e.g. `TESTI/O`, i.e.
            1. The processor raises `TESTI/O` and places the address of a particular I/O module on the address lines
            2. The I/O module responds positively if it sets the interrupt
        * *Option 2*. Each I/O module could contain an addressable status register

            $\to$ The processor then reads the status register of each I/O module to identify the interrupting module
    * *Drawback*. Software poll is time consuming
* *Daisy chain (hardware poll, vectored)*. For interrupts, all I/O modules share a common interrupt request line
    * *Daisy chain (in electrical engineering)*. A wiring scheme, in which multipl devices are wired together in a sequence or in a ring

        $\to$ The interrupt acknowledge line is daisy chained through the modules
    * *Mechanism*. 
        1. When the processor senses an interrupt, it sends out an interrupt acknowledge
        2. The signal propagates through a series of I/O modules until it gets to a requesting module
        3. The requesting module typically responds by placing a word on the data lines, i.e. a vector, which is either the address of the I/O module, or some other unique identifier

            $\to$ The procesor uses the vector as a pointer to the appropriate device-service routine
* *Bus arbitration*. With bus arbitration, an I/O module must first gain control of the bus before it can raise the interrupt request line

    $\to$ Only one module can raise the line at a time
    * *Consequence*. When the processor detects the interrupt, it responds on the interrupt acknowledge line

        $\to$ The requesting module then places its vector on the data lines

**Interrupt priorities**. The aforementioend techniques also provide a way of assigning priorities when more than once device is requesting interrupt service
* *Multiple lines*. The processor just picks the interrupt line with the highest priority
* *Software polling*. The order in which modules are polled determines their priorities
* *Daisy chain*. The order of modules determines their priorities
* *Bus arbitration*. Employ a priority scheme

### Intel 82C59A interrupt controller