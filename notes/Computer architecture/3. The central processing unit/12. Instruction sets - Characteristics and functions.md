<!-- TOC titleSize:1 tabSpaces:2 depthFrom:1 depthTo:6 withLinks:1 updateOnSave:1 orderedList:0 skip:0 title:1 charForUnorderedList:* -->
# Table of Contents
- [Table of Contents](#table-of-contents)
- [Instruction sets - Characteristics and functions](#instruction-sets---characteristics-and-functions)
  - [Machine instruction characteristics](#machine-instruction-characteristics)
    - [Elements of a machine instruction](#elements-of-a-machine-instruction)
    - [Instruction representation](#instruction-representation)
    - [Instruction types](#instruction-types)
    - [Number of addresses](#number-of-addresses)
    - [Instruction set design](#instruction-set-design)
  - [Types of operands](#types-of-operands)
    - [Numbers](#numbers)
    - [Characters](#characters)
    - [Logical data](#logical-data)
  - [Intel x86 and ARM data types](#intel-x86-and-arm-data-types)
    - [x86 data types](#x86-data-types)
    - [ARM data types](#arm-data-types)
  - [Types of operations](#types-of-operations)
    - [Data transfer](#data-transfer)
    - [Arithmetic](#arithmetic)
    - [Logical](#logical)
    - [Conversion](#conversion)
    - [Input/Output](#inputoutput)
    - [System control](#system-control)
    - [Transfer of control](#transfer-of-control)
      - [Branch instructions](#branch-instructions)
      - [Skip instructions](#skip-instructions)
      - [Procedure call instructions](#procedure-call-instructions)
<!-- /TOC -->

# Instruction sets - Characteristics and functions
**Machine instruction set**. One boundary where the computer designer and the computer programmer can view the same machine
* *Machine instruction set from the designer’s perspective*. The machine instruction set provides the functional requirements for the processor
    * *Explain*. Implementing the processor is a task that in large part involves implementing the machine instruction set

## Machine instruction characteristics
**Machine instructions (or computer instructions)**. Determine the operation of the processor
* *Instruction set*. The collection of different instructions that the processor can execute

### Elements of a machine instruction
**Elements of a machine instruction**. Each instruction must contain the information required by the processor for execution

<div style="text-align:center">
    <img src="https://i.imgur.com/VLwkCyX.png">
    <figcaption>Instruction cycle state diagram</figcaption>
</div>

* *Operation code*. Specify the operation to be performed, e.g. ADD, I/O, etc.
    * *Explain*. The operation is specified by a binary code, i.e. the operation code, or opcode
* *Source operand reference*. The operation may involve one or more source operands, i.e. input operands for the operation
* *Result operand reference*. The operation may produce a result
* *Next instruction reference*. Tell the processor where to fetch the next instruction after the execution of this instruction is complete
    * *Next instruction address format*. Can be either a real address or a virtual address, depending on the architecture
        
        $\to$ Generally, the distinction is transparent to the instruction set architecture
    * *Implicit next instruction reference*. In most cases, the next instruction to be fetched immediately follows the current instruction
        
        $\to$ In those cases, there is no explicit reference to the next instruction
        
        >**NOTE**. When an explicit reference is needed, the main memory or virtual memory address must be supplied. 

**Memory location of source and result operands**. Source and result operands can be in one of four areas
* *Main or virtual memory*. As with next instruction references, the main or virtual memory address must be supplied
* *Processor register*. With rare exceptions, a processor contains one or more registers, which may be referenced by machine instructions
    * If only one register exists, reference to it may be implicit
    * If more than one register exists, then each register is assigned a unique name or number
        
        $\to$ The instruction must contain the number of the desired register
* *Immediate*. The value of the operand is contained in a field in the instruction being executed
* *I/O device*. The instruction must specify the I/O module and device for the operation
    
    >**NOTE**. If memory-mapped I/O is used, this is just another main or virtual memory address

### Instruction representation
**Instruction representation**. Within the computer, each instruction is represented by a sequence of bits
* *Instruction fields*. The instruction is divided into fields, corresponding to the constituent elements of the instruction
    * *Example*.

        ```asm
        opcode (4 bits) + operand reference (6 bits) + operand reference (6 bits)
        ```

* *Multiple-format instruction sets*. With most instruction sets, more than one format is used
* *Instruction parsing*. During instruction execution, an instruction is read into an instruction register (IR) in the processor
    
    $\to$ The processor must be able to extract the data from the various instruction fields to perform the required operation
* *Symbolic instruction representation*. It is difficult for both the programmers to deal with binary representations of machine instructions

    $\to$ It is common to use a symbolic representation of machine instructions

**Opcode representation**. Opcodes are represented by abbreviations, called mnemonics, that indicate the operation
* *Examples*.

    ```asm
    ADD Add
    SUB Subtract
    MUL Multiply
    DIV Divide
    LOAD Load data from memory
    STOR Store data to memory
    ```

* *Operand representation*. Operands are represented symbolically, e.g.

    ```asm
    ADD R, Y // add the value contained in data location Y to the contents of register R
    ```
    
    >**NOTE**. The operation is performed on the contents of a location, not on its address

* *Symbolic-to-binary opcode*. Each symbolic opcode has a fixed binary representation, and the programmer specifies the location of each symbolic operand
    * *Work flow*. A simple program would accept the symbolic input, convert opcodes and operand references to binary form, and construct binary machine instructions

### Instruction types
**Example of high-level code to machine instructions**. 
* *High-level code*. `X = X + Y`
    * *Interpretation*. This statement instructs the computer to add the value stored in `Y` to the value stored in `X` and put the result in `X`
* *Machine language instructions*. Consider variables `X` and `Y` corresponding to locations `513` and `514`
    
    $\to$ If we assume a simple set of machine instructions, this operation could be accomplished with three instructions
    1. Load a register with the contents of memory location `513`
    2. Add the contents of memory location `514` to the register
    3. Store the contents of the register in memory location `513`
* *Conclusion*. This is typical of the relationship between a high-level language and a machine language, i.e.
    * *High-level language*. Expresse operations in a concise algebraic form, using variables
    * *Machine language*. Expresses operations in a basic form involving the movement of data to or from registers

**Types of instructions**. A computer should have a set of instructions allowing the user to formulate any data processing task
* *Instruction types from higher-programming languages' perspective*. Any program written in a high-level language must be translated into machine language to be executed
    
    $\to$ The set of machine instructions must be sufficient to express any of the instructions from a high-level language
* *Instruction types*. 
    * *Data processing*. Arithmetic and logic instructions
        * *Arithmetic instructions*. Provide computational capabilities for processing numeric data
        * *Logic (or Boolean) instructions*. Operate on the bits of a word as bits rather than as numbers
            
            $\to$ They provide capabilities for processing any other type of data the user may wish to employ
    * *Data storage*. Movement of data into or out of register and or memory locations
        * *Explain*. Data processing operations are performed primarily on data in processor registers

            $\to$ There must be memory instructions for moving data between memory and the registers
    * *Data movement*. I/O instructions

        $\to$ These are needed to transfer programs and data into memory and the results of computations back out to the user
    * *Control*. Test and branch instructions
        * *Test instructions*. Used to test the value of a data word or the status of a computation
        * *Branch instructions*. Used to branch to a different set of instructions depending on the decision made

### Number of addresses
**Brief**. One of the traditional ways of describing processor architecture is in terms of the number of addresses contained in each instruction

>**NOTE**. This dimension has become less significant with the increasing complexity of processor design

>**NOTE**. It is useful at this point to draw and analyze this distinction

**Maximum number of addresses required in an instruction**. Evidently, arithmetic and logic instructions will require the most operands
* *Operands of arithmetic and logic instructions*. 
    * *Source operands*. Virtually all arithmetic and logic operations are either unary, i.e. one source operand, or binary, i.e. two source operands
        
        $\to$ We need a maximum of two addresses to reference source operands
    * *Target operands*. The result of an operation must be stored, suggesting a third address, which defines a destination operand
    * *Next instruction reference*. After completion of an instruction, the next instruction must be fetched, and its address is needed
* *Conclusion*. An instruction could plausibly be required to contain four address references

**Common number of operands in most architectures**. Most instructions have one, two, or three operand addresses, with the address of the next instruction being implicit, i.e. obtained from the program counter
* *Special instructions*. Most architectures also have a few special-purpose instructions with more operands
    * *Example*. The load and store multiple instructions of the ARM architecture designate up to 17 register operands in a single instruction
* *Common practices*.

    <div style="text-align:center">
        <img src="https://i.imgur.com/RwDEAhi.png">
        <figcaption>Utilization of instruction addresses for non-branching instructions</figcaption>
    </div>

    * Three-address instruction formats are not common
        * *Explain*. They require a relatively long instruction format to hold the three address references
    * With two-address instructions, and for binary operations, one address must do double duty as both an operand and a result
        * *Pros*. Reduce the space requirement
        * *Cons*. To avoid altering the value of an operand, a `MOVE` instruction is used to move one of the values to a result or temporary location before performing the operation
            
            $\to$ The program expands to more instructions
    * For one-address instruction to work, a second address must be implicit
        
        $\to$ This was common in earlier machines, with the implied address being a processor register known as the accumulator (AC)
        * *Accumulator*. Contains one of the operands and is used to store the result
    * Zero-address instructions are applicable to a special memory organization called a stack
        * *Stack*. A last-in-first-out set of locations, starting at a known location and, often, at least the top two elements are in processor registers

            $\to$ Zero-address instructions would reference the top two stack elements

**Number of addresses as a design decision**. The number of addresses per instruction is a basic design decision
* *Fewer addresses per instruction*.
    * *Pros*.
        * Instructions are more primitive, requiring a less complex processor
        * Instructions are of shorter length
    * *Cons*.
        * Programs contain more total instructions, which in general results in longer execution times and longer, more complex programs
        * There is an important threshold between one-address and multiple-address instructions, i.e.
            * With one-address instructions, the programmer generally has available only one general-purpose register, i.e. the accumulator
            * With multiple-address instructions, it is common to have multiple general-purpose registers
                
                $\to$ This allows some operations to be performed solely on registers
                * *Consequence*. Since register references are faster than memory references, this speeds up execution
* *Conclusion*. For reasons of flexibility and ability to use multiple registers
    
    $\to$ Most contemporary machines employ a mixture of two- and three-address instructions

### Instruction set design
**Brief**. The design of an instruction set is very complex since it affects so many aspects of the computer system 
* *Explain*. 
    * The instruction set defines many of the functions performed by the processor
        
        $\to$ This has a significant effect on the implementation of the processor
    * The instruction set is the programmer’s means of controlling the processor
        
        $\to$ Programmer requirements must be considered in designing the instruction set

**Instruction set design trend**. Some of the most fundamental issues relating to the design of instruction sets remain in dispute

>**NOTE**. In recent years, the level of disagreement concerning these fundamentals has actually grown

* *Most important of fundamental design issues*. Include the following
    * *Operation repertoire*. How many and which operations to provide, and how complex operations should be
    * *Data types*. The various types of data upon which operations are performed
    * *Instruction format*. Instruction length (in bits), number of addresses, size of various fields, and so on
    * *Registers*. Number of processor registers that can be referenced by instructions, and their use
    * *Addressing*. The mode or modes by which the address of an operand is specified

>**NOTE**. These issues are highly interrelated and must be considered together in designing an instruction set

## Types of operands
**Most important general categories of data**. Addresses, numbers, characters, and logical data
* *Addresses*. A form of data, i.e. in many cases, some calculation must be performed on the operand reference in an instruction to determine the main or virtual memory address
    
    $\to$ In this context, addresses can be considered to be unsigned integers

>**NOTE**. Some machines define specialized data types or data structures
>
>* *Example*. There may be machine operations that operate directly on a list or a string of characters

### Numbers
**Brief**. All machine languages include numeric data types
* *Explain*. Even in nonnumeric data processing, there is a need for numbers to act as counters, field widths, etc.

**Limited representation of numbers in computers**. Numbers in computers are limited
* *Explain*.
    * There is a limit to the magnitude of numbers representable on a machine
    * In case of floating-point numbers, a limit to their precision

        $\to$ The programmer is faced with understanding the consequences of rounding, overflow, and underflow

**Types of numerical data common in computers**.
* Binary integer or binary fixed point
* Binary floating point
* Decimal

**Decimal-to-binary conversion**.
* *Motivation*. Although all internal computer operations are binary in nature
    
    $\to$ The human users of the system deal with decimal numbers
    * *Consequence*. There is a necessity to convert from decimal to binary on input and from binary to decimal on output
* *Decimal numbers in I/O bound programs*. For applications in which there is a great deal of I/O and comparatively little, comparatively simple computation
    
    $\to$ It is preferable to store and operate on the numbers in decimal form
    * *Most common representation for decimal numbers in I/O bound programs* Packed decimal

**Packed decimal representation**. Each decimal digit is represented by a 4-bit code
* *Binary-to-decimal decoding*. To form numbers, 4-bit codes are strung together, usually in multiples of 8 bits
* *Negative number representation*. Include a 4-bit sign digit at either the left or right end of a string of packed decimal digits
    * *Standard sign values*. `1100` for positive (+) and `1101` for negative (-)
* *Pros and cons*.
    * *Pros*. Avoid the conversion overhead
    * *Cons*. This code is less compact than a straight binary representation
        
        $\to$ This is an inefficient code, since only 10 of 16 possible 4-bit values are used

### Characters
**Characters**. A common form of data is text or character strings
* *Problem*. While textual data are most convenient for human beings
    
    $\to$ They cannot, in character form, be easily stored or transmitted by data processing and communications systems
    * *Explain*. Communication systems are designed for binary data
* *Solution*. A number of codes have been devised by which characters are represented by a sequence of bits
    * *Morse code*. Perhaps the earliest common example
    * *American Standard Code for Information Interchange (ASCII)*. The most commonly used character code in the International Reference Alphabet (IRA) today

**ASCII code**. Each character in this code is represented by a unique 7-bit pattern

$\to$ 128 different characters can be represented
* *Control characters*. Some of the patterns represent control characters
    * Some have to do with controlling the printing of characters on a page
    * Others are concerned with communications procedures
* *Character storage*. IRA-encoded characters are almost always stored and transmitted using 8 bits per character
    
    $\to$ The eighth bit may be set to 0 or used as a parity bit for error detection
    * *Error detection code*. This bit is set such that the total number of binary 1s in each octet is always odd, i.e. odd parity, or always even, i.e. even parity

**Extended Binary Coded Decimal Interchange Code (EBCDIC)**. Another code used to encode characters, which is used on IBM mainframes
* *Idea*. Use an 8-bit code
    
    $\to$ As with IRA, EBCDIC is compatible with packed decimal

### Logical data
**Data unit**. Normally, each word or other addressable unit, e.g. byte, halfword, etc., is treated as a single unit of data
* *Logical data*. To consider an $n$-bit unit as consisting of $n$ 1-bit items of data, each item having the value 0 or 1
    
    $\to$ When data are viewed this way, they are considered to be logical data
* *Benefits of the bit-oriented view*.
    * we may sometimes wish to store an array of Boolean or binary data items, in which each item can take on only the values 1 (true) and 0 (false)
        
        $\to$ With logical data, memory can be used most efficiently for this storage
    * There are occasions when we wish to manipulate the bits of a data item
        * *Examples*. 
            * If floating-point operations are implemented in software
                
                $\to$ We need to be able to shift significant bits in some operations
            * To convert from IRA to packed decimal, we need to extract the rightmost 4 bits of each byte

## Intel x86 and ARM data types
### x86 data types
**General data types**. The x86 can deal with data types of 8 (byte), 16 (word), 32 (doubleword), 64 (quadword), and 128 (double quadword) bits in length
* *Elimination of word alignment for flexibility*. To allow maximum flexibility in data structures and efficient memory utilization
    
    $\to$ Words need not be aligned at evennumbered addresses
    * *Example*. Doublewords need not be aligned at addresses evenly divisible by 4
* *Data accesse via 32-bit bus*. When data are accessed across a 32-bit bus, data transfers take place in units of doublewords, beginning at addresses divisible by 4
    
    $\to$ The processor converts the request for misaligned values into a sequence of requests for the bus transfer
* *Little-endian style*. As with all of the Intel 80x86 machines, the x86 uses the little-endian style
    * *Little-endian style*. The least significant byte is stored in the lowest address

**Specific data types**. The x86 supports an impressive array of specific data types recognized and operated on by particular instructions

<div style="text-align:center">
    <img src="https://i.imgur.com/TWZYYaZ.png">
    <figcaption>x86 data types</figcaption>
</div>

* *Signed integers*. Represented in twos complement representation and may be 16, 32, or 64 bits long
* *Floatingpoint type*. Actually refers to a set of types, which are used by the floating-point unit
and operated on by floating-point instructions
    * *Representation*. The three floating-point representations conform to the IEEE 754 standard
* *Packed SIMD (single-instruction-multiple-data) data types*. Introduced to the x86 architecture as part of the extensions of the instruction set to optimize performance of multimedia applications
    * *Extension details*. Include MMX (multimedia extensions) and SSE (streaming SIMD extensions)
    * *Basic concept*. 
        * Multiple operands are packed into a single referenced memory item
        * These multiple operands are operated on in parallel
    * *Data types*.
        * *Packed byte and packed byte integer*. Bytes packed into a 64-bit quadword or 128-bit double quadword, interpreted as a bit field or as an integer
        * *Packed word and packed word integer*. 16-bit words packed into a 64-bit quadword or 128-bit double quadword, interpreted as a bit field or as an integer
        * *Packed doubleword and packed doubleword integer*. 32-bit doublewords packed into a 64-bit quadword or 128-bit double quadword, interpreted as a bit field or as an integer
        * *Packed quadword and packed qaudword integer*. Two 64-bit quadwords packed into a 128-bit double quadword, interpreted as a bit field or as an integer
        * *Packed single-precision floating-point and packed double-precision floatingpoint*. Four 32-bit floating-point or two 64-bit floating-point values packed into a 128-bit double quadword

### ARM data types
**General data types**. ARM processors support data types of 8 (byte), 16 (halfword), and 32 (word) bits in length
* *Memory aligment*. Normally, halfword access should be halfword aligned and word accesses should be word aligned
* *Nonaligned data access*. The architecture supports three alternatives
    * *Default case*.
        * The address is treated as truncated, i.e.
            * Address bits[1:0] treated as zero for word accesses
            * Address bit[0] treated as zero for halfword accesses
        * Load single word ARM instructions are architecturally defined to rotate right the word-aligned data transferred by a non word-aligned address one, two, or three bytes depending on the value of the two least significant address bits
    * *Alignment checking*. When the appropriate control bit is set, a data abort signal indicates an alignment fault for attempting unaligned access
    * *Unaligned access*. When this option is enabled, the processor uses one or more memory accesses to generate the required transfer of adjacent bytes transparently to the programmer
* *Data representation*. 
    * *Unsigned integer representation*. For all three data types, an unsigned interpretation is supported, in which the value represents an unsigned, nonnegative integer
    * *Signed integer representation*. All three data types can be used for twos complement signed integers
    * *Floating point representation*. The majority of ARM processor implementations do not provide floatingpoint hardware, which saves power and area
        
        $\to$ If floating-point arithmetic is required in such processors, it must be implemented in software
        * *Single- and double-precision floating point*. ARM does support an optional floating-point coprocessor that supports the single- and double-precision floating point data types defined in IEEE 754

**Endian support**. A state bit, i.e. E-bit, in the system control register is set and cleared under program control using the `SETEND` instruction

$\to$ This bit defines which endian to load and store data

<div style="text-align:center">
    <img src="https://i.imgur.com/xXHXY9J.png">
    <figcaption>ARM endian support - Word load/store with E-bit</figcaption>
</div>

* *Consequence*. This enables efficient dynamic data load/store for system designers, who know they need to access data structures in the opposite endianness to their OS/environment
* *Data byte address*. Fixed in memory, however the byte lane in a register is different

## Types of operations
**General operation types**. The same general types of operations are found on all machines
* *A useful and typical categorization of operations*. Data transfer, arithmetic, logical, conversion, I/O, system control, and transfer of control

### Data transfer
**Data transfer**. The most fundamental type of machine instruction
* *Required parameters* The data transfer instruction must specify
    * The location of the source and destination operands must be specified
        
        $\to$ Each location could be memory, a register, or the top of the stack
    * The length of data to be transferred
    * The mode of addressing for each operand must be specified
* *Choice of data transfer instructions to include in an instruction set*. Exemplifies the kinds of trade-offs the designer must make
    * *Example*. The general location, i.e. memory or register, of an operand can be indicated in either the specification of the opcode or the operand
    * *Key notes*.
        * Most data transfer instructions are of the form `LOAD` and `STORE`
        * There are different instructions for register to register, register to memory, memory to register, and memory to memory transfers
    * *VAX architecture's `MOV` instruction*. VAX has a move (MOV) instruction with variants for different amounts of data to be moved
        
        $\to$ It specifies whether an operand is register or memory as part of the operand
        * *Benefits*. Easier for the programmer, who has fewer mnemonics to deal with
        * *Drawback*. Less compact than the IBM EAS/390 approach, since the location, i.e. register versus memory, of each operand must be specified separately in the instruction

**Data transfer operations in terms of processor action**. Perhaps the simplest type, i.e.
* If both source and destination are registers
    
    $\to$ The processor simply causes data to be transferred from one register to another
    * *Consequence*. This is an operation internal to the processor
* If one or both operands are in memory
    
    $\to$ The processor must perform some or all of the following actions
    1. Calculate the memory address, based on the address mode
    2. If the address refers to virtual memory, translate from virtual to real memory address
    3. Determine whether the addressed item is in cache
    4. If not, issue a command to the memory module

### Arithmetic
**Arithmetic operations**. 
* *Basic operations*. Most machines provide the basic arithmetic operations of add, subtract, multiply, and divide
    * *Supports for different data types*
        * These operations are invariably provided for signed integer, i.e. fixed-point, numbers
        * Often they are also provided for floating-point and packed decimal numbers
* *Other single-operand operations*. Other possible operations include a variety of single-operand instructions
    * *Example*.
        * *Absolute*. Take the absolute value of the operand
        * *Negate*. Negate the operand
        * *Increment*. Add 1 to the operand
        * *Decrement*. Subtract 1 from the operand

**Execution of arithmetic operations**. 
* *Workflow*. The execution of an arithmetic instruction may involve 
    * Data transfer operations to position operands for input to the ALU
    * Deliver the output of the ALU

### Logical
**Basic logical operations**. Most machines also provide a variety of operations for manipulating individual bits of a word or other addressable units
* *Bit twiddling*. Manipulating bits of a word or other addressable unit
    
    $\to$ They are based upon Boolean operations
* *Basic logical operations*. `NOT`, `AND`, `OR`, `XOR`, `EQUAL`
    * *Bitwise execution*. These logical operations can be applied bitwise to $n$-bit logical data units
    * *Example*. Consider `(R1) = 10100101` and `(R2) = 00001111` then `(R1) AND (R2) = 00000101`


**Logical shift operations**. Most machines provide a variety of shifting and rotating functions

<div style="text-align:center">
    <img src="https://i.imgur.com/tmi6HXz.png">
    <figcaption>Shift and rotate operations</figcaption>
</div>

* *Logical shift*. The bits of a word are shifted left or right
    
    $\to$ The bit shifted out is lost on one end, and a `0` is shifted in on the other end
    * *Usage*. 
        * Useful primarily for isolating fields within a word
        * The `0`s that are shifted into a word displace unwanted information that is shifted off the other end
    * *Example*. Consider transmitting characters of data to an I/O device one character at a time
        1. If each memory word is 16 bits in length and contains two characters
            
            $\to$ We must unpack the characters before they can be sent
        2. To send the two characters in a word,
            1. Load the word into a register
            2. Shift to the right eight times

                $\to$ This shifts the remaining character to the right half of the register
            3. Perform I/O, i.e. The I/O module reads the lower-order 8 bits from the data bus
                
                $\to$ This result in sending the left-hand character
* *Arithmetic shift operation*. 
    * *Left arithmetic shift*. Treat the data as a signed integer and does not shift the sign bit
    * *Right arithmetic shift*. The sign bit is replicated into the bit position to its right
    
    >**NOTE**. These operations can speed up certain arithmetic operations
    
    * *Interpretation*. 
        * If no overflow occurs
            
            $\to$ Both an arithmetic left shift and a logical left shift correspond to a multiplication by 2
        * If overflow occurs
            
            $\to$ Arithmetic and logical left shift operations produce different results
    * *Prevention of overflow*. Due to the potential for overflow
        * Many processors do not include this instruction, including PowerPC and Itanium
        * Others, such as the IBM EAS/390, do offer the instruction
    * *Arithmetic left shift in x86*. The x86 architecture includes an arithmetic left shift but defines it to be identical to a logical left shift

**Rotate (or cyclic shift) operations**. Preserve all of the bits being operated on
* *Usage*. One use of a rotate is to bring each bit successively into the leftmost bit, where it can be identified by testing the sign of the data

**Execution of logical operations**. Logical operations involve ALU activity and may involve data transfer operations

### Conversion
**Conversion instructions**. Operations changing the format, or operate on the format of data
* *Example*. Converting from decimal to binary

### Input/Output
**Input/output instructions**. There are a variety of approaches taken, including 
* Isolated programmed I/O
* Memory-mapped programmed I/O
* DMA
* I/O processor

**Supported I/O operations**. Many implementations provide only a few I/O instructions, with the specific actions specified by parameters, codes, or command words

### System control
**System control instructions**. 
* *System control instructions*. Instructions that can be executed only while
    * The processor is in a certain privileged state, or
    * The processor is executing a program in a special privileged area of memory
* *Usage*. Reserved for the use of the OS
* *Examples*.
    * A system control instruction may read or alter a control register
    * A system control instruction may read or modify a storage protection key, e.g.as in the EAS/390 memory system
    * A system control instruction may access to process control blocks in a multiprogramming system

### Transfer of control
**Transfer of control**.
* *Motivation*.
    * For most operation types, the next instruction to be performed is the one that immediately follows, in memory, the current instruction
    * A significant fraction of the instructions in any program have as their function changing the sequence of instruction execution
        
        $\to$ The operation performed by the processor is to update the program counter to contain the address of some instruction in memory
* *Needs for transfer-of-control operations*.
    * When using computers, it is essential to be able to repeatedly execute some instructions
        
        $\to$ This would be unthinkable if each instruction had to be written out separately
    * Virtually all programs involve some decision making
        * *Idea*. The computer may do one thing if one condition holds, and another thing if another condition holds
    * To compose correctly a large or even medium-size computer program is an exceedingly difficult task
        
        $\to$ It helps if there are mechanisms for breaking the task up into smaller pieces that can be worked on one at a time
* *Most common transfer-of-control operations*. Branch, skip, and procedure call

#### Branch instructions
**Branch instruction (or jump instruction)**.
* *Operands*. One of the operands is the address of the next instruction to be executed
* *Conditional branch instruction*. The branch is made, i.e. update program counter to equal address specified in operand, only if a certain condition is met

    $\to$ Otherwise, the next instruction in sequence is executed, i.e. increment program counter as usual
* *Unconditional branch instruction*. The branch is always taken

**Common ways of generating the condition to be tested in a conditional branch instruction**. 
* *Option 1*. Most machines provide a 1-bit or multiple-bit condition code, which is set as the result of some operations
    
    $\to$ This code is a short user-visible register
    * *Example*. An arithmetic operation, e.g. `ADD` or `SUBTRACT`, could set a 2-bit condition code to be 0, positive, negative, or overflow
        
        $\to$ On such a machine, there could be four different conditional branch instructions
            * *`BRP X`*. Branch to location `X` if result is positive
            * *`BRN X`*. Branch to location `X` if result is negative
            * *`BRZ X`*. Branch to location `X` if result is zero
            * *`BRO X`*. Branch to location `X` if overflow occurs
* *Option 2*. Use a three-address instruction format to perform a comparison and specify a branch in the same instruction
    * *Example*. `BRE R1, R2, X` branches to `X` if `R1`'s contents equals to `R2`'s contents

>**NOTE**. A branch can be either forward (an instruction with a higher address) or backward (lower address)

#### Skip instructions
**Skip instruction**. Include an implied address
* *Interpretation*. Typically, the skip implies that one instruction be skipped
    
    $\to$ The implied address equals the address of the next instruction plus one instruction length
* *Benefits of having no destination address*. Since the skip instruction does not require a destination address field
    
    $\to$ It is free to do other things
    * *Example*. The increment-and-skip-if-zero (ISZ) instruction

#### Procedure call instructions
**Procedure**. A selfcontained computer program incorporated into a larger program
* *Procedure invocation*. At any point in the program, the procedure may be invoked, or called

    $\to$ The processor is instructed to go and execute the entire procedure and then return to the point from which the call took place

**Principal reasons for using procedures**. Economy and modularity
* *Economy reason*. A procedure allows the same piece of code to be used many times
    
    $\to$ This is important for economy in programming effort and for making the most efficient use of storage space in the system
    * *Explain*. The program must be stored
* *Modularity reason*. Procedures also allow large programming tasks to be subdivided into smaller units
    
    $\to$ This use of modularity greatly eases the programming task

**Basic instructions related to procedure mechanism**. Both instructions are forms of branching instructions
* *Call instruction*. Branch from the present location to the procedure
* *Return instruction*. Return from the procedure to the place from which it was called

**Using procedures to construct a program**.
* *Example*. Consider a main program starting at location `4000`

    <div style="text-align:center">
        <img src="https://i.imgur.com/Kj1C2qA.png">
        <figcaption>Nested procedures</figcaption>
    </div>

    * *Function call*. This program includes a call to procedure `PROC1`, starting at location 4500
        
        $\to$ When this call instruction is encountered
        1. The processor suspends execution of the main program 
        2. The processor begins execution of `PROC1` by fetching the next instruction from location 4500
    * *Nested function call*. Within `PROC1`, there are two calls to PROC2 at location 4800
        
        $\to$ In each case, the execution of `PROC1` is suspended and `PROC2` is executed
    * *Return from function*. The `RETURN` statement causes the processor to go back to the calling program 
        
        $\to$ The processor continues execution at the instruction after the corresponding `CALL` instruction

* *Key notes*.
    * A procedure can be called from more than one location
    * A procedure call can appear in a procedure
        
        $\to$ This allows the nesting of procedures to an arbitrary depth
    * Each procedure call is matched by a return in the called program

**Storing the return address**. Since we would like to be able to call a procedure from a variety of points

$\to$ The processor must somehow save the return address so that the return can take
place appropriately
* *Common places for storing the return address*. Consider a machine-language instruction `CALL X`, i.e. call procedure at location `X`
    * *Assumptions*.
        * `PC` is the program counter
        * `Delta` is the instruction length
    * *Register*. `CALL X` causes the following actions

        ```asm
        RN <-- PC + Delta
        PC <-- X
        ```
        
        where `RN` is a register used for storing return address
        
        $\to$ The called procedure can save the contents of `RN` to be used for the later return
    * *Start of called procedure*. `CALL X` causes the following actions

        ```asm
        X <-- PC + Delta
        PC <-- X + 1
        ```

        $\to$ The return address has been stored safely away
    * *Top of stack*.
        * *Drawbacks of preceding approaches*. Those approaches complicate the use of reentrant procedures
            * *Reentrant procedure*. A procedure, in which it is possible to have several calls open to it at the same time
                * *Example*. Recursive procedures
            * *Explain*. If parameters are passed via registers or memory for a reentrant procedure
                
                $\to$ Some code must be responsible for saving the parameters, for the registers or memory space to be available for other procedure calls
        * *Idea*. When the processor executes a call
            
            $\to$ It places the return address on the stack
            * *Consequence*. When it executes a return, it uses the address on the stack

**Storing parameters for procedure calls**.
* *Option 1*. Parameters can be passed in registers
* *Option 2*. Store the parameters in memory just after the `CALL` instruction
    
    $\to$ The return must be to the location following the parameters
* *Option 3*. Use stack
    * *Drawbacks of preceding approaches*
        * If registers are used, the called program and the calling program must be written to assure that the registers are used properly
        * The storing of parameters in memory makes it difficult to exchange a variable number of parameters
        * Both approaches prevent the use of reentrant procedures
    * *Idea*. When the processor executes a call
        
        $\to$ It not only stacks the return address, it stacks parameters to be passed to the called procedure
    * *Consequence*.
        * The called procedure can access the parameters from the stack
        * Upon return, return parameters can also be placed on the stack
    * *Stack frame*. The entire set of parameters, including return address, that is stored for a procedure invocation