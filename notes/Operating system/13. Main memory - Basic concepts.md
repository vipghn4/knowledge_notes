---
title: 13. Main memory - Basic concepts
tags: Operating system
---

<!-- TOC titleSize:1 tabSpaces:2 depthFrom:1 depthTo:6 withLinks:1 updateOnSave:1 orderedList:0 skip:0 title:1 charForUnorderedList:* -->
# Table of Contents
- [Table of Contents](#table-of-contents)
- [13. Main memory - Basic concepts](#13-main-memory---basic-concepts)
  - [Background](#background)
    - [Basic hardware](#basic-hardware)
    - [Address binding](#address-binding)
    - [Logical versus physical address space](#logical-versus-physical-address-space)
    - [Dynamic loading](#dynamic-loading)
    - [Dynamic linking and shared libraries](#dynamic-linking-and-shared-libraries)
- [Appendix](#appendix)
  - [Concepts](#concepts)
  - [Advanced](#advanced)
<!-- /TOC -->

# 13. Main memory - Basic concepts
## Background
**Memory structure**. A large array of words or bytes, each with its own address
* *Memory-CPU interaction*. CPU fetches instructions from memory according to the value of the PC

    $\to$ These instructions may cause additional loading from and storing to specific memory address
* *Memory address stream*. During execution, the memory unit sees only a stream of memory addresses without knowing how they are generated, or what they are for

    $\to$ We can ignore how a program generated a memory address, and focus on the sequence of memory addresses generated by the running program

### Basic hardware
**Direct-access memory**. Main memory and registers built into the processor itself are the only storage which the CPU can access directly
* *Memory instructions*. Take memory addresses as arguments

>**NOTE**. There is no memory instruction taking disk addresses as arguments

* *Consequence*. Any instructions in execution, and any data being used by the instructions, must be in one of the direct-access storage devices

**Memory operation speed**.
* *Built-in registers speed*.
    * *Access*. Generally accessiable within one cycle of CPU clock
    * *Operation*. Most CPUs can decode instructions and perform simple operations on register contents at the rate of one or more operations per clock tick
* *Main memory*. Accessed via a transaction on the memory bus

    $\to$ Completing a memory access may take many cycles of the CPU clock
    * *Stalling*. In case the memory access take too long, the processor normally needs to stall
        * *Explain*. It does not have the data required to complete the executing instruction

        >**NOTE**. This is bad because of the frequency of memory accessses

        * *Solution*. Add fast memory between the CPU and the main memory, e.g. cache

**Protection**. Correct operation must be ensured to protect the OS from access by user processes, and to protect user processes from one another

>**NOTE**. This protection must be provided by the hardware

<div style="text-align:center">
    <img src="/media/U5ysP8a.png">
    <figcaption>A base and a limit register define in a logical address space</figcaption>
</div>

* *Base and limit registers*. Each process must have a separate memory space

    $\to$ We need the ability to determine the range of legal addresses, which the process may access, and to ensure that the process can access only these legal addresses
    * *Solution*. Use two registers, i.e.
        * *Base register*. Hold the smallest legal physical memory address
        * *Limit register*. Specify the size of the range
* *Protection of process memory space*. The CPU hardware compares every address generated in user mode with the registers

    $\to$ Any attempt to access OS memory or other users' memory results in a trap to the OS, which treats the attempt as a fatal error
    * *Consequence*. Prevent a user program from modifying the code or data structures of the OS and other users
* *Loading base and limit registers*. Can be loaded only by the OS, which uses a special privileged instruction
    * *Explain*. Privileged instructions can be executed only in kernel mode, in which only the OS can executes

        $\to$ Only the OS can load the base and limit registers
    * *Consequence*.
        * The OS can change the value of the registers
        * User programs cannot change registers' contents

### Address binding
**Program in disk**.
* *Program representation*. A binary executable file
* *Program execution*. To be executed, the program must be brought into memory and placed within a process
    >**NOTE**. Depending on the memory management in use
    >$\to$ The process may be moved between disk and memory during its execution

    1. Select one of the processes in the input queue (see below)
    2. Load the selected process into memory
    3. As the process is executed, it accesses instructions and data from memory
    4. The process terminates, and its memory space is declared available

**Input queue**. Contain the processes on the disk, which are waiting to be brought into memory for execution

**User process memory space**. Most systems allow a user process to reside in any part of the physical memory

$\to$ Although the address space of the computer starts at 00000, the first address of the user process need not be 00000

<div style="text-align:center">
    <img src="/media/zceLNZq.png">
    <figcaption>Multistep processing of a user program</figcaption>
</div>

* *Consequence*. In most cases, a user program will go through several steps, some of which may be optional, before being executed

    >**NOTE**. Addresses may be represented in different ways during these steps

**Address binding**. Addresses in source program are generally symbolic, e.g. count
* *Address binding*. A mapping from one address space to another
* *Binding mechanism*.
    1. The compiler will typically bind these symbolic addresses to relocatable addresses, e.g. "14 bytes from the begining of this module"
    2. The linkage editor or loader will bind the relocatable addresses to absolute addresses, e.g. 74014
* *Binding of instructions and data to memory addresses*. Can be done at any step along the way
    * *Compile time*. If we know at compile time where the process will reside in memory

        $\to$ Absolute code can be generated
        * *Changing address starting location*. We must recompile the code
    * *Load time*. If it is not known at compile time where the process will reside in memory, the compiler must generated relocatable code

        $\to$ The final binding is delayed until load time
        * *Changing address starting location*. We only need to reload the user code to incorporate this change
    * *Execution time*. If the process can be moved during its execution from one memory segment to another

        $\to$ Binding must be delayed until run time

        >**NOTE**. Most general-purpose OSes use this method

### Logical versus physical address space
**Logical address and physical address**.
* *Logical address*. An address generated by the GPU
* *Physical address*. An address seen by the memory unit, i.e. the one loaded into the memory-address register of the memory

**Logical addresses and physical address binding during execution**.
* *Compile-time and load-time*. Generated logical addresses and physical addresses are identical
* *Execution-time*. Generated addresses and physical addresses are different

    $\to$ In this case, we refer to logical address as virtual address

>**NOTE**. The words "logical address" and "virtual address" can be used interchangeably

**Address spaces**.
* *Logical address space*. The set of all logical addresses generated by a program
* *Physical address space*. The set of all physical addresses corresonding to the generated logical addresses

**Memory-management unit (MMU)**. The run-time mapping from virtual to physical addresses is done by a hardware device called the MMU

<div style="text-align:center">
    <img src="/media/rY16cLR.png">
    <figcaption>Dynamic relocation using a relocation register</figcaption>
</div>

>**NOTE**. Currently, we will illustrate this mapping with a simple MMU scheme, which is a generalization of the base-register scheme
>$\to$ The base register is now called a relocation register
>* *Memory mapping scheme*. The value in the relocation register is added to every address generated by a user process at the time the address is sent to memory
>* *Consequences*.
>    * The user generated only logical addresses and thinks that the process runs in locations 0 to `max`
>    * The user program generates only logical addresses and thinks that the process runs in locations 0 to `max`

>**NOTE**. The user program never sees the real physical addresses
>$\to$ The user program deals with logical addresses


### Dynamic loading
**Problem**. The size of a process is limited to the size of physical memory
* *Explain*. It is necessary for the entire program and all data of a process to be in physical memory for the process to execute

**Dynamic loading**. A technique exploited to obtain better memory-space utilization
* *Idea*.
    * A rountine is not loaded until it is called
    * All routines are kept on disk in a relocatable load format
* *Program execution*.
    * The main program is loaded into memory and is executed
    * When a routine needs to call another routine
        * The calling routine checks to see whether the other routine has been loaded
        * If not
            * The relocatable linking loader is called to load the desired routine into memory
            * The relocatable linking loader is called to update the program's address tables to reflect this change
            * The control is passed to the newly roaded routine
* *Usage*. When large amounts of code are needed to handle infrequently occurring cases, e.g. error routines

>**NOTE**. Dynamic loading does not require special support from the OS

>**NOTE**. It is the responsibility of the users to design their programs to take advantage of such methods

### Dynamic linking and shared libraries
>**NOTE**. Some OSes support only static linking

**Static linking**. System language libraries are treated like any other object module

$\to$ Theses libraries are combined by the loader into the binary program image

**Dynamic linking**. Similar dynamic loading
* *Usage*. Usually used with system libraries
    * *Explain*. Without this facility, each program on a system must include a copy of its language library in the executable image
* *Implementation*. A stub is included in the image for each library routine reference
    * *Stub*. A small piece of code indicating how to locate the appropriate memory-resident library routine, or how to load the library from disk if the routine is not present
    * *Stub execution*.
        1. The stub checks to see whether the needed routine is already in memory

            $\to$ If not, the program loads the routine into memory
        2. The stub replaces itself with the address of the routine and executes the routine

            $\to$ The next time that particular code segment is reached, the library routine is executed directly, without cost of dynamic linking

        >**NOTE**. Under this scheme, all processes using a language library execute only one copy of the library code

>**NOTE**. A library may be replaced by a new version, and all programs with dynamic linking referencing the library will automatically use the new version
>$\to$ Without dynamic linking, all such programs would need to be relinked to gain access to the new library

>**NOTE**. For programs to not accidentally execute new, incompatible versions of libraries
>$\to$ Version information is included in both the program and the library

>**NOTE**. Dynamic linking generally requires help from the OS
>* *Explain*. If the processes in memory are protected from one another
>    $\to$ The OS is the only entity, which can check to see whether the required routine is in another process' memory space, or can allow multiple processes to access the same memory addresses

# Appendix
## Concepts
**Memory bus**. A type of computer bus, usually in the form of a set of wires or conductors
* *Usage*.
    * Connects electrical components
    * Allow transfers of data and addresses from main memory to CPU, or a memory controller

## Advanced
**Process address space**. As described before, the address space of a process is specified via base and limit registers, therefore
* *Process address space representation*. Liek memory, as an array

    >**NOTE**. It gets more complicated since memory can be shared between processes and the kernel, and various protection mechanisms
    >$\to$ Conceptually, we can think of an address space as a big array of bytes starting at index 0

<div style="text-align:center">
    <img src="/media/eTJAxRD.png">
    <figcaption>Memory layout of C programs (in logical address space)</figcaption>
</div>

* *Process memory layout*.
    * *Heap and stack*. Each process has its own stack and heap independent of other processes, without worry of conflicting addresses
    * *Memory mapping segment (MMS)*. Reside between heap and stack

        <div style="text-align:center">
            <img src="/media/VzeO2eL.png">
            <figcaption>How MMS is represented</figcaption>
        </div>

        * *Usage*. Store the mapping for shared memory, shared libraries, opened files, etc.
* *Multi-threaded process address space*.
    * The threads share the same address space
    * Each thread has its own stack
* *Context switching*.
    * *Between processes*. Involve changing the address space
    * *Between threads*. Involve changing the stack address space
        * *Explain*. Threads share a common heap
* *Related registers*.
    * Define the address space of a process, i.e. base and limit registers
    * Define the location of the stack
    * Define the location of current instruction
* *Program memory layout in physical memory*. Heap and stack can be anywhere in physical memory due to the appearance of MMUs

    >**NOTE**. Since modern OSes have implemented Address Space Layout Randomization (ASLR)
    >$\to$ Heap and stack can be anywhere in virtual memory too

    >**NOTE**. The continuity of heap and stack memories are not ensured in physical memory

* *Reference*.
    * See [here](https://softwareengineering.stackexchange.com/questions/325704/how-is-stack-and-heap-are-assigned-to-each-processes#:~:text=A%20process%20usually%20reflects%20an%20address%20space.&text=Each%20process%20is%20given%20its,can%20also%20run%20multiple%20threads)
    * See [here](https://stackoverflow.com/questions/30008025/where-is-heap-and-stack-on-physical-memory)

**Address space layout randomization (ASLR)**. A computer security technique aimed at preventing an attacker, who previously knows that a program function is vulnerable and can be exploited, to get access to it
* *Key idea*. Prevent the hacker from knowing the memory address, where the function is allocated within the running process
* *Method*. Randomly distribute the fundamental parts of a process, i.e. executable bsae, stack pointers, libraries, etc., into the memory address space, which has been assigned to it by the OS
* *Implementation*. $x' = F(x, r)$ where $x$ is the original address, $r$ is some random number generated intime

    >**NOTE**. $F$ may differ for different parts of a proces
