---
title: 11. CPU scheduling
tags: Operating system
---

<!-- TOC titleSize:1 tabSpaces:2 depthFrom:1 depthTo:6 withLinks:1 updateOnSave:1 orderedList:0 skip:0 title:1 charForUnorderedList:* -->
# Table of Contents
- [Table of Contents](#table-of-contents)
- [11. CPU scheduling](#11-cpu-scheduling)
  - [Basic concepts](#basic-concepts)
    - [CPU-I/O burst cycle](#cpu-io-burst-cycle)
    - [CPU scheduler](#cpu-scheduler)
    - [Preemptive scheduling](#preemptive-scheduling)
    - [Dispatcher](#dispatcher)
<!-- /TOC -->

# 11. CPU scheduling
## Basic concepts
**Single-processor system**. Only one process can run at a time, any others must wait until the CPU is free and can be scheduled
* *Multiprogramming*. The objective is to have some process running at all times, to maximize CPU utilization
    * *Problem to solve*. A process is executed until it must wait, typically for the completion of some I/O request

        $\to$ The CPU then just sits idle, thus all the waiting time is wasted and no useful work is accomplished
    * *Idea*. Try to use the time productively by keeping several processes in memory at one time

        $\to$ When one process has to wait, the OS takes the CPU away from that process and gives the CPU to another process

**Scheduling**. Scheduling processes in a multiprogramming system is a fundamental OS function

### CPU-I/O burst cycle
**Key property of processes**. Process execution consists of a cycle of CPU execution and I/O wait

$\to$ Processes alternate between these two states
* *Terminology*. Process execution begins with a CPU burst and is followed by an I/O burst, which is followed by another CPU burst, then another I/O burst, and so one

    $\to$ Eventually, the final CPU burst ends with a system request to terminate execution

**CPU burst duration**. Vary greatly from process to process, and from computer to computer, but they tend to have a frequency curve similar to the following figure

$\to$ The curve is generally characterized as exponential or hyperexponential, with a large number of short CPU bursts and a small number of long CPU bursts

<div style="text-align:center">
    <img src="https://i.imgur.com/G3UpxXu.png">
    <figcaption>Burst duration (in milliseconds) distribution</figcaption>
</div>

>**NOTE**. This distribution can be important in the selection of an appropriate CPU-scheduling algorithm

* *I/O bound program*. Typically has many short CPU bursts
* *CPU bound program*. Might have a few long CPU burst

### CPU scheduler
**Short-term scheduler**. Whenever the CPU become idle, the OS must select one of the processes in the ready queue to be executed
* *Idea*. The scheduler selects a process from the processes in memory, which are ready to execute and allocates the CPU to that process
* *Ready queue*. Not necessarily a FIFO queue, it can be a priority queue, a tree, or simply an unordered linked list
    * *Queue entries*. Generally process control blocks (PCBs) of the processes

### Preemptive scheduling
**Cases for CPU-scheduling decisions**. CPU-scheduling decisions may take place under the following cases
1. When a process switches from the running state to waiting state, e.g. as the result of an I/O request or an invocation of `wait` for the termination of one of the child processes
2. When a process switches from the running state to the ready state, e.g. when an interrupt occurs
3. Whewn a process switches from the waiting state to the ready state, e.g. at completion of I/O
4. When a process terminates

>**NOTE**. For cases 1 and 4, there is no choice in terms of scheduling, since a new process (if one exists in the ready queue) must be selected for execution

>**NOTE**. There is a choice for cases 2 and 3

**Nonpreemptive (or cooperative) scheduling scheme**. When scheduling takes place only under cases 1 and 4, then the scheduling scheme is non-preemptive, otherwise, it is preemptive
* *Non-preemptive scheduling*. Once the CPU has been allocated to a process, the process keeps the CPU until it releases the CPU either by terminating or by switching to the waiting state

    $\to$ No process is interrupted until the process is completed, and after that the processor switches to another process 
    * *Use cases*. Microsoft Windows 3.x
* *Preemptive scheduling*. There is interruptions during the execution of the process, with the intention of resuming the process at a later time
    * *Use cases*. Microsoft Windows 95 and subsequent versions, Mac OS X
    * *Drawback*. Incur a cost associated with access to shared data
        * *Explain*. If two processes share some data
            * While one is updating the data, it is preempted, i.e. interrupted, so that the second process can run
            * The second process then tries to read the data, but they are in an inconsistent state

                $\to$ We need mechanisms to coordinate access to shared data

>**NOTE**. Cooperative scheduling is the only method which can be used on certain hardware platforms, since it does not require the special hardware, e.g. a timer, required for preemptive scheduling

**Preemption and the design of OS kernel**. Preemption affects the design of the OS kernel
* *Problem*. During the processing of a system call, the kernel may be busy with an activity on behalf of a process (as part of the system call), e.g. changing important kernel data, etc.

    $\to$ What if the process is preempted, i.e. stopped or paused, in the middle of these changes and the kernel, or the device driver, needs to read or modify the same structure
* *Solution*. Certain OSes, including most versions of UNIX, waits either for a system call to complete, or for an I/O block to take place, before doing a context switch

    $\to$ This ensures that the kernel structure is simple, since the kernel will not preempt a process while the kernel data structures are in an inconsistent state
    * *Drawback*. This kernel-execution model is a poor one for supporting real-time conputing and multiprocessing

**Critical section and interrupts**. Interrupts can occur at any time, and they cannot always be ignored by the kernel

$\to$ The sections of code affected by interrupts must be guarded from simultaneous use

### Dispatcher
**Dispatcher**. A component involved in the CPU-scheduling function
* *Dispatcher*. The module giving control of the CPU to the process selected by the short-term scheduler
* *Functionality*.
    * Switching context
    * Switching to user mode
    * Jumping to the proper location in the user program to restart the program
* *Requirements*. The dispatcher should be as fast as possible, since it is invoked during every process switch
    * *Dispatch latency*. The time for the dispatcher to stop one process and start another running