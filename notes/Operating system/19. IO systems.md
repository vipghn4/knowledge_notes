---
title: 1. Introduction and review about computer system
tags: Operating system
---

<!-- TOC titleSize:1 tabSpaces:2 depthFrom:1 depthTo:6 withLinks:1 updateOnSave:1 orderedList:0 skip:0 title:1 charForUnorderedList:* -->
# Table of Contents
- [Table of Contents](#table-of-contents)
- [I/O systems](#io-systems)
  - [Overview](#overview)
  - [I/O hardware](#io-hardware)
    - [Polling](#polling)
    - [Interrupts](#interrupts)
<!-- /TOC -->

# I/O systems
## Overview
**I/O subsystem**. Since I/O devices vary so widely in their function and speed, varied methods are required to control them

$\to$ This subsystem separates the rest of the kernel from the complexities of mananaging I/O devices

**I/O device technology trends**. There are two conflict trends
* *Option 1*. Increasing stnadardization of software and hardware interfaces

    $\to$ This helps us to incorporate improved device generations into existing computers and operating systems
* *Option 2*. Increasingly broad variety of I/O devices, where new devices are so unlike previous devices

    $\to$ This is a challenge to incorporate them into our computers and OSes
    * *Solution*. Use a combination of hardware and software techniques
        * *Hardware*. The basic I/O hardware elements, e.g. ports, buses, and device controllers, accommodate a wide variety of I/O devices
        * *Software*. To encapsulate the details and oddities of different devices, the kernel of an OS is structured to use device-driver modules

**Device driver**. A uniform device-access interface to the I/O subsystem

## I/O hardware
**Types of hardware devices**. Most devices fit into the general categories of
* Storage devices, e.g. disks, tape, etc.
* Transmission devices, e.g. network cards, modems, etc.
* Human-interface devices, e.g. screen, keyboard, mouse, etc.
* Other specialized devices, e.g. those in the steering of military fighter jet, or a space shuttle

**Device-computer communication**. A device communicates with a computer system by sending signals over cable, or even through the air
* *Port*. A connection point, via which the device communicates with the machine
    * *Example*. A serial port
* *Bus*. If devices use a common set of wires, the connection is called a bus
    * *Bus*. A set of wires, and rigidly defined protocol specifying a set of messages which can be sent on the wires
    * *Message format*. In terms of the electronics, the messages are conveyed by patterns of electrical voltages applied to the wires with defined timings
* *Daisy chain*. When device A has a cable plugging into device B, and device B has cable plugging into device C, and device C plugs into a port on the computer
    * *Daisy chain as a bus*. A daisy chain usually operates as a bus

**Types of buses**. Buses are used widely in computer architecture, and vary in their signaling methods, speed, throughput, and connection methods

<div style="text-align:center">
    <img src="https://i.imgur.com/LJmJvf2.png">
    <figcaption>A typical PC bus structure</figcaption>
</div>

* *PCI bus*. The common PC system bus connecting the processor-memory subsystem to the fast devices
* *Expansion bus*. Connect relatively slow devices, e.g. the keyboard and serial and USB ports
* *SCSI bus*. Plugged into a SCSI controller, which connects the disks
* *Other common buses*. 
    * PCI-X, with throughput up to 4.3 GB
    * PCI Express (PCIe), with throughput up to 16 GB
    * HyperTransport, with throughput up to 20 GB

**Controller**. A collection of electronics, which can operate on a port, a bus, or a device
* *Example*. 
    * A serial-port controller, i.e a single chip, or portion of a chip, in the computer, which controls the signals on the wires of a serial port
    * A SCSI bus controller, i.e. implemented as a separate circuit board, or a host adapter, plugging into the computer
        * *Explain*. The SCSI protocol is complex
        * *SCSI controller structure*. Contain a processor, microcode, and some private memory to enable processing the SCSI protocol messages
    * Device built-in controllers, e.g. disk drive has a circuit board attached to one side, acting as a disk controller
        * *Purpose*. Implement the disk side of the protocol for some kind of connection, e.g. SCSI or ATA
        * *Structure*. Have a microcode, and a processor to do many tasks
* *Interaction with the main processor*. The controller has one or more registers for data and control signals

    $\to$ The processor communicates with the controller by reading and writing bit patterns in these registers
    * *Option 1*. Use a special I/O instructions specifying the transfer of a byte or word to an I/O port address

        $\to$ The I/O instruction triggers bus lines to select the proper device and to move bits into or out of a device register
    * *Option 2*. The device controller can support memory-mapped I/O
        * *Idea*. The device-control registers are mapped into the address space of the processor

            $\to$ The CPU executes I/O requests using the standard data-transfer instructions to read and write the device-control registers
    * *Hybird option*. Some systems use both options above
        * *Explain*. Use I/O instructions to control some devices, and memory-mapped I/O to control others
* *Communication with GPUs*. The graphics controller has I/O ports for basic control operations, but the controller has a large memory-mapped region to hold screen contents
    * *Rendering screen image*.
        1. The proces sends output to the screen by writing data into the memory-mapped region
        2. The controller generates the screen image based on the contents of this memory
    * *Pros*. Writing millions of bytes to the graphics memory is faster then issuing millions of I/O instructions
    * *Cons*. Due to a common type of software fault is a write through an incorrect pointer to an unintended region of memory

        $\to$ A memory-mapped device register is vulnerable to accidental modification
        * *Solution*. Use protected memory

**I/O port registers**. An I/O port typically consists of four registers
* *Data-in register*. Read by the host to get input
* *Data-out register*. Written by the host to send output
* *Status register*. Contain bits, which can be read by the host

    $\to$ These bits indicate states, e.g. whether the current command has completed
* *Control register*. Can be written by the host to start a command, or to change the mode of a device

### Polling
**Basic handshaking of interaction protocol between the host and a controller**.
* *Scenario*. Assume that two bits are used to coordinate the procedure-consumer relationship between the controller and the host
* *Status register*. The controller indicates its state through the busy bit in the status register, i.e.
    * The controller sets the busy bit when it is busy working
    * The controller clears the busy it when it is ready to accept the next command
* *Command register*. The host signals its wishes via the command-ready bit in the command register
  * *Explain*. The host sets the command-ready bit when a command is available for the controller to execute
* *Handshaking procedure for coordination*. The host writes output through a port, coordinating with the controller by handshaking as follows
    1. The host repeatedly reads the busy bit, until that bit becomes clear
    2. The host sets the write bit in the command register, and writes a byte into the data-out register
    3. The host sets the command-ready bit
    4. When the controller notices that the command-ready bit is set

        $\to$ It sets the busy bit
    5. The controller reads the command register, and see the `write` command

        $\to$ It reads the data-out register to get the byte, and does the I/O to the devic
    6. The controller clears the command-ready bit, clears the error bit in the status register, to indicate that the device I/O succeeded

        $\to$ The controller then clears the busy bit to indicate that it is finished

**Busy-waiting or polling**. The action of the host reading the status register over and over, until the busy bit becomes clear
* *Problem*. If the controller and device are fast, this method is reasonable, otherwise, the host should probably switch to another task
    * *Question*. How does the host know when the controller has become idle
        * *Explain*. For some devices, the host must service the device quickly, or data will be lost
* *CPU-instruction cycles sufficient to poll a device*.
    * *Read instruction*. To read a device regsiter
    * *Logical-and instruction*. To extract a status bit
    * *Branch instruction*. To branch out if the busy-bit is not zero
* *Solution*. Arrange for the hardware controller to notify the CPU, when the device becomes ready for service, rather than to require the CPU to poll repeatedly for an I/O completion
* *Interrupt*. The hardware mechanism enabling a device to notify the CPU

### Interrupts
**Basic interrupt mechanism**.
* *Interrupt-request line*. The CPU hardware has an interrupt-request line, which the CPU sense after executing every instruction
* *Interrupt handling* When the CPU detects that a controller has asserted a signal on the interrupt-request line

    $\to$ It performs a state save, and jumps to the interrupt-handler routine at a fixed address in memory
* *Interrupt-handler routine*. 

    <div style="text-align:center">
        <img src="https://i.imgur.com/dfeX0On.png">
        <figcaption>Interrupt-driven I/O cycle</figcaption>
    </div>

    1. Determine the cause of the interrupt
    2. Perform the necessary processing
    3. Perform a state restore
    4. Execut a `return from interrupt` instruction to return the CPU to the execution state, prior to the interrupt
* *Terminology for the procedure above*. We say that 
    1. The device controller raises an interrupt by asserting a signal on the interrupt request line
    2. The CPU catches the interrupt, and dispatches it to the interrupt handler
    3. The CPU dispatches it to the interrupt handler
    4. The handler clears the interrupt by servicing the device

**Modern OS's interrupt mechanism**. 
* *Requirements*. We need a more sophisticated interrupt-handling features, i.e.
    * The ability to defer interrupt handling during critical processing
    * An efficient way to dispatch to the proper interrupt handler for a device, without first polling all the devices to see which one raised the interrupt
    * Multi-level interrupts, i.e. for the OS to distinguish between high- and low-priority interrupts

        $\to$ The OS can repsond with the appropriate degree of urgency
* *Interrupt-controller hardware*. Features above are provided by the CPU, and by the interrupt-controller hardware

**Types of interrupt request lines**.
* *Nonmaskable interrupt*. Reserved for events like unrecoverable memory errors
* *Maskable interrupt*. Can be turned off by the CPU, before the execution of critical instruction sequences, which must not be interrupted

    $\to$ This line is used by device controllers to request service