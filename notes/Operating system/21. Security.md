<!-- TOC titleSize:1 tabSpaces:2 depthFrom:1 depthTo:6 withLinks:1 updateOnSave:1 orderedList:0 skip:0 title:1 charForUnorderedList:* -->
# Table of Contents
- [Table of Contents](#table-of-contents)
- [Security](#security)
  - [The security problem](#the-security-problem)
  - [Program threats](#program-threats)
    - [Trojan horse](#trojan-horse)
    - [Trap door](#trap-door)
    - [Logic bomb](#logic-bomb)
    - [Stack and buffer overflow](#stack-and-buffer-overflow)
    - [Viruses](#viruses)
  - [System and network threats](#system-and-network-threats)
    - [Worms](#worms)
    - [Port scanning](#port-scanning)
    - [Denial of service](#denial-of-service)
  - [Cryptography as a security tool](#cryptography-as-a-security-tool)
    - [Encryption](#encryption)
      - [Symmetric encryption](#symmetric-encryption)
      - [Asymmetric encryption](#asymmetric-encryption)
      - [Authentication](#authentication)
      - [Key distribution](#key-distribution)
    - [Implementation of cryptography](#implementation-of-cryptography)
  - [User authentication](#user-authentication)
    - [Passwords](#passwords)
    - [Password vulnerabilities](#password-vulnerabilities)
    - [Encrypted passwords](#encrypted-passwords)
    - [One-time passwords](#one-time-passwords)
    - [Biometrics](#biometrics)
  - [Example - Windows](#example---windows)
<!-- /TOC -->

# Security
**Protection and security**. A protection system is ineffective if user authentication is compromised or a program is run by an unauthorized user
* *Protection*. An internal problem concerning how to provide controlled access to programs and dat stored in a computer system
* *Security*. Require an adequate protection and consideration of the external environment, within which the system operates

**Security of computer resources**. Must be guarded against unauthorized access, malicious destruction or alteration, and accidental introduction of inconsistency

$\to$ This chapter examines ways, in which resources may be accidentally or purposely misused

## The security problem
**Secure system**.
* *Motivation*. The OS can provide mechanisms, with appropriate aid from the hardware, allowing users to protect their resources, including programs and data

    $\to$ This works well only as long as the users conform the intended use of and access to these resources
* *Secure system*. A system is secure if its resources are used and accessed as intended under all circumstances
    * *Problem*. Total security cannot be achieved, hence we must have mechanisms to make security breaches a rare occurrence, rather than the norm

**Security violations (or misuse) categories of the system**. These violations can be categorized as internal, i.e. malicious, or accidental

$\to$ It is easier to protect against accidental misuse than malicious misuse

>**NOTE**. For the most part, protection mechanisms are the core of protection from accidents

* *Terminology*.
    * *Intruder and cracker*. Those attempting to breach security
    * *Thread*. The potential for a security violation, e.g. the discovery of vulnerability
    * *Attack*. The attempt to break security
* *Breach of confidentiality*. Involve unauthorized reading of data, or theft of information

    $\to$ This is typically the goal of an intruder
* *Breach of integrity*. Involve unauthorized destruction of data
* *Theft of service*. Involve unauthorized use of resources
* *Denial of service (DOS)*. Involve preventing legitimate use of the system

**Methods of attack**.
* *Masquerading*. One participant in a communication pretends to be someone else, e.g. another host or another person

    $\to$ Attackers breach authentication, i.e. the correctness of identification
    * *Consequence*. 
        * Attackers can gain access that they would not normally be allowed or 
        * Attackers can escalate their privileges, i.e. obtain privileges to which they would not normally be entitled
* *Replay attack*. Consist of the malicious or fraudulent repeat of a valid data transmission

    $\to$ This is frequently done along with message modification, to escalate privileges
* *Man-in-the-middle attack*. An attacker sits in the data flow of a communication, masquerading as the sender to the receiver, and vice versa

    $\to$ This can be preceded by a session hijacking, i.e. an active communication is intercepted

**Levels of security measures**. The cost to the perpetrator can be made sufficiently high to deter most intruders

>**NOTE**. In some cases, it is preferable to prevent the attack, but sufficient to detect the attack then take countermeasures

* *Physical*. The site or sites containing the computer system must be physically secured against armed or surreptitious entry by intruders

    $\to$ Both the machine rooms and the terminals or workstations having access to the machines must be secured
* *Human* Authorization must be done carefully to assure that only appropriate users have access to the system
    * *Threats from authorized users*. Authorized users may be encouraged to let others use their access
    * *Social engineering*. Authorized users can be tricked via social engineering into allowing access
        * *Phishing*. A legitimate-looking e-mail or Web page misleads a user to entering confidential information
        * *Dumpster diving*. Attempting to gather information to gain unauthorized access to the computer
* *OS*. The system must protect itself from accidental or purposeful security breaches
* *Network*. 
    * Intercepting data travelling over private leased lines and shared lines could be as harmful as breaking into a computer
    * Interruption of communication may constitute a remote DOS attack, diminishing users' user of and trust in the system

## Program threats
**Brief**. Processes, along with the kernel, are the only means of accomplishing work on a computer

$\to$ Writing a program that creates a breach of security, or causing a normal process to change its behavior and create a breach, is a common goal of crackers

>**NOTE**. Even most nonprogram security events have as their goal causing a program threat

### Trojan horse
**Brief**. Many systems have mechanisms allowing programs written by users to be executed by other users

$\to$ If these programs are executed in a domain that provides the access rights of the executing user, the other users may misuse these rights

**Trojan horse**. A code segment misusing its environment

**Spyware**. A variation on the Trojan horse, which sometimes accompanies a program that the user has chosen to install
* *Goal of spyware*. 
    * Download ads to display on the user’s system, create pop-up browser windows when certain sites are visited, or
    * Capture information from the user’s system and return it to a central site
        
        $\to$ This is an example of a general category of attacks known as covert channels, i.e. surreptitious communication occurs
* *Violation of the principle of least privilege*. Spyware is a micro example of the violation of the principle of least privilege
    * *Explain*. Under most circumstances, a user of an OS does not need to install network daemons
        
        $\to$ Such daemons are installed via two mistakes
        * A user may run with more privileges than necessary, e.g. as the administrator, allowing programs that she runs to have more access to the system than is necessary
            
            $\to$ This is a case of human error, i.e. a common security weakness
        * An OS may allow by default more privileges than a normal user needs
            
            $\to$ This is a case of poor OS design decisions
* *Conclusion*. An OS and softwares should allow fine-grained control of access and security, but it must also be easy to manage and understand
    * *Explain*. Inconvenient or inadequate security measures are bound to be circumvented
        
        $\to$ This causes an overall weakening of the security they were designed to implement

### Trap door
**Trap door**. The designer of a program or system might leave a hole in the software that only he is capable of using

**Trap door in compilers**. A clever trap door could be included in a compiler
* *Explain*. The compiler could generate standard object code as well as a trap door, regardless of the source code being compiled
    
    $\to$ This activity is particularly nefarious
    * *Explain*. A search of the source code of the program will not reveal any problems. Only the source code of the compiler would contain the information

**Trap door detection**. To detect them, we have to analyze all the source code for all components of a system

$\to$ Given that software systems may consist of millions of lines of code, this analysis is not done frequently, and frequently it is not done at all

### Logic bomb
**Logic bomb**. A program initiating a security incident only under certain circumstances

$\to$ It is hard to detect since under normal operations, there would be no security hole
* *Example*. A programmer may write code to detect whether she was still employed
    
    $\to$ If that check failed, a daemon could be spawned to allow remote access, or code could be launched to cause damage to the site

### Stack and buffer overflow
**Stack- or buffer-overflow attack**. The most common way for an attacker outside the system, on a network or dial-up connection, to gain unauthorized access to the target system

>**NOTE**. An authorized user of the system may also use this exploit for privilege escalation

* *Idea*. The attack exploits a bug in a program, which can be a simple case of poor programming, i.e. the programmer neglected to code bounds checking on an input field
    
    $\to$ The attacker sends more data than the program was expecting
* *Implementation*. By using trial and error, or by examining the source code of the attacked program if it is available
    
    $\to$ The attacker determines the vulnerability and writes a program to do the following
    1. Overflow an input field, command-line argument, or input buffer until it writes into the stack
    2. Overwrite the current return address on the stack with the address of the exploit code loaded in step 3
    3. Write a simple set of code for the next space in the stack that includes the commands that the attacker wishes to execute, e.g. spawn a shell
        
        $\to$ This attack program’s execution will be a root shell or other privileged command execution
* *Example*. 
    * *Scenario*. Consider a Web-page form expecting a user name to be entered into a field
            
        $\to$ The attacker could send the user name with following additional information
        * Extra characters to overflow the buffer and reach the stack
        * A new return address to load onto the stack
        * The code the attacker wants to run
    * *Consequence*. When the buffer-reading subroutine returns from execution
        
        $\to$ The return address is the exploit code, and the code is run

**Example and analysis**.
* *Program of interest*. Consider the following simple C program

    ```cpp
    #include <stdio.h>
    #define BUFFER_SIZE 256
    int main(int argc, char *argv[]) {
        char buffer[BUFFER_SIZE];
        if (argc < 2)
            return -1;
        else {
            strcpy(buffer,argv[1]);
            return 0;
        }
    }
    ```

    * *Explain*. The program creates a character array of size `BUFFER_SIZE` and copies the contents of `argv[1]`

        $\to$ As long as the size of this parameter is less than `BUFFER_SIZE`, this program works properly
        
        >**NOTE**. We need one byte to store the null terminator

* *Faulty scenario*. If `argv[1]` is longer than `BUFFER_SIZE`, `strcpy()` will begin copying from `argv[1]` until it encounters a null terminator, or until the program crashes
    
    $\to$ This program suffers from a potential buffer-overflow problem, in which copied data overflow the buffer array
    * *Bound checking solution*. A programmer can perform bounds checking on the size of `argv[1]` by using the `strncpy()` function rather than `strcpy()`
        * *Problems*. 
            * Good bounds checking is the exception rather than the norm
            * Lack of bounds checking is not the only possible cause of the behavior of the underlying program
                * *Explain*. The program could be carefully designed to compromise the integrity of the system
* *Possible security vulnerabilities of a buffer overflow*. 
    * *Stack frame*. When a function is invoked in a typical computer architecture, the following data are stored in the stack frame
        * The variables defined locally to the function, i.e. automatic variables
        * The parameters passed to the function
        * The address to which control returns once the function exits
    * *Typical layout for a stack frame*.

        <div style="text-align:center">
            <img src="https://i.imgur.com/6kR1KwB.png">
            <figcaption>Layout for a typical stack frame</figcaption>
        </div>

    * *Frame pointer*. The address of the beginning of the stack frame
        * *Storage of frame pointer*. The frame pointer must be saved on the stack
            * *Explain*. The value of the stack pointer can vary during the function call
        * *Usage*. The saved frame pointer allows relative access to parameters and automatic variables
    * *Prepare for a buffer-overflow attack*. Given the standard memory layout, a cracker could execute a bufferoverflow attack
        
        $\to$ Her goal is to replace the return address in the stack frame so that it points to the code segment containing the attacking program
        * *Example code*. 

            ```cpp
            #include <stdio.h>
            int main(int argc, char *argv[]) {
                execvp(‘‘\bin\sh’’,‘‘\bin \sh’’, NULL);
                return 0;
            }
            ```

            * *Explain*. Using the `execvp()` system call, this code segment creates a shell process
                
                $\to$ If the program being attacked runs with system-wide permissions, this newly created shell will gain complete access to the system
            * *Consequence*. The code segment could do anything allowed by the privileges of the attacked process
        * *Errornous code injection*. The code segment is compiled so that the assembly-language instructions can be modified
            * *Primary modification*. Remove unnecessary features in the code, hence reducing the code size so that it can fit into a stack frame
                
                $\to$ This assembled code fragment is now a binary sequence that will be at the heart of the attack
    * *Buffer-overflow attack*. Consider when `main()` is called, the stack frame appears as 
        
        <div style="text-align:center">
            <img src="https://i.imgur.com/3jjUu7k.png">
            <figcaption>Hypothetical stack frame (before and after)</figcaption>
        </div>

        1. Using a debugger, the programmer then finds the address of `buffer[0]` in the stack
           
            $\to$ That address is the location of the code the attacker wants executed
        2. The binary sequence is appended with the necessary amount of `NO-OP` instructions to fill the stack frame up to the location of the return address
        3. The new return address, i.e. the location of `buffer[0]`, is added
        4. The attack is complete when the attacker gives this constructed binary sequence as input to the process
        5. The process then copies the binary sequence from `argv[1]` to position `buffer[0]` in the stack frame
        6. When control returns from `main()`, instead of returning to the location specified by the old value of the return address
            
            $\to$ We return to the modified shell code, which runs with the access rights of the attacked process

**Possibility of buffer-overflow attack**. It seems that considerable knowledge and programming skill are needed to recognize exploitable code and then to exploit it

$\to$ Unfortunately, it does not take great programmers to launch security attacks
* *Explain*. One cracker can determine the bug and then write an exploit
    
    $\to$ Anyone with rudimentary computer skills and access to the exploit can try to launch the attack at target systems

**Consequences of buffer-overflow attack**. The buffer-overflow attack is especially pernicious
* *Explain*. It can be run between systems and can travel over allowed communication channels
    
    $\to$ Such attacks can occur within protocols that are expected to be used to communicate with the target machine, and they can therefore be hard to detect and prevent

    >**NOTE**. They can even bypass the security added by firewalls

**Solution**. Have a CPU with a feature disallowing execution of code in a stack section of memory
* *Examples*. Recent versions of AMD and Intel x86 chips include the NX feature to prevent this type of attack
    
    $\to$ The use of the feature is supported in several x86 OSs, including Linux and Windows XP SP2 and beyond
* *Hardware implementation*. Involve using a new bit in the page tables of the CPUs to mark the associated page as nonexecutable
    
    $\to$ Instructions cannot be read from it and executed

### Viruses
**Virus**. A fragment of code embedded in a legitimate program, which are self-replicating and are designed to
infect other programs

$\to$ They can wreak havoc in a system by modifying or destroying files and causing system crashes and program malfunctions

>**NOTE**. Viruses are very specific to architectures, OSs, and applications

>**NOTE**. Viruses are a particular problem for users of PCs

* *UNIX and viruses*. UNIX and other multiuser OSs generally are not susceptible to viruses
    * *Explain*. The executable programs are protected from writing by the OS
        
        $\to$ Even if a virus does infect such a program, its powers usually are limited because other aspects of the system are protected
* *Forms of viruses*. 
    * Viruses are usually borne via e-mail, with spam the most common vector
    * Viruses can spread when users download viral programs from Internet file-sharing services or exchange infected disks
    * Viruses can spread via Microsoft Office files, e.g. Microsoft Word documents
        * *Explain*. These documents can contain macros, i.e. Visual Basic programs, that programs in the Office suite will execute automatically
        * *Consequence*. Since these programs run under the user’s own account
            
            $\to$ The macros can run largely unconstrained, e.g. deleting user files at will
    
    >**NOTE**. Commonly, the virus will also e-mail itself to others in the user’s contact list

* *Example of faulty Visual Basic macro*. A virus could use the following VB macro to format the hard drive of a Windows computer as soon as the file containing the macro was opened

    ```bash
    Sub AutoOpen()
    Dim oFS
        Set oFS = CreateObject(’’Scripting.FileSystemObject’’)
        vs = Shell(’’c: command.com /k format c:’’,vbHide)
    End Sub
    ```

* *How viruses work*. Once a virus reaches a target machine, a program, i.e. a virus dropper, inserts the virus into the system
    * *Virus dropper*. Usually a Trojan horse, executed for other reasons but installing the virus as its core activity
        
        $\to$ Once installed, the virus may do any one of a number of things

**Types of viruses**. Many viruses belong to more than one category
* *File*. 
    * *Data flow*. A standard file virus infects a system by appending itself to a file, i.e.
        1. It changes the start of the program so that execution jumps to its code
        2. After it executes, it returns control to the program so that its execution is not noticed
    * *Parasitic viruses*. Another name for file viruses, i.e. they leave no full files behind and leave the host program still functional
* *Boot*. A boot virus infects the boot sector of the system, **executing** every time the system is booted and before the OS is loaded

    <div style="text-align:center">
        <img src="https://i.imgur.com/LbRG45u.png">
        <figcaption>A boot-sector computer virus</figcaption>
    </div>

    * *Idea*. It watches for other bootable media and infects them
    * *Memory viruses*. Another name for boot viruses, i.e. they do not appear in the file system
* *Macro*. Most viruses are written in a low-level language, e.g. assembly or C
    
    $\to$ Macro viruses are written in a high-level language, e.g. Visual Basic
    * *Idea*. These viruses are triggered when a program capable of executing the macro is run
* *Source* code. A source code virus looks for source code and modifies it to include the virus and to help spread the virus
* *Polymorphic*. A polymorphic virus changes each time it is installed to avoid detection by antivirus software
    
    $\to$ The changes do not affect the virus’s functionality but change the virus’s signature
    * *Virus signature*. A pattern that can be used to identify a virus, e.g. a series of bytes making up the virus code
* *Encrypted*. An encrypted virus includes decryption code along with the encrypted virus, again to avoid detection
    
    $\to$ The virus first decrypts and then executes
* *Stealth*. This tricky virus attempts to avoid detection by modifying parts of the system that could be used to detect it
    * *Example*. It could modify the `read` system call so that if the file it has modified is read
        
        $\to$ The original form of the code is returned rather than the infected code
* *Tunneling*. This virus attempts to bypass detection by an antivirus scanner by installing itself in the interrupt-handler chain
    
    $\to$ Similar viruses install themselves in device drivers
* *Multipartite*. A virus of this type is able to infect multiple parts of a system, including boot sectors, memory, and files
    
    $\to$ This makes it difficult to detect and contain
* *Armored*. An armored virus is coded to make it hard for antivirus researchers to unravel and understand
    * *Examples*.
        * It can be compressed to avoid detection and disinfection
        * Virus droppers and other full files, which are part of a virus infestation, are frequently hidden via file attributes or unviewable file names

>**NOTE**. This vast variety of viruses is likely to continue to grow

**Conclusion**. Viruses are the most disruptive security attacks, and since they are effective

$\to$ They will continue to be written and to spread

## System and network threats
**System and network threats**. Involve the abuse of services and network connections

$\to$ System and network threats create a situation, in which OS resources and user files are misused

>**NOTE**. Sometimes a system and network attack is used to launch a program attack, and vice versa

**Openness and security of OS**. 
* *Openness of OS*. The more open an OS is, the more services it has enabled and the more functions it allows

    $\to$ The more likely it is that a bug is available to exploit
* *Security of OS*. Increasingly, OSs strive to be secure by default
    * *Examples*. Solaris 10 moved from a model, in which many services, e.g. FTP, telnet, etc., were enabled by default when the system was installed, to a model in which almost all services are disabled at installation time and must specifically be enabled by system administrators
        
        $\to$ Such changes reduce the system’s attack surface
* *Attack surface*. The set of ways, in which an attacker can try to break into the system

**Secrets**. 
* Sharing secrets, i.e. to prove identity and as keys to encryption, is required for authentication and encryption
* Sharing secrets is easier in environments, in which secure sharing methods exist
    * *Secure sharing methods*. Include shared memory and interprocess communications

### Worms
**Worm**. A process using the spawn mechanism to duplicate itself

$\to$ The worm spawns copies of itself, using up system resources and perhaps locking out all other processes
* *Effects on computer networks*. Worms may reproduce themselves among systems and thus shut down an entire network
    
    $\to$ Such an event occurred in 1988 to UNIX systems on the Internet, causing the loss of system and system-administrator time worth millions of dollars

**`rsh` attack**. The worm was made up of two programs, a grappling hook, i.e. a bootstrap or vector, program and the main program
1. Grappling hook is compiled and run on each machine it accessed
2. Once established on the computer system under attack
    
    $\to$ The grappling hook connected to the machine, where it originated and uploaded a copy of the main worm onto the hooked system 
3. The main program proceeded to search for other machines, to which the newly infected system could connect easily
    * *`rsh` command*. In these actions, Morris exploited the UNIX networking utility `rsh` for easy remote task execution
4. By setting up special files listing host–login name pairs, users can omit entering a password each time they access a remote account on the paired list
    
    $\to$ The worm searched these special files for site names, which would allow remote execution without a password
5. Where remote shells were established, the worm program was uploaded and began executing anew

**`finger` attack**,
* *`finger` utility*. Functions as an electronic telephone directory, i.e. the command

    ```bash
    finger user-name@hostname
    ```
    
    returns a person’s real and login names, with other information that the user may have provided, e.g. office and home address and telephone number, research plan, or clever quotation
    * *How `finger` executes*. `finger` runs as a background process, or daemon, at each BSD site and responds to queries throughout the Internet
* *Buffer-overflow attack on `finger`*. The worm executed a buffer-overflow attack on finger
    1. The program queried `finger` with a 536-byte string crafted to exceed the buffer allocated for input and to overwrite the stack frame
    2. Instead of returning to the main routine, where it resided before Morris’s call
        
        $\to$ The finger daemon was routed to a procedure within the invading 536-byte string residing on the stack
    3. The new procedure executed `/bin/sh`, which, if successful, gave the worm a remote shell on the machine under attack

**`sendmail` attack**. The bug exploited in `sendmail` also involved using a daemon process for malicious entry
* *`sendmail` utility*. Send, receive, and route electronic mail
    * *Debugging option*. Allow testers to verify and display the state of the mail system
        
        $\to$ This was useful to system administrators and was often left on
* *`sendmail` attack*. 
    1. The worm raises a call to debug that, instead of specifying a user address, issued a set of commands
        
        $\to$ These commands mailed and executed a copy of the grappling-hook program
    2. Once in place, the main worm systematically attempted to discover user passwords, i.e.
        1. It began by trying simple cases of no password or passwords constructed of account–user-name combinations
        2. It used comparisons with an internal dictionary of 432 favorite password choices
        3. It went to the final stage of trying each word in the standard UNIX on-line dictionary as a possible password
    3. The elaborate and efficient three-stage password-cracking algorithm enabled the worm to gain access to other user accounts on the infected system
    4. The worm then searched for `rsh` data files in these newly broken accounts and used them as described previously to gain access to user accounts on remote systems

**Prevention of worms**. The very features of the UNIX network environment that assisted in the worm’s propagation also helped to stop its advance
* *Explain*. Ease of electronic communication, mechanisms to copy source and binary files to remote machines, and access to both source code and human expertise allowed cooperative efforts to develop solutions quickly
    
    $\to$ By the evening of the next day, November 3, methods of halting the invading program were circulated to system administrators via the Internet
    * *Consequence*. Within days, specific software patches for the exploited security flaws were available

### Port scanning
**Port scanning**. Not an attack but a means for a cracker to detect a system’s vulnerabilities to attack
* *Idea*. Port scanning typically is automated, involving a tool that attempts to create a TCP/IP connection to a specific port or a range of ports
    * *Example*. If there is a known vulnerability, or bug, in `sendmail`
        
        $\to$ A cracker could launch a port scanner to try to connect to port 25 of a particular system or to a range of systems
        * *Consequence*. If the connection was successful, the cracker, or tool, could attempt to communicate with the answering service to determine if the service was indeed `sendmail`
            
            $\to$ If so, determine if it was the version with the bug

**Consequences of port scanning**.
* *Ideal scenario*. Consider a tool, in which each bug of every service of every OS was encoded
    1. The tool could attempt to connect to every port of one or more systems
    2. For every service that answered, it could try to use each known bug
        
        $\to$ Frequently, the bugs are buffer overflows, allowing the creation of a privileged command shell on the system
    3. From there, the cracker could install Trojan horses, back-door programs, etc.
* *Practical scenario*. There is no such tool, but there are tools that perform subsets of that functionality, e.g. `nmap`
    * *Idea*. When pointed at a target, `nmap` will determine what services are running, including application names and versions
        
        $\to$ It can identify the host OS, or provide information about defenses, e.g. firewalls

**Detecting port scanning**. Since port scans are detectable, they frequently are launched from zombie systems

$\to$ Such systems are previously compromised, independent systems serving their owners while being used for nefarious purposes
* *Consequence*. Zombies make crackers difficult to prosecute, since determining the source of the attack and the person that launched it is challenging

    $\to$ This is one of many reasons for securing “inconsequential” systems, not just systems containing “valuable” information or services

### Denial of service
**Denial-of-service attacks**. Aimed at disrupting legitimate use of a system or facility

$\to$ Denial-of-service attacks are generally network based

>**NOTE**. Most such attacks involve systems that the attacker has not penetrated

* *Motivation*. Launching an attack that prevents legitimate use is frequently easier than breaking into a machine or facility
* *Types of DoS attacks*.
    * *Option 1*. Use so many facility resources that, in essence, no useful work can be done
        * *Example*. A Web-site click could download a Java applet, which proceeds to use all available CPU time or to pop up windows infinitely
    * *Option 2*. Involve disrupting the network of the facility
        
        $\to$ These attacks result from abuse of some of the fundamental functionality of TCP/IP
        * *Example*. If the attacker sends the part of the protocol saying “I want to start a TCP connection” without following with the standard “The connection is now complete”
            
            $\to$ TCP sessions can be partially started
            * *Consequence*. If enough of these sessions are launched, they can eat up all the network resources of the system, disabling any further legitimate TCP connections
* *Prevention of DoS attacks*. It is impossible to prevent denial-of-service attacks, i.e. the attacks use the same mechanisms as normal operation

**Distributed DoS (DDoS) attacks**. Launched from multiple sites at once, toward a common target, typically by zombies

$\to$ DDOS attacks have become more common and are sometimes associated with blackmail attempts
* *Consequence*. A site comes under attack, and the attackers offer to halt the attack in exchange for money
* *Detection of DDoS attacks*. A site may not know it is under attack
    * *Explain*. It is difficult to determine whether a system slowdown is an attack or just a surge in system use

**Other aspects of DoS attacks**.
* If an authentication algorithm locks an account for a period of time after several incorrect attempts to access the account
    
    $\to$ An attacker could cause all authentication to be blocked by purposely making incorrect attempts to access all accounts
* A firewall that automatically blocks certain kinds of traffic could be induced to block that traffic when it should not

**Conclusion**. Programmers and systems managers need to fully understand the algorithms and technologies they are deploying

## Cryptography as a security tool
**Brief**. There are many defenses against computer attacks, running the gamut from methodology to technology

$\to$ The broadest tool available to system designers and users is cryptography
* *Identification of sender and recipient of interprocess communication*.
    * *Isolated computer*. The OS can reliably determine the sender and recipient of all interprocess communication
        * *Explain*. The OS controls all communication channels in the computer
    * *Network of computers*. 
        * A networked computer receives bits from the wire with no immediate and reliable way of determining the sender of those bits
        * The computer sends bits onto the network with no way of knowing who might eventually receive them

**Network addresses and the identification of sender and receiver of messages**. 
* *Idea*. 
    * *Receiving messages*. Network packets arrive with a source address, e.g. an IP address
    * *Sending messages*. When a computer sends a message, it names the intended receiver by specifying a destination address
* *Drawback*. If security matters, the source or destination address of a packet may not reliably determine who sent or received that packet
    * *Explain*. 
        * A rogue computer can send a message with a falsified source address
        * Numerous computers other than the one specified by the destination address can receive a packet
    * *Example*. All of the routers on the way to the destination will receive the packet
* *Needs for cryptography*. It is infeasible to build a network of any scale, in which the source and destination addresses of packets can be trusted in this sense
    
    $\to$ The only alternative is to eliminate the need to trust the network
    * *Consequence*. This is the job of cryptography

**Cryptography**. Used to constrain the potential senders and/or receivers of a message
* *Modern cryptography*. Based on secrets, i.e. keys, which are selectively distributed to computers in a network and used to process messages
* *Key idea*. Keys are designed so that it is not computationally feasible to derive them from the messages they were used to generate, or from any other public information
    
    $\to$ Keys provide a much more trustworthy means of constraining senders and receivers of messages
* *Usage*.
    * Cryptography enables a recipient of a message to verify that the message was created by some computer possessing a certain key
        
        $\to$ The key is the source of the message
    * A sender can encode its message so that only a computer with a certain key can decode the message
        
        $\to$ The key becomes the destination
### Encryption
**Brief**. Since it solves a wide variety of communication security problems, encryption is used frequently in many aspects of modern computing
* *Encryption*. A means for constraining the possible receivers of a message
* *Encryption algorithm*. Enable the sender of a message to ensure that only a computer possessing a certain key can read the message

**Secure communication between two users over an insecure channel**.

<div style="text-align:center">
    <img src="https://i.imgur.com/gHcH9Ha.png">
    <figcaption>A secure communication over an insecure medium</figcaption>
</div>

>**NOTE**. The key exchange can take place directly between the two parties or via a trusted third party

* *Encryption algorithm*. Consist of the following components
    * A set $K$ of keys
    * A set $M$ of messages
    * A set $C$ of ciphertexts
    * An encryption function $E : K \to (M \to C)$
        * *Idea*. For each $k \in K$, $E(k)$ is a function for generating ciphertexts from messages
        * *Requirements*. Both $E$ and $E(k)$ for any $k$ should be efficiently computable functions
    * A decryption function $D : K \to (C \to M)$
        * *Idea*. For each $k \in K$, $D(k)$ is a function for generating messages from ciphertexts
        * *Requirements*. Both $D$ and $D(k)$ for any $k$ should be efficiently computable functions
* *Essential property of an encryption algorithm*. Given a ciphertext $c \in C$, a computer can compute $m$ such that 
    
    $$E(k)(m) = c$$
    
    only if it possesses $D(k)$
    
* *Consequence*. 
    * A computer holding $D(k)$ can decrypt ciphertexts to the plaintexts used to produce them
    * A computer not holding $D(k)$ cannot decrypt ciphertexts
* *Requirements*. Since ciphertexts are generally exposed, it must be infeasible to derive $D(k)$ from the ciphertexts
* *Types of encryption algorithms*. Symmetric and asymmetric

#### Symmetric encryption
**Symmetric encryption algorithm**. The same key is used to encrypt and to decrypt
* *Formal*. $E(k)$ can be derived from $D(k)$, and vice versa
* *Consequence*. The secrecy of $E(k)$ must be protected to the same extent as that of $D(k)$

**Data-encryption standard (DES)**. The most commonly used symmetric encryption algorithm in the U.S. for civilian applications for the past several

$\to$ This is adopted by the National Institute of Standards and Technology (NIST)
* *Idea*. Take a 64-bit value and a 56-bit key and perform a series of transformations
    
    $\to$ These transformations are based on substitution and permutation operations, as is generally the case for symmetric encryption transformations

    >**NOTE**. Some of the transformations are black-box transformations, i.e. the algorithms are hidden

* *Encryption of messages longer than 64 bits*. Messages are broken into 64-bit chunks
    * *Block cipher*. Since DES works on a chunk of bits at a time, it is known as a block cipher
* *Cipher-block chaining*. If the same key is used for encrypting an extended amount of data
    
    $\to$ It becomes vulnerable to attack
    * *Example*. The same source block would result in the same ciphertext if the same key and encryption algorithm were used
    * *Solution*. The chunks are encrypted then exclusive-or’ed (XORed) with the previous ciphertext block before encryption
* *Drawback*. DES is now considered insecure for many applications 
    * *Explain*. Its keys can be exhaustively searched with moderate computing resources

**Triple DES**. A modification of DES created by NIST created
* *Idea*. Repeat the DES algorithm three times, i.e. two encryptions and one decryption, on the same plaintext using two or three keys
    * *Example* $c = E(k3)(D(k2)(E(K1)(m)))$
* *Effective key length*. When three keys are used, the effective key length is 168 bits
* *Usage*. Triple DES is in widespread use today

**Advanced encryption standard (AES)**. A new encryption algorithm adopted by NIST in 2001 to replace DES

$\to$ This is another symmetric block cipher
* *Key lengths*. It can use key lengths of 128, 192, and 256 bits
* *Ciphper block size*. works on 128-bit blocks
* *Idea*. It works by performing 10 to 14 rounds of transformations on a matrix formed from a block
* *Benefits*. Generally, the algorithm is compact and efficient

**Other symmetric block-encryption algorithms**.
* *Twofish algorithm*. 
    * Fast, compact, and easy to implement
    * It can use a variable key length of up to 256 bits and works on 128-bit blocks
* *RC5*. 
    * Can vary in key length, number of transformations, and block size
    * Since it uses only basic computational operations, it can run on a wide variety of CPUs
* *RC4*. Perhaps the most common stream cipher
    * *Stream cipher*. Designed to encrypt and decrypt a stream of bytes or bits rather than a block
        * *Usage*. When the length of a communication would make a block cipher too slow
    * *Key stream*. An infinite set of keys that can be used for the input plaintext stream
        * *Creation of key stream*. Input into a pseudo–random-bit generator, i.e. an algorithm attempting to produce random bits
            
            $\to$ The output of the generator when fed a key is a keystream
    * *Usage*.
        * Used in encrypting steams of data, e.g. WEP, the wireless LAN protocol
        * Used in communications between Web browsers and Web servers
    * *Drawback*. RC4 as used in WEP (IEEE standard 802.11) has been found to be breakable in a reasonable amount of computer time
        
        >**NOTE**. In fact, RC4 itself has vulnerabilities

#### Asymmetric encryption
**Asymmetric encryption algorithm**. There are different encryption and decryption keys

**RSA cipher**. A block-cipher public-key algorithm, which is the most widely used asymmetrical algorithm

>**NOTE**. Asymmetrical algorithms based on elliptical curves are gaining ground
>
>* *Explain*. The key length of such an algorithm can be shorter for the same amount of cryptographic strength

* *Public key and private key*. It is computationally infeasible to derive $D(k_d, N)$ from $E(k_e, N)$
    
    $\to$ $E(k_e, N)$ need not be kept secret and can be widely disseminated
    * *Public key*. $E(k_e, N)$, or just $k_e$
    * *Private key*. $D(k_d, N)$, or just $k_d$
* *Formulation of encryption and decryption functions*. Consider two large, randomly chosen prime numbers $p$ and $q$, and their product $N$
    * *Encryption algorithm*. $E(k_e, N)(m) = m^{k_e} \mod N$, where $k_e$ satisfies
        
        $$k_ek_d \mod (p−1)(q −1) = 1$$
    * *Decryption algorithm*. $D(k_d, N)(c) = c^{k_d} \mod N$

**Key distribution in asymmetric encryption algorithms**.
* *Publication of public keys* The public key of the destination is published
    * *Bidirectional communication*. The source also must publish its public key
    * *Publication of keys*. Can be as simple as handing over an electronic copy of the key, or can be more complex
* *Protection of private keys*. Anyone holding that key can decrypt any message created by the matching public key

**Difference from symmetric encryption**. The seemingly small difference in key use between asymmetric and symmetric cryptography is quite large in practice
* *Asymmetric cryptography*. Based on mathematical functions rather than transformations
    
    $\to$ Asymmetric cryptography is much more computationally expensive to execute
* *Symmetric cryptography*. It is much faster for a computer to encode and decode ciphertext by using the usual symmetric algorithms

**Applications of asymmetric cryptography**. These algorithms are not used for generalpurpose encryption of large amounts of data

$\to$ They are used for encryption of small amounts of data, and for authentication, confidentiality, and key distribution

#### Authentication
**Brief**. Encryption offers a way of constraining the set of possible receivers of a message
* *Authentication*. Constraining the set of potential senders of a message
* *Authentication and encryption*. Authentication is complementary to encryption, and sometimes their functions overlap
    * *Example*. An encrypted message can also prove the identity of the sender, i.e.
        * *Explain*. If $D(k_d, N)(E(k_e, N)(m))$ produces a valid message
            
            $\to$ We know that the creator of the message must hold $k_e$
* *Data integrity*. Authentication is useful for proving that a message has not been modified

**Authentication algorithm**.
* *Authentication algorithm*. Consist of the following components
    * A set $K$ of keys
    * A set $M$ of messages
    * A set $A$ of authenticators
    * A function $S : K \to (M \to A)$
        * *Idea*. For each $k\in K$, $S(k)$ is a function for generating authenticators from messages
        * *Requirements*. Both $S$ and $S(k)$ for any $k$ should be efficiently computable functions
    * A function $V : K \to (M × A \to \{\text{true}, \text{false}\})$
        * *Idea*. For each $k \in K$, $V(k)$ is a function for verifying authenticators on messages
        * *Requirements*. Both $V$ and $V(k)$ for any $k$ should be efficiently computable functions
* *Critical property of an authentication algorithm*. For a message $m$, a computer can generate an authenticator $a \in A$ such that
$V(k)(m, a) = \text{true}$ only if it possesses $S(k)$
* *Consequence*.
    * A computer holding $S(k)$ can generate authenticators on messages so that any computer possessing $V(k)$ can verify them
    * A computer not holding $S(k)$ cannot generate authenticators on messages that can be verified using $V(k)$
* *Requirements*. Since authenticators are generally exposed
    
    $\to$ It must not be feasible to derive $S(k)$ from the authenticators

**Types of authentiation algorithms**. As there are two types of encryption algorithms, there are two main varieties of authentication algorithms

$\to$ These algorithms are classified based on hash functions
* *Hash function $H(m)$*. Create a small, fixed-sized block of data, i.e. a message digest or hash value, from a message $m$
    * *Mechanism*. Hash functions work by taking a message in $n$-bit blocks and processing the blocks to produce an $n$-bit hash
    * *Requirements*. $H$ must be collision resistant on $m$, i.e. it must be infeasible to find an $m'\neq m$ such that $H(m) = H(m')$
        
        $\to$ If $H(m) = H(m')$, we know that $m = m'$, i.e. the message has not been modified
    * *Common message-digest functions*. MD5, i.e. produces a 128-bit hash, and SHA-1, i.e. outputs a 160-bit hash
    * *Encryption of message digests*. Message digests are useful for detecting changed messages but are not useful as authenticators
        * *Example*. $H(m)$ can be sent along with $m$, but if $H$ is known, then someone could modify m and recompute $H(m)$
            
            $\to$ The message modification would not be detected
        * *Solution*. An authentication algorithm takes the message digest and encrypts it
* *Message-authentication code (MAC)*. The first main type of authentication algorithm uses symmetric encryption
    * *Idea*. A cryptographic checksum is generated from the message using a secret key
    * *Needs for keeping $k$ secret*. Knowledge of $V(k)$ and knowledge of $S(k)$ are equivalent, i.e. one can be derived from the other
        
        $\to$ $k$ must be kept secret
    * *Example of a MAC*. 
        * *Signing function*. $S(k)(m) = f(k, H(m))$, where $f$ is a function that is one-way on its first argument
            * *One-way function $f(k,H(m))$*. $k$ cannot be derived from $f(k, H(m)))$
            * *Collision resistance*. Due to the collision resistance in the hash function, we are reasonably assured that no other message could create the same MAC
        * *Verification function*. $V(k)(m, a) = ( f (k, m) = a)$
* *Digital-signature algorithm (DSA)*. The second main type of authentication algorithm
    * *Digital signatures*. The authenticators produced by $S$
    * *Public key and private key*. In a DSA, it is computationally infeasible to derive $S(k_s)$ from $V(k_v)$, i.e. $V$ is a one-way function
        * *Public key*. $k_v$
        * *Private key*. $k_s$
    * *Example of a DSA*. The RSA digital-signature algorithm, which is similar to the RSA encryption algorithm, but the key use is reversed
        * *Authentication algorithm*. $S(k_s)(m) = H(m)^{k_s} \mod N$
            * *Private key $k_s$*. A pair $\langle d, N\rangle$, where $N$ is the product of two large, randomly chosen prime numbers $p$ and $q$
        * *Verification algorithm*. $V(k_v)(m, a) = (a^{k_v} \mod N = H(m))$, where $k_v$ satisfies
            
            $$k_vk_s \mod (p − 1)(q − 1) = 1$$

**Needs for authentication algorithms**/ If encryption can prove the identity of the sender of a message

$\to$ Why do we need separate authentication algorithms?
* Authentication algorithms generally require fewer computations, with the notable exception of RSA digital signatures
    
    $\to$ Over large amounts of plaintext, this efficiency can make a huge difference in resource use and the time needed to authenticate a message
* The authenticator of a message is almost always shorter than the message and its ciphertext
    
    $\to$ This improves space use and transmission time efficiency
* Sometimes, we want authentication but not confidentiality
    * *Example*. A company could provide a software patch, and could sign that patch to prove that it came from the company and that it has not been modified

**Applications of authentication**. Authentication is a component of many aspects of security
* *Example*. Authentication is the core of nonrepudiation, which supplies proof that an entity performed an action

#### Key distribution
**Brief**. A good part of the battle between cryptographers and cryptanalysts involves keys
* *Symmetric algorithms*. Both parties need the key, and no one else should have it
    * *Delivery of the symmetric key*. This is a huge challenge
        
        >**NOTE**. Sometimes it is performed out-of-band—say, via a paper document or a conversation
        >
        >$\to$ These methods do not scale well
    * *Key-management challenge*. Conider a user wanting to communicate with $N$ other users privately
        
        $\to$ The user needs $N$ keys and, for more security, would need to change those keys frequently
    * *Consequence*. These are the very reasons for efforts to create asymmetric key algorithms
* *Asymmetric key algorithms*.
    * *Advantages*.
        * The keys can be exchanged in public
        * A given user needs only one private key, no matter how many other people she wants to communicate with
    * *Distribution of public keys*. This requires some care
        * *Example*. Consider a man-in-the-middle attack, i.e.
            1. The person, who wants to receive an encrypted message, sends out his public key
            2. An attacker also sends her bad public key, which matches her private key
            3. The person, who wants to send the encrypted message, knows no better and hence uses the bad key to encrypt the message
            4. The attacker then happily decrypts it

**Solution for key distribution**. This problem is one of authentication, i.e. what we need is proof of who owns a public key

$\to$ We can use digital certificates
* *Digital certificate*. A public key digitally signed by a trusted party
    * *Idea*. The trusted party receives proof of identification from some entity and certifies that the public key belongs to that entity
    * *Establishing trust of the certifier*. These certificate authorities have their public keys included within Web browsers, before they are distributed
        
        $\to$ The certificate authorities can then vouch for other authorities, i.e. digitally signing the public keys of these other authorities, and so on, creating a web of trust

### Implementation of cryptography
**Cryptography in ISO networking layers**. Cryptography can be inserted at almost any layer in the ISO model
* *Transport-layer security*. Use SSL
* *Network-layer security*. Standardized on IPSec, which defines IP packet formats allowing the insertion of authenticators and the encryption of packet contents
    * *Idea*. Use symmetric encryption and the IKE protocol for key exchange
    * *VPNs*. IPSec is becoming widely used as the basis for VPNs
        * *Idea*. All traffic between two IPSec endpoints is encrypted to make a private network out of one that may otherwise be public
* *Application-layer security*. Numerous protocols also have been developed for use by applications
    
    $\to$ The applications themselves must be coded to implement security

**Best place for cryptographic protection**. There is no definitive answer in general
* On the one hand, more protocols benefit from protections placed lower in the stack
    * *Example*. Since IP packets encapsulate TCP packets
        * Encryption of IP packets, e.g. using IPSec, also hides the contents of the encapsulated TCP packets
        * Authenticators on IP packets detect the modification of contained TCP header information
* On the other hand, protection at lower layers in the protocol stack may give insufficient protection to higher-layer protocols
    * *Example*. An application server running over IPSec might be able to authenticate the client computers, from which requests are received
        * To authenticate a user at a client computer, the server may need to use an application-level protocol, e.g. using passwords
        * E-mail delivered via the industry standard SMTP protocol is stored and forwarded, frequently multiple times, before it is delivered
        
            $\to$ Each of these transmissions could go over a secure or an insecure network
            * *Consequence*. For e-mail to be secure, the e-mail message needs to be encrypted so that its security is independent of the transports that carry it

## User authentication
**Brief**. If a system cannot authenticate a user, then authenticating that a message came from that user is pointless

$\to$ A major security problem for OSes is user authentication
* *Motivation*. The protection system depends on the ability to identify the programs and processes currently executing
    
    $\to$ This depends on the ability to identify each user of the system
* *Key components of user authentication*. One or more of three things
    * The user’s possession of something, e.g. a key or card
    * The user’s knowledge of something, e.g. a user identifier and password
    * An attribute of the user, e.g. fingerprint, retina pattern, or signature

### Passwords
**Passwords**. The most common approach to authenticating a user identity
* *Idea*. 
    1. When the user identifies herself by user ID or account name, she is asked for a password
    2. If the user-supplied password matches the password stored in the system
        
        $\to$ The system assumes that the account is being accessed by the owner of that account
* *Usage*. Protect objects in the computer system, in the absence of more complete protection schemes
    
    $\to$ They can be considered a special case of either keys or capabilities
    * *Example*. A password may be associated with each resource, e.g. a file
        
        $\to$ Whenever a request is made to use the resource, the password must be given
        
    >**NOTE**. Different passwords may be associated with different access rights

* *Common practice*. One password is required for a user to gain full rights
    * *Explain*. Although more passwords theoretically would be more secure, systems tend not to be implemented
        
        $\to$ This is due to the classic trade-off between security and convenience
    * *Conclusion*. If security makes something inconvenient, then the security is frequently bypassed or otherwise circumvented

### Password vulnerabilities
**Password vulnerabilities**. Passwords can often be guessed, accidentally exposed, sniffed, or illegally transferred from an authorized user to an unauthorized one

**Guessing a password**. There are two common ways to guess a password
* *Option 1*. The intruder knows the user or has information about the user
* *Option 2*. Use brute force, trying enumeration, or all possible combinations of valid password characters
    
    $\to$ This repeats until the password is found
    
    >**NOTE**. Short passwords are especially vulnerable to this method

**Accidentally exposed passwords**. 
* *Visual or electronic monitoring*. Passwords can be exposed as a result of visual or electronic monitoring
    * *Example*. An intruder can look over the shoulder of a user when the user is logging in and can learn the password easily by watching the keyboard
* *Password sniffing*. Anyone with access to the network, on which a computer resides can seamlessly add a network monitor, allowing him to watch all data being transferred on the network
    * *Solution*. Encrypting the data stream containing the password
* *Conclusion*. Exposure is a particularly severe problem if the password is written down where it can be read or lost

**Illegal transfer of passwords**. The result of human nature
* *Solution*. Most computer installations have a rule that forbids users to share accounts
    
    $\to$ This rule is sometimes implemented for accounting reasons but is often aimed at improving security
    * *Example*. If one user ID is shared by several users, and a security breach occurs from that user ID
        
        $\to$ It is impossible to know 
        * Who was using the ID at the time the break occurred, or
        * Whether the user was an authorized one
    * *Consequence*. With one user per user ID
        * Any user can be questioned directly about use of the account
        * The user might notice something different about the account and detect the break-in
    * *Drawback*. Sometimes, users break account-sharing rules to help friends or to circumvent accounting
        
        $\to$ This can result in a system’s being accessed by unauthorized users

**Password generation**. Passwords can be either generated by the system or selected by a user
* *System-generated passwords*. Difficult to remember, and thus users may write them down
* *User-selected passwords*. Easy to guess
    * *Solution*. 
        * Some systems checks a proposed password for ease of guessing or cracking before accepting it
        * Administrators occasionally check user passwords and notify a user if his password is easy to guess
        * Some systems age passwords, forcing users to change their passwords at regular intervals
            * *Drawback*. This method is not foolproof, since users can easily toggle between two passwords
            * *Solution*. Record a password history for each user

### Encrypted passwords
**Brief**. One problem with all these approaches is the difficulty of keeping the password secret within the computer

**UNIX solution**. Use encryption to avoid the necessity of keeping its password list secret
* *Idea*. Each user has a password, and the system contains a function, which is extremely difficult to invert but is simple to compute

    $\to$ This function is used to encode all passwords
    * *Explain*. 
        * Given a value $x$, it is easy to compute the function value $f(x)$
        * Given a function value $f(x)$, it is impossible to compute $x$
    * *Consequence*. Only encoded passwords are stored
* *Password verification*. When a user presents a password, it is encoded and compared against the stored encoded password
    
    $\to$ Even if the stored encoded password is seen, it cannot be decoded, hence the password cannot be determined
    * *Consequence*. The password file does not need to be kept secret
* *Password encoding function $f(x)$*. Typically an encryption algorithm designed and tested rigorously

**Drawback of UNIX solution**. 
* The system no longer has control over the passwords
    * *Consequence*. Although the passwords are encrypted, anyone with a copy of the password file can run fast encryption routines against it
        * *Example*. Encrypting each word in a dictionary, and comparing the results against the passwords

            >**NOTE**. On sufficiently fast computers, or even on clusters of slow computers, such a comparison may take only a few hours

        * *Consequence*. If the user has selected a password that is also a word in the dictionary
            
            $\to$ The password is cracked
* Since UNIX systems use a well-known encryption algorithm, a cracker might keep a cache of passwords that have been cracked previously
    * *Solution*. 
        * *Option 1*. Store the encrypted password entries in a file readable only by the superuser
        * *Option 2*. Include a salt, i.e. recorded random number, in the encryption algorithm
            * *Explain*. The salt is added to the password to ensure that if two plaintext passwords are the same
                
                $\to$ They result in different ciphertexts
* Many UNIX systems treat only the first eight characters as significant
    
    $\to$ It is therefore extremely important for users to take advantage of the available password space
    
    >**NOTE**. To avoid the dictionary encryption method, some systems disallow the use of dictionary words as passwords
    
    * *Recommended passwords*. A good technique is to generate your password by using the first letter of each word of an easily remembered phrase using both upper and lower characters with a number or punctuation mark thrown in for good measure

### One-time passwords
**One-time passwords**. To avoid the problems of password sniffing and shoulder surfing

$\to$ A system could use a set of paired passwords
* *Idea*. When a session begins, the system randomly selects and presents one part of a password pair
    
    $\to$ The user must supply the other part
    * *Explain*. The user is challenged and must respond with the correct answer to that challenge
* *Generalization*. This approach can be generalized to the use of an algorithm as a password
    * *Example*. The system selects a random integer and presents it to the user
        1. The user applies a function and replies with the correct result
        2. The system also applies the function
        3. If the two results match, access is allowed
    * *Consequence*. A user can type in a password, and no entity intercepting that password will be able to reuse it
* *Shared secret between user and system*. The system and the user share a secret, which is never transmitted over a medium allowing exposure
    
    $\to$ The secret is used as input to the function, along with a shared seed
    * *Shared seed*. A random number or alphanumeric sequence, which is the authentication challenge from the computer
        1. The secret and the seed are used as input to the function $f(\text{secret}, \text{seed})$
        2. The result of this function is transmitted as the password to the computer
        3. Since the computer also knows the secret and the seed, it can perform the same computation
        4. If the results match, the user is authenticated
        5. The next time the user needs to be authenticated, another seed is generated, and the same steps ensue
        6. This time, the password is different

**Implementation**.
* Commercial implementations use hardware calculators, most of which are shaped like a credit card, a key-chain dangle, or a USB device

    $\to$ They include a display and may or may not also have a keypad
* Some use the current time as the random seed
* Others require the user to enter the shared secret, i.e. a personal identification number or PIN, on the keypad
    
    $\to$ The display then shows the one-time password
    * *Two-factor authentication*. The use of both a one-time password generator and a PIN
        * *Explain*. Two different types of components are needed
        * *Benefits*. Two-factor authentication offers far better authentication protection than single-factor authentication
* Some use a code book, or one-time pad, which is a list of single-use passwords
    
    $\to$ Each password on the list is used once and then is crossed out or erased

### Biometrics
Skipped

## Example - Windows
**Microsoft Windows**. A general-purpose OS designed to support a variety of security features and methods

**User accounts**. The Windows security model is based on the notion of user accounts

$\to$ Windows allows the creation of any number of user accounts that can be grouped in any manner
* *Access to resources*. Access to system objects can then be permitted or denied as desired
* *User identification*. Users are identified to the system by a unique security ID
* *Protection with user accounts*. 
    1. When a user logs on, Windows creates a security access token including
        * The security ID for the user
        * Security IDs for any groups, of which the user is a member
        * A list of any special privileges that the user has
            * *Examples*. Backing up files and directories, shutting down the computer, logging on interactively, and changing the system clock
    2. Every process that Windows runs on behalf of a user will receive a copy of the access token
    3. The system uses the security IDs in the access token to permit or deny access to system objects whenever the user, or a process on behalf of the user, attempts to access the object
* *Authentication of a user account*. Typically accomplished via a user name and password
    * *Custom authentication*. The modular design of Windows allows the development of custom authentication packages
        
        * *Examples*. A retinal, or eye, scanner might be used to verify that the user is who she says she is

**Subjects in Windows**. Windows uses the idea of a subject to ensure that programs run by a user do not get greater access to the system than the user is authorized to have
* *Subject*. Used to track and manage permissions for each program run by a user
    * *Subject structure*. Composed of
        * The user’s access token
        * The program acting on behalf of the user
    * *Types of subjects*. Since Windows operates with a client–server model, two classes of subjects are used to control access, i.e. simple subjects and server subjects
        * *Simple subject*. Assigned a security context based on the security access token of the user
        * *Server subject*. A process implemented as a protected server using the security context of the client when acting on the client’s behalf

**Auditing**. A useful security technique, which is built in Windows to allows many common security threats to be monitored
* *Examples*.
    * Failure auditing for login and logoff events to detect random password breakins
    * Success auditing for login and logoff events to detect login activity at strange hours
    * Success and failure write-access auditing for executable files to track a virus outbreak
    * Success and failure auditing for file access to detect access to sensitive files

**Security descriptor**. Describe security attributes of an object in Windows
* *Security descriptor structure*. Contain 
    * The security ID of the owner of the object, who can change the access permissions
    * A group security ID used only by the POSIX subsystem
    * A discretionary access-control list identifying which users or groups are allowed, and which are not allowed, access
    * A system access-control list controling which auditing messages the system will generate
    * A system access-control list of audit writes by everyone

**An access-control list**. 
* *List entry structure*. Contain
    * The security ID of the individual
    * An access mask defining all possible actions on the object
    * A value of `AccessAllowed` or `AccessDenied` for each action

**Container and non-container objects**. Windows classifies objects as either container objects or noncontainer objects
* *Container objects*. Can logically contain other objects, e.g. directories
    * *Permissions of objects within a container*. 
        * By default, when an object is created within a container object
            
            $\to$ The new object inherits permissions from the parent object
        * If the user copies a file from one directory to a new directory
            
            $\to$ The file will inherit the permissions of the destination directory

    >**NOTE**. If a permission is changed on a directory, the new permissions do not automatically apply to existing files and subdirectories
    >
    >$\to$ The user may explicitly apply them if she so desires

* *Noncontainer objects*. Inherit no other permissions