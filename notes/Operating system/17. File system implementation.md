---
title: 17. File system implementation
tags: Operating system
---

# Table of Contents
[toc]

# File-system implementation
## File system structure
**Characteristics making disks a convenient medium for storing multiple files**.
* A disk can be rewritten in place, i.e. it is possible to read a block from  the disk, modify the block, and write it back into the same place
* A disk can access directly any block of information it contains
    * *Consequences*.
        * It is simple to access any file, either sequentially or randomly
        * Switching from one file to another requires only moving the read-write heads and waiting for the disk to rotate

**Block I/O**. To improve I/O efficiency, I/O transfers between memory and disk are performed in units of blocks, each of which has one or more sectors
* *Sector size*. Vary from 32 bytes to 4096 bytes, depending on the disk drive
    * *Usualy size*. 512 bytes

**File system and disks**. File systems provide efficient and convenient access to the disk by allowing data to be stored, located, and retrieved easily
* *Design problems with file systems*.
    * *Problem 1*. Define how the file system should look to the user

        $\to$ This involves defining a file and its attributes, the operations allowed on a file, and the directory structure for organizing files
    * *Problem 2*. Create algorithms and data structures to map the logical file system onto the physical secondary-storage devices

<div style="text-align:center">
    <img src="/media/wPYCzJ5.png">
    <figcaption>Layered file system</figcaption>
</div>

**Levels of file system**. Each level in the file system uses the features of lower levels to create new features for use by higher levels
* *I/O control*. The lowest level, which consists of device drivers and interrupt handlers to transfer information between the main memory and the disk system
    * *Device driver*. A translator 
        * *Inputs*. High-level commands, e.g. `retrive block 123`
        * *Outputs*. Low-level, hardware-specific instructions used by the hardware controller, which interfaces the I/O device to the rest of the system
        * *Working mechanism*. Write specific bit patterns to special locations in the I/O controller's memory 
            
            $\to$ This tells the controller which device location to act on, and what actions to take
* *Basic file system*. Responsible for the following functionalities 
    * Need only to issue generic commands to the appropriate device driver to read and write physical blocks on the disk
        * *Identifying physical blocks*. Use block's numeric disk address, e.g. drive 1 - cylinder 73 - track 2 - sector 10
    * Manage the memory buffers and caches which hold various file-system, directory, and data blocks
        * *Buffer block*. Allocated before the transfor of a disk block can occur
            * *Full buffer*. When the buffer is full, the buffer manager must find more buffer memory or free up buffer space to allow a requested I/O to complete
        * *Caches*. Used to hold frequently used file-system metadata to improve performance

            $\to$ Managing their contents is critical for optimum system performance
* *File-organization module*. Know about files and their logical blocks, as well as physical blocks

    $\to$ The file-organization module thus can translate logical block addresses to physical block addresses for the basic file system to transfer
    * *Logical-physical block translation*.
        * *Logical block numbering*. Each file's logical blocks are numbered from $0$ or $1$ through $N$
        * *Block location*. Since the physical blocks containing the data usually do not match the logical numbers

            $\to$ A translation is needed to locate each block
    * *Free-space manager*. The file-organization module also includes the free-space manager, which 
        * Track unallocated blocks 
        * Provides unallocated blocks to the file-organization module when requested
* *Logic file system*. Manage metadata information and perform protection and security
    * *Metadata management*.
        * *Metadata*. Include all the file-system structure, except the actual data, i.e. contents of the files
        * *Functionality*. Manage the directory structure to provide the file-organization module with the information it needs, given a symbolic file name
        * *File-control blocks*. The logical file system maintains the file structure via file-control blocks
            * *File-control block (FCB)*. Contain information about the file, i.e. ownership, permissions, and location of the file contents
                * *Example*. `inode` in most UNIX file systems
    * *Protection and security*. The logical file system is responsible for protection and security

**Pros and cons of layered file systems**. 
* *Pros*. Duplication of code is minimized
    * *Explain*. The I/O control and sometimes the basic file-system code can be used by multiple file systems

        $\to$ Each file system can then have its own logical file-system and file-organization modules
* *Cons*. Introduce more OS overhead, which may result in decreased performance
    * *Consequence*. The use of layering, including the decision about how many layers to use, and what each layer should do, is a major challenge in designing new systems

## File-system implementation
### Overview
**On-disk and in-memory structures**. 
* *On-disk structures*. For data storage
* *In-memory structures*. For data access

**On-disk structures to implement a file system**. Contain information about how to boot an OS stored on the disk, the total number of blocks, the number and location of free blocks, the directory structure, and individual files
* *Brief description of on-disk structure components*.
    * *Boot-control block (one per volume)*. Contain information required by the system to boot an OS from that volume

        >**NOTE**. If the disk odes not contain an OS, this block can be empty

        * *Location*. Typically the first block of a volume
        * *Other names*. Boot block (in UFS), and partition boot sector (in NTFS)
    * *Volume-control block (one per volume)*. Contain volume, or partition, details
        * *Example*. The number of blocks in the partition, the size of the blocks, a free-block count and free-block pointers, and a free-FCB and FCB pointers
        * *Other names*. Superblock (in UFS), and master file table (in NTFS)
    * *Directory structure (one per file system)*. Used to organize the files
        * *Contents*.
            * *In UFS*. Include the file names, and associated inode numbers
            * *In NTFS*. Stored in the master file table
    * *Per-file FCB*. Contain details about the file
        * *Identifier number*. It has a unique identifier number to allow association with a directory entry
        
        >**NOTE**. In NTFS, this information is actually stored within the master file table, which uses a relational database structure, with a row per file

**In-memory structures to implement a file system**. Reflect and extend on-disk structures

$\to$ This is used for both file-system management and performance improvement via caching
* *Data operations*. The data are loaded at mount time, updated during file-system operations, and discarded at dismount
* *Types of structures included*.
    * *In-memory mount table*. Contain information about each mounted volume
    * *In-memory directory-structure cache*. Hold the directory information of recently accessed directories

        >**NOTE**. For directories, at which volumes are mounted, it can contain a pointer to the volume table
    
    * *System-wide open-file table*. Contain a copy of the FCB of each open file, as well as other information
    * *Per-process open-file table*. Contain a pointer to the appropriate entry in the system-wide open-file table, as well as other information
    * *I/O memory buffers*. Hold the file-system blocks when they are being read from disk, or written to disk

**File operations**.

<div style="text-align:center">
    <img src="/media/cfL7OWm.png">
    <figcaption>File open (a) and file read (b)</figcaption>
</div>

* *File creation procedure*. 
    1. An application program calls the logical file system
    2. The logical file system knows the format of the directory structures

        $\to$ To create a new file, it allocates a new FCB
    3. The system reads the appropriate directory into memory, update it with the new file name and FCB, and writes it back to the disk
* *File opening procedure*.
    1. An application call `open()` with a file name as argument to the logical file system
    2. The `open()` system call searches the system-wide open-file table to see if the file is already in use by another process
        * If the file is currently used, a per-process open-file table entry is created, pointing to the existing system-wide open-file table

            $\to$ This can save substantial overhead
        * If the file is not already open, the directory structure is searched for the given file name

            $\to$ Once the file is found, the FCB is copied into a system-wide open-file table in memory

            >**NOTE**. The table not only stores the FCB, but also tracks the number of processes having the file open

            >**NOTE**. Parts of the directory structure are usually cached in memory to speed directory operations

    3. An entry is made in the per-process open-file table, with a pointer to the entry in the system-wide open-file table and some other fields
        * *Fields included in the per-process open-file table along with a FCB*.
            * A pointer to the current location in the file, i.e. for the next `read()` and `write()` operations
            * The access mode, in which the file is open
    3. The `open()` call returns a pointer to the appropriate entry in the per-process open-file table

        $\to$ All file operations are then performed via this pointer

        >**NOTE**. The file name may not be part of the open-file table, since the system has no use for it once the appropriate FCB is located on disk

        >**NOTE**. The file pointer may be cached to save time on subsequent opens of the same file

* *File closing procedure*. 
    1. The per-process table entry is removed, and the system-wide entry's open count is decremented
    2. When all users that have opened the file close it, any updated metadata is copied back to the disk-based directory structure

        $\to$ The system-wide open-file table entry is then removed

**Caching of file-system structures**. Most systems keep all information about an open file, except for its actual data blocks, in memory

$\to$ Caching should be used to improve the performance of the file system

### Partitions and mounting
**Disk layout**. Can have many variations, depending on the OS
* *Option 1*. A disk can be sliced into multiple partitions
* *Option 2*. A volume can span multiple partitions on multiple disks

**Raw and cooked partition**.
* *Raw partition*. Contain no file system
    * *Usage*. 
        * When no file system is appropriate
            * *Example*. UNIX swap space, or databases
        * Hold information required by disk RAID, i.e. redundant arrays of inexpensive disks, systems, e.g. bit maps indicating which blocks are mirrored, and which have chagned and need to be mirrored
        * Contain a miniature database holding RAID configuration information, e.g. which disks are members of each RAID set
* *Cooked partition*. Contain a file system

**Boot partition**. Boot information can be stored in a separate partition

>**NOTE**. This partition has its own format, since at boot time the system does not have the file-system code loaded
>$\to$ The system cannot interpret the file-system format

* *Partition format*. Boot information is usually a sequential series of blocks, loaded as an image into memory
* *Execution of boot image*.
    1. The execution starts at a predefined location, e.g. the first byte
    2. The boot loader in turn knows enough about the file-system structure to be able to find and load the kernel and start it executing
        
        $\to$ It can contain more than the instructions for how to boot a specific OS
* *Dual boot*. PCs and other systems can be dual-booted
    * *Problem*. How does the system know which one to boot?
    * *Idea*. A boot loader which understands multiple file systems and multiple OSes can occupy the boot space

        $\to$ Once loaded, it can boot one of the OSes available on the disk
    * *Disk partitioning*. The disk can have multiple partitions, each containing a different type of file system and a different OS

**Root partition**. Contain the OS kernel and sometimes other system files
* *Mounting root partition*. Root partition is mounted at boot time
* *Automatically mounted volumes*. Some volumes can be automatically mounted at boot, or manually mounted later, depending on the OS
* *Procedure to verify valid file system on a device*.
    1. The OS asks the device driver to read the device directory and verifying that the directory has the expected format
    2. If the format is invalid, the partition must have its consistency checked and possibly corrected, either with or without user intervention
    3. The OS notes in its in-memory mount table that a file system is mounted, along with the type of the file system

**Mounting in UNIX**. File systems can be mounted at any directory
* *Implementation*. Mounting is implemented by setting a flag in the in-memory copy of the inode for the directory

    $\to$ The flag indicates that the directory is a mount point
* *Mount table entry*. Contain a pointer to the superblock of the file system on the device

    $\to$ The OS can traverse its directory structure, switching seamlessly among file systems of varying types

### Virtual file systems
**Problem**. Modern OSes must concurrently support multiple types of file systems

$\to$ How does an OS allow multiple types of file systems to be integrated into a directory structure
* *Suboptimal solution*. Write directory and file routines for each type
* *Improved solution*. Most OSes, including UNIX, use OOP techniques to simplify, organize, and modularize the implementation
    * *Pros*. Allow very dissimilar file-system types to be implemented withint the same structure, e.g. network file systems (NFS)

        $\to$ Users can access files conatined within multiple file systems on the local disk, or even on a remote file systems

<div style="text-align:center">
    <img src="/media/lratjNk.png">
    <figcaption>Schematic view of a VFS</figcaption>
</div>

**Implementation details isolation from basic system-call**. Data structures and procedures are used to isolate the basic system-call functionality from the implementation details

$\to$ The file-system implementation consists of three major layers
* *File-system interface*. The first layer, which is based on `open()`, `read()`, `write()`, and `close()` calls and on file descriptors
* *Virtual file system (VFS)*. The second layer
    * *Functions*. The VFS layer serves two important functions
        * The VFS layer separates file-system-generic operations from their implementation by defining a clean VFS interface
            * *Explain*. Several implementations for the VFS interface may coexist on the same machine, allowing transparent access to different types of file systems mounted locally
        * The VFS layer provides a mechanism for uniquely representing a file throughout a network
            * *Explain*. 
                * The VFS is based on a file-representation structure, called a `vnode`

                    $\to$ `vnode` contains a numerical designator for network-wide unique file, which is required for support of NFS
                * The kernel maintains one vnode structure for each active node, i.e. file or directory
            * *Consequences*. The VFS distinguishes local files from remote ones, and local files are further distinguished according to their file-system types
    * *Request handling*. 
        * *Local requests*. The VFS activates the file-system-specific operations to handle local request according to their file-system types
        * *Remote requests*. The OS then calls the NFS protocol procedures for remote requests
* *Implementation of file-system type or remote-file-system protocol*. The third layer of the architecture

# Directory implementation

# Appendix
## Concepts
**Implementation of directories**.
* *UNIX*. Treat a directory in exactly the same way as a file, i.e. one with a `type` field indicating that it is a directory
* *Windows*. Implement separate system calls for files and directories

    $\to$ Directories are treated as entities separate from files

**Naming for file pointer in popular OSes**.
* *UNIX*. File descriptor
* *Windows*. File handle

**File system as an interface to other system aspects**. Some system complicate the file system scheme further by using the file system as an interface to other system aspects, e.g. networking
* *In UFS*. The system-wide open-file table holds 
    * The inodes and other information for files and directories, and
    * Similar information for network conections and devices
* *Consequences*. One mechanism can be used for multiple purposes

**Superblock**. A unique data strucutre in a filesystem, which holds metadata about the file system, e.g. which inode is the top-level directory and the type of the file system use