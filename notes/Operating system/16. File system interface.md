---
title: 16. File system interface
tags: Operating system
---

<!-- TOC titleSize:1 tabSpaces:2 depthFrom:1 depthTo:6 withLinks:1 updateOnSave:1 orderedList:0 skip:0 title:1 charForUnorderedList:* -->
# Table of Contents
- [Table of Contents](#table-of-contents)
- [Storage management](#storage-management)
  - [File concept](#file-concept)
    - [File attributes](#file-attributes)
    - [File operations](#file-operations)
    - [File types](#file-types)
    - [File structure](#file-structure)
    - [Internal file structure](#internal-file-structure)
  - [Access methods](#access-methods)
    - [Sequential access](#sequential-access)
    - [Direct access](#direct-access)
    - [Other access methods](#other-access-methods)
  - [Directory and disk structure](#directory-and-disk-structure)
    - [Storage structure](#storage-structure)
    - [Directory overview](#directory-overview)
    - [Single-level directory](#single-level-directory)
    - [Two-level directory](#two-level-directory)
    - [Tree-structured directories](#tree-structured-directories)
    - [Acyclic-graph directories](#acyclic-graph-directories)
    - [General graph directory](#general-graph-directory)
  - [File-system mounting](#file-system-mounting)
  - [File sharing](#file-sharing)
    - [Multiple users](#multiple-users)
    - [Remote file systems](#remote-file-systems)
    - [Consistency semantics](#consistency-semantics)
  - [Protection](#protection)
    - [Types of access](#types-of-access)
    - [Access control](#access-control)
    - [Other protection approaches](#other-protection-approaches)
- [Appendix](#appendix)
  - [Concepts](#concepts)
<!-- /TOC -->

# Storage management
**File system**.
* *Usage*. Provide the mechanism for online storage of and access to both data and programs of the OS and all the users of the computer system
* *Structure*. Consist of two distinct parts
    * *A collection of files*. Each file stores related data
    * *A directory structure*. Organize the provide information about all the files in the system

## File concept
**Motivation**. Computers can store information on various storage media, e.g. magnetic disks, magnetic tapes, etc.

$\to$ For the computer system will be convenient to use, the OS provides a uniform logical view of information storage
* *Abstraction of physical storage*. The OS abstracts from the physical properties of its storage devices to define a logical storage unit, called a file

$\to$ Files are mapped by the OS onto physical devices

>**NOTE**. The storage devices are usually nonvalatile
>$\to$ The contents are persistent through power failures and system reboots

**File**. A named collection of related information, which is recorded on secondary storage
* *User's perspective*. A file is a smallest allotment of logical secondary storage
    * *Explain*. Data cannot be written to secondary storage unless they are within a file
* *File format*. Represent programs (both source and object forms) and data (numeric, alphabetic, alphanumeric, or binary)
* *File content*. Defined by its creator
* *File structure*. Depend on file structure
    * *Text file structure*. A sequence of characters organized into lines, and possibly pages
    * *Source file structure*. A sequence of subroutines and functions, each of which is further organized as declarations followed by executable statements
    * *Object file structure*. A sequence of bytes organized into blocks understandable by the system's linker
    * *Executable file structure*. A series of code sections, which the loader can bring into memory and execute

### File attributes
**File attributes**.
* *Name*. The symbolic file name is the only information kept in human-readable form
* *Identifier*. Usually a number, identify the file within the file system

    >**NOTE**. This may not be human-readable

* *Type*. Required for the systems that support different types of files
* *Location*. A pointer to a device, and to the location of the file on that device
* *Size*. The current size of the file and possibly the maximum allowed size
* *Protection*. Access-control information determines who can do reading, writing, executing, and so on
* *Time, date, and user identification*. Kept for creation, last modification, and last use

    $\to$ These data are useful for protection, security, and usage monitoring

**Directory structure**. Reside on secondary storage, keeping information about all files
* *Directory entries*. Consist of the file's name and its unique identifier

    $\to$ The identifier in turn locates the other file attributes

* *Storage*. Directories, like files, must be volatile

    $\to$ They must be stored on the device and brought into memory piecemeal as needed

### File operations
**File as an abstract data type**. A file is an abstract data type

$\to$ To define a file properly, we need to consider the operations which can be performed on files
* *OS operations on files*. Create, write, read, reposition, delete, and truncate

**Basic operations on files and procedures**.
* *Creating a file*. To create a file,
    1. Space in the file system must be found for the file
    2. An entry for the new file must be made in the directory
* *Writing a file*. To write a file,
    1. Make a system call specifying both the file name and the content to be written to the file
    2. The system searches the directory to find the file's location
    3. The system keep a writer pointer to the location in the file, where the next write is to take place
    4. The writer pointer must be updated whenever a write occurs
* *Reading a file*. To read a file,
    1. Use a system call specifying the file name and where (in memory) the next block of the file should be put
    2. The directory is searched for the associated entry
    3. The system needs to keep a read pointer to the location in the file, where the next read is to take place
    4. Once the read has taken place, the read pointer is updated
* *Repositioning (seeking) within a file*.
    1. The directory is searched for the appropriate entry
    2. The current-file-position is repositioned to a given value

    >**NOTE**. Repositioning within a file need not involve any actual I/O

* *Deleting a file*.
    1. Search the directory for the named file
    2. Release all file space, so that it can be used by other files

        $\to$ This is done by marking the released space as `free`
    3. Erase the directory entry
* *Truncating a file*. Erase the contents of a file but keep its attributes

**Per-process current file-position pointer**. A process is usually either reading from or writing to a file

$\to$ The current operation location can be kept as per-process *current file-position pointer*

>**NOTE**. Both the read and write operations use this same pointer, saving space and reducing system complexity

**Other common operations**.
* Appending new informtion to the end of an existing file
* Renaming an existing file

**`open()` system call**. Most of the file operations mentioned involve searching the directory for the entry associated with the named file

$\to$ We need to avoid this constant searching
* *Solution*. Make an `open()` system call before a file is first used actively
* *Implementation*.
    * The OS keeps a small table, called the open-file table, containing information about all open files
    * When a file operation is requested

        $\to$ The file is specified via an index into this table, thus no seraching is required
    * When the file is no longer being actively used

        $\to$ It is closed by the proceess, and the OS removes it entry from the open-file table
* *Opening and closing mechanism*.
    * *Implicit mechanism*.
        * A file is implicitly opened when the first reference to it is made
        * The file is automatically closed when the job or program that opened the file terminates
    * *Explicit mechanism*.
        * *`open()` system call*. Takes a file name and searches the directory, copying the directory entry into the open-file table
            * *Opening mode*. `open()` can also access-mode information, i.e. create, read-only, read-write, append-only, etc.

                $\to$ This mode is checked against the file's permissions
            * *Return type*. A pointer to the entry in the open-file table
                * *Usage*. Used in all I/O operations, avoiding any further searching and simplifying the system-call interface
* *Simultaneous opening and closing*.
    * *Idea*. The OS uses two levels of internal tables
        * Per-process table
        * System-wide table
    * *Per-process table*. Track all files opened by a process
        * *Content*. Information regarding the use of the file by the process
            * *Example*.
                * The current file pointer for which file is found
                * Access rights to the file and accounting information
        * *Table entry*. Point to a system-wide open-file table
    * *System-wide open-file table*. Contain process-independent information, e.g. file location on disk, access dates, file size, etc.
        * *Execution*.
            * Once a file has been opened by a process, the system-wide table includes an entry for the file
            * When another process opens the file, a new entry is added to the process's open-file table, pointing to the appropriate entry in the system-wide table
        * *Open count*. Associated with each file to indicate how many processes have the file open

            $\to$ `close()` decreases this open count, and when the count reachers zero, the file is no longer in use, and its entry is removed from the open-file table

**Information associated with an open file**.
* File pointer
* File-open count
* Disk location of the file
* Access rights
* File locks (optional)

### File types
**File type implementation**. Include the type as part of the file name
* *File name structure*. `{filename}<period-character>{extension}`
* *Consequence*. The OS and the user can tell from the name alone what type of a file is

**Common file types**.
* *Executable*. Ready-to-run machine language program
* *Object*. Compiled, machine language, not linked
* *Source code*. Source code in various languages
* *Batch*. Commands to the command interpreter
* *Text*. Textual data, documents, etc.
* *Word processor*. Various word-processor formats
* *Library*. Libraries of routines for programmers
* *Print or view*. ASCII or binary file in a format for printing or viewing
* *Archive*. Related files grouped into one file, sometimes compressed, for archiving or storage
* *Multimedia*. Binary file containing audio or A/V information

### File structure
**Motivation**. Certain files must conform to a required structure, which is understood by the OS
* *Naive idea*. File types can be used to indicate the internal structure of the file

    $\to$ Some OSes extend this idea into a set of system-supported file structures, with sets of special operations for manipulating files with those structures
* *Drawbacks of having the OS support multiple file structures*. The resulting size of the OS is cumbersome
    * *Explain*.
        * The OS needs to contain the code to support its supported file structures
        * It may be necessary to define every file as one of the file types supported by the OS

            $\to$ When new applications require unsupported types, severe problems may result
* *Potential solution*. Some OS impose and support a minimal number of file structures

    $\to$ Each application program must include its own code to interpret an input file as to the appropriate structure
    * *Applications*. UNIX, MS-DOS, etc.
    * *Benefits*. Provide maximum flexibility but little support

>**NOTE**. All OS must support at least one struct, i.e. an executable file, so that the system is able to load and run programs

>**NOTE**. It is useful for an OS to support structures which will be used frequently and will save the programmer substantial effort

### Internal file structure
**Motivation**. Locating an offset within a file can be complicated for the OS
* *Explain*.
    * Disk systems typically have a well-defined block size determined by the size of a sector

        $\to$ All disk I/O is performed in units of one block (physical record), and all blocks are the same size
    * It is unlikely that the physical record size will exactly match the length of the desired logical record
    * Logical records may even vary in length
* *Common solution*. Pack a number of logical records into physical blocks

**UNIX internal file structure**.  All files are defined as streams of bytes

$\to$ Each byte is individually addressable by its offset, from the beginning (or end) of the file
* *Logical record size*. 1 byte
* *Physical record size*. The file system automatically packs and unpacks bytes into physical disk blocks, e.g. 512 bytes per block, as necessary

## Access methods
**Problem**. Choosing the right one for a particular application is a major design problem

### Sequential access
**Sequential access**. The simplest access method
* *Idea*. Information in file is processed in order, one record after the other

    >**NOTE**. This mode of access is by far the most common

**Read and write operations**.
* *Read next*. Read the next position of the file, and automatically advances a file pointer tracking the I/O location
* *Write next*. Append to the end of the file, and advances to the end of the newly written material, i.e. the new end of file

### Direct access
**Direct access (relative access)**. A file is made up of fixed-length logical records allowing programs to read and write records rapidly in no particular order

$\to$ Direct-access method is based on a disk model of a file, since disks allow random access to any file block
* *Benefits*. Great use for immediate access to large amounts of information
* *Applications*. Database

**Implementation**. The file operations must be modified to include the block number as a parameter

### Other access methods
**Other access methods on top of direct-access method**. Involve the construction of an index for a file
* *Index*. Contain pointers to the various blocks
* *Finding a record in a file*.
    1. Search the index
    2. Use the pointer to access the file directly
    3. Find the desired record
* *Indexing large files*. Use index for the index file

## Directory and disk structure
**Problem**. How to store files
* *Idea*. Store on random-access storage devices, including hard disks, optical disks, and solid state (memory-based) disks

**Storage device partitioning**.
* A storage device can be used in its entirety for a file system, it can also be subdivided for finer-grained control
    * *Example*. A disk can be partitioned into quarters, each of which can hold a file system
* Storage devices can also be collected together into RAID sets, which provide protection from the failure of a single disk

**Use cases of disk partitioning**.
* Limit the sizes of individual file systems
* Put multiple file-system types on the same device
* Leave part of the device available for other uses, e.g. swap space or unformatted (raw) disk space

>**NOTE**. Partitions are also known as slices or, in the IBM world, minidisks

**Volume**. Any entity containing a file system
* *Physical format*. A volume can be a subset of a device, a whole device, or multiple devices linked together into a RAID set
* *Logical format*. Each volume can be thought of as a virtual disk

>**NOTE**. Volumes can also store multiple OSes, allowing a system to boot and run more than one OS

* *Volume and file system*. Each volume containing a file system must also contain information about the files in the system
    * *Device directory (or volume table of contents, or simply directory)*. The place where information about files is kept

    <div style="text-align:center">
        <img src="/media/NLRAwKW.png">
        <figcaption>A typical file-system organization</figcaption>
    </div>

    * *Information kept in device directory*. File name, location, size, and type, for all files on the volume

### Storage structure
**Speical-purpose file systems in Solaris**.

<div style="text-align:center">
    <img src="/media/NCtSXUF.png">
    <figcaption>Solaris file system</figcaption>
</div>

* *`tmpfs`*. A temporary file system created in volatile main memory, and has its contents erased if the system reboots or crashes
* *`objfs`*. A virtual file system, i.e. essentially an interface to the kernel that looks like a file system, giving debuggers access to kernel symbols
* *`ctfs`*. A virtual file system maintaining contact information to manage which processes start when the system boots, and must continue to run during operation
* *`lofs`*. A loop-back file system allowing one file system to be accessed in place of another
* *`procfs`*. A virtual file system presenting information on all processes as a file system
* *`ufs, zfs`*. General-purpose file systems

**File groups**. Even within a file system, it is useful to segregate files into groups and manage and act on those groups

$\to$ This organization involves the use of directories

### Directory overview
**Directory**. A symbol table translating file names into their directory entries

**Operations on a directory**.
* Search for a file
* Create a file
* Delete a file
* List a directory
* Rename a file
* Traverse the file system

### Single-level directory
**Single-level directory**. All files are contained in the same directory, which is easy to support and understand
* *Drawbacks*.
    * When the number of files increases, or when the system has more than one user

        $\to$ The files must have unique names since they are in the same directory
    * Even a single user on a single-level directory may find it difficult to remember the names of all files as the number of files increases
* *Consequence*. It is not uncommon for a user to have hundreds of files on one computer system, and an equal number of additional files on another system

    $\to$ Keeping track of so many files is a daunting task

### Two-level directory
**Solving confusion of file names**. Create a separate directory for each user
* *Idea*.
    * Each user has his own user file directory (UDF)

        $\to$ The UFDs have similar structures, but each lists only the files of a single user
    * When a user job starts, or a user logs in, the system's master file directory (MFD) is searched
* *Master file directory*. Indexed by user name or account number, and each entry points to the UFD for that user

**File system mechanism**.
* *File access*. When a user refers to a particular file, only his own UFD is searched

    $\to$ Different users may have files with the same name, as long as all files within each UFD are unique
* *File creation*. When a user creates a file, the OS searches only that user's UFD to ascertain whether another file of that name exists
* *File deletion*. To delete a file, the OS confines its search to the local UFD

    $\to$ It cannot accidentally delete another user's file of the same name

**Creation and deletion of user directories**. User directories must be created and deleted as necessary
* *Idea*. A special system program is run with the appropriate user name and account information
* *User directory creation*. The special program creates a new UFD and adds an entry for it to the MFD

    >**NOTE**. The execution of this program might be restricted to system administrators

**Drawbacks**.
* Two-level directory isolates one user from another
    * This is advantage when the users are completely independent
    * This is disadvantage when the users want to cooperate on some task, and to access one another's files

### Tree-structured directories
**Idea**. Extend the directory structure to a tree of arbitrary height
* *Benefits*.
    * Users can create their own subdirectories
    * Users can organize their files accordingly
* *Consequence*. Tree is the most common directory structure

**Tree structure**. Have a root directory, and every file in the system has a unique path name

**Directory**. Contain a set of files or subdirectories
* *Directory as a file*. A directory is simply a file treated in a special way

    $\to$ There is one bit in each directory entry defining the entry as a file, i.e. 0, or a subdirectory, i.e. 1

    >**NOTE**. All directories have the same internal format

**Current directory**. Each process has a current directory

$\to$ This directory contain most of the files which are of current interest to the process
* *File references*. When reference is made to a file
    1. The current directory is searched
    2. If a file is needed which is not in the current directory

        $\to$ The user usually must either specify a path name, or change the current directory to the one holding the file

    >**NOTE**. The search path may or may not contain a special entry standing for "the current directory"

* *Initial current directory of the login shell of a user*. Designated when the user job starts or the user logs in
    * *Current directory initialization*.
        1. The OS searches the accounting file, or some other predefined location, to find an entry for this user (for accounting pruposes)

            $\to$ In the accounting file is a pointer to, or the name of, the user's initial directory
        2. The pointer is copied to a local variable for this user, which specifies the user's initial current directory
        3. From that shell, other processes can be spawned

            $\to$ The current directory of any subprocess is usually the current directory of the parent, when it was spawned

**Absolute and relative path names**.
* *Absolute path*. Begin at the root and follow a path down to a specified file, giving the directory names in the path
* *Relative path*. A path from the current directory

**Directory deletion**.
* *Empty directory deletion*. Directory's entry in the directory containing it can simply be deleted
* *Non-empty directory deletion*.
    * *Approach 1*. A directory will not be deleted unless it is empty

        $\to$ To delete a directory, the user must first delete all files in the directory
        * *Drawback*. Substantial amount of work
    * *Approach 2*. Provide an option to `rm` command

        $\to$ When a request is made to delete a directory, all that directory's files and subdirectories are also to be deleted
        * *Drawback*. Dangerous, i.e. an entire directory can be removed with one command

            $\to$ If the command is issued in error, a large number of files and directories will need to be restored

**Directory access**., Users can be allowed to access, in addition to their files, the files of other users

**Path searching**. A path to a file in a tree-structured directory can be longer than a path in a two-level directory

$\to$ OSes automates the search for executable programs
* *Implementation*. Maintain a file, called *the Desktop file*, containing metadata code and the name and location of all executable programs it has seen

### Acyclic-graph directories
**Problem**.
* *Problem*.
    * Two programmers working on a joint project, whose files stored in a subdirectory, separating them from other projects and files of the two programmers
    * Both programmers want the subdirectory to be in their own directories
* *Solution*. Use shared directory (or file)
    * *Shared directory (or file)*. Exist in the file system in two (or more) places at once
* *Drawback of tree structure*. Prohibit the sharing of files or directories

**Acyclic graph directory**. Directory graph with no cycles
* *Benefits*. Allow directories to share subdirectories and files

    $\to$ The same file or subdirectory may be in two different directories
* *Shared file and copied file*.
    * *Copied files*. With two copies, each programmer can view the copy rather than the original

        $\to$ If one changes the file, the changes will not appear in the other's copy
    * *Shared file*. Only one actual file exists

        $\to$ Any changes made by one person are immediately visible to the other

**File sharing practice**. When people are working as a team, all the files they want to share can be put into one directory

$\to$ The UFD of each team member will contain this directory of shared files as a subdirectory

**Implementation of shared file**.
* *UNIX's implementation*. Create a new directory entry called a link
    * *Link*. Effectively a pointer to another file or subdirectory

        >**NOTE**. A link may be implemented as an absolute or a relative path name

    * *Link access*.
        1. When a reference to a file is made

            $\to$ We search the directory
        2. If the directory entry is marked as a link

            $\to$ The name of the real file is included in the link information
        3. We resolve the link using the real path name to locate the real file
    * *Link identification*. Identified by their format in the directory entry, or by having a special type on a systems that support types

        $\to$ Links are indirect pointers
    * *Directory traversion*. The OS ignores links when traversing directory trees to preserve the acyclic structure of the system
* *Duplication approach*. Duplicate all information about shared files in both sharing directories

    $\to$ Both entries are identical and equal
    * *Drawback*. We have to maintain consistency between duplications when a file is modified

**Considerations with acyclic graph**. Acyclic-graph directory structure is more complex than tree structure
* A file now have multiple absolute path names

    $\to$ Distinct file names may refer to the same file, i.e. aliasing
    * *Consequence*. If we are trying to traverse the entire file system, this problem becomes significant
        * *Explain*. We do not want to traverse shared structures more than once
* It is more complicated to delete a file
    * *Option 1*. Remove the file whenever anyone deletes it
        * *Drawback*. Dangling pointers may be left to now-nonexistent file
        * *Solution*. Search for these links and remove them as well

            $\to$ Unless a list of the associated links is kept with each file, this search can be expensive
    * *Option 2*. Leave the links until an attempt is made to use them

        $\to$ At that time, we can determine that the file of the name given by the link does not exist and can fail to resolve the link name

        >**NOTE**. This is more preferred than option 1

    * *Option 3*. Preserve thje file until all references to it are deleted
        * *Implementation*. Have some mechanism for determining the last reference to the file has been deleted
        * *Drawback*. The variable and potentially large size of file-reference list
            * *Solution*. Keep only a count of the number of references

            >**NOTE**. The UNIX OS uses this approach for nonsymbolic links (or hard links)

### General graph directory
**Revisit acyclic graph directory**.
* *Pros*. It is relatively simple to traverse the graph and to determine when there are no more references to a file
* *Cons*. It is hard to ensure that there are no cycles

**Problem with cyclic graph directory**.
* *Directory traversion*. We want to avoid searching any component twice
    * *Solution*. Limit arbitrary the number of directories that will be accessed during a search
* *Directory deletion ability*. When cycles exist, the reference count (as in acyclic graph directory) may not be 0 even when it is no longer possible to refer to a directory or file
    * *Solution*. Use a garbage-collection scheme to determine when the last reference has been deleted and the disk space can be reallocated
    * *Garbage-collection mechanism*.
        1. Traverse the entire file system, marking everything which can be accessed
        2. Traverse the file system again, collecting everything not marked onto a list of freespace
    * *Drawback*. Time-consuming

## File-system mounting
**Mounting**. A file system must be mounted before it can be available to processes on the system

>**NOTE**. The directory structure may be built out of multiple volumes, which must be mounted to make them available within the file-system name space

**Mounting procedure**.
1. The OS is given the name of the device, and the mount point
   * *Mount point*. The location within the file structure, where the file system is to be attached

       >**NOTE**. A mount point is typically an empty directory

   * *File system type*.
       * Some OSes require that a file system type be provided
       * Others inspect the structures of the device and determine the type of file system
   * *Example*. On a UNIX system, a file system containing a user's home directories might be mounted as `/home`
2. The OS rverifies that the device contains a valid file system
   * *Explain*. It asks the device driver to read the device directory and verifies that the directory has the expected format
3. The OS notes in its directory structure that the file system is mounted at the specified mount point

**Advantage**. The OS can traverse its directory structure, switching among file systems, and even file systems of varying types, as appropriate

## File sharing
### Multiple users
**Problem**. When an OS accommodates multiple users, given a directory structure allowing files to be shared by users

$\to$ The system must mediate the file sharing
* *Idea*. The system can either allow a user to access the files of other users by default, or require that a user specifically grant access to the files

**Requirements**. To implement sharing and protection, the system must maintain more file and directory attributes than required on a single-user system
* *Most common additional attributes*. File (or directory) owner (or user) and group
    * *File owner*. The user who can change attributes and grant access, and who has the most control over the file
    * *Group*. A subset of users who can share access to the files

        >**NOTE**. Which operations can be executed by group members and other users is definable by the file's owner

**File access mechanism**. When a user requests an operation on a file,
1. The user ID can be compared with the owner attribute to determine if the requesting user is the owner of the file
2. The group IDs can compared likewise
3. The result indicates which permissions are applicable
4. The system then applies the permissions to the requested operation and allows or denies it

**Local file systems**. Include volumes of a single disk, or multiple volumes on multiple attached disks
* *Access checking*. The ID checking and permission matching are straightforward, once the file systems are mounted

### Remote file systems
**Remote file transfer and access methods**.
* *Manually transferring files between machines*. The first implemented method for remote file transfer
    * *Example*. `ftp`
* *Distributed file system (DFS)*. Remote directories are visible from a local machine
* *World wide web*. A reversion to the first, i.e. a browser is needed to gain access to the remote files, and separate operations, i.e. essentially a wrapper for `ftp`, are used to transfer files

**`ftp`**. Used for both anonymous and authenticated access
* *Anonymous access*. Allow a user to transfer files without having an account on the remote system
    * *Anonymous access in world wide web*. WWW uses anonymous file exchange almost exclusively
    * *Anonymous access in DFS*. DFS involves a much tighter integration between the machine accessing the remote files and the machine providing the files

        $\to$ This integration adds complexity

**Client-server model**.
* *Client and server*. Remote file systems allow a computer to mount one or more file systems from one or more remote machines
    * *Server*. The machine containing the files
    * *Client*. The machine seeking access to the files
* *Idea*.
    * The server declares that a resource is available to clients and specifies exactly which resource, i.e. files, and exactly which clients
    * A server can serve multiple clients, and a client can use multiple servers, depending on implementation details of the system
* *File identification*. The server usually specifies the available files on a volume or directory level
* *Client identification*.
    * *Option 1*. Use a network name or other identifier, e.g. IP address
        * *Drawbacks*. These attributes can be spoofed, or imitated

            $\to$ Unauthorized client could be allowed access to the server
    * *Option 2*. Include secure authentication of the client via encrypted keys
        * *Drawbacks*. With security come many challenges, e.g.
            * Ensuring compability of the client and server, i.e. they must use the same encryption algorithms
            * Security of key exchanges, i.e. intercepted keys could again allow unauthorized access
    * *Consequence*. Due to the difficulties of solving option 2's problems, option 1, i.e. unsecure authentication methods, are most commonly used
* *File transferring*. Once the remote file system is mounted

    $\to$ File operation requests are sent on behalf of user across the network to the server via DFS protocol
    * *Typical mechanism*.
        1. A file operation request is sent along with the ID of the requesting user
        2. The server applies the standard access checks to determine if the user has credentials to access the file in the mode requested
        3. The request is either allowed or denied
        4. If allowed, a file handle is returned to the client aplication

            $\to$ The client application can perform desired operations on the file
        5. The client closes the file when access is completed

**Distributed information system (or distributed naming system)**. Provide unified access to the information required for remote computing

$\to$ This makes client-server systems easier to manage
* *Distributed naming service*. A distinct service used by client processes to obtain attributes such as addresses of resources, or objects with their given names
    * *Examples*. DNS
* *Domain name system (DNS)*. Provide host-name-to-network-address translations for the entire Internet, including the WWW
    * *Motivation*. Before DNS, file containing the same information were sent via e-amil or `ftp` between all networked hosts

        $\to$ This methodology was not scalable
* *Network information service (NIS)*. Provide user name, password, user ID, and group ID space for a distributed facility
    * *Idea*. Centralize storage of user names, host names, printer information, and the like
    * *Drawbacks*. NIS uses unsecure authentication methods, including sending user passwords unencrypted, and identifying hosts by IP address
    * *Improvement*. NIS+, i.e. a much more secure replacement for NIS, but is also much more complicated and has not been widely adopted
* *Common Internet file system (CIFS)*. Network information is used in conjunction with user authentication to create a network login used by the server to decide whether to allow or deny access to a requested file system
    * *Valid authentication criteria*. The user names must match from machine to machine, as with NFS
    * *Distributed naming structure by CIFS*. Used to provide a single name space fo rusers
        * *Older naming technology*. Domains
        * *Newer naming technology*. Active directory
* *Lightweight directory-access protocol (LDAP)*. A trending secure distributed naming mechanism

**Failure modes**.
* *Failure modes in local and remote file systems*.
    * *Local file systems*. Local file systems can fail for many reasons

        $\to$ Many of the failures will cause a host to crash and an error condition to be displayed, and human intervention will be required to repare the damage
    * *Remote file systems*. Even have more failure modes than local file systems' failure modes
        * *Explain*. Due to the complexity of network systems, and the required interactions between remote machines

            $\to$ Many more problems can interfere with the proper operation of remote file systems
        * *Consequences*. The network can be interrupted between two hosts
        * *Roots of failures*. Hardware failure, poor hardware configuration, or networking implementation issues
* *Handling remote file system failures*. Most DFS protocols either enforce or allow delaying of file-system operations to remote hosts, with the hope that the remote host will become avaliable again
    * *Recorvery from failure*. To implementation recovery, some kind of state information may be maintained on both the client and the server

        $\to$ Clients and servers can seamlessly recover from failure

### Consistency semantics
**Consistency semantics**. An important crierion for evaluating any file system which supports file sharing
* *Purpose*. Specify how multiple users of a system are to access a shared simultaneously
    * *Explain*. Specify when modifications of data by one user will be observable by other users

**UNIX semantics**. A file is associated with a single physical image, which is accessed as an exclusive resource

$\to$ Contention for this single image causes delays in user processes
* Writes to an open file by a user are visible immediately to other users who have this file open
* One mode of sharing allows users to share the pointer of current location into the file

    $\to$ The advancing of the pointer by one user affects all sharing users

    >**NOTE**. Here, a file has a single image which interleaves all accesses, regardless of their origin

**Session semantics**. A file may be associated with several, possibly different, images at the same time

$\to$ Multiple users are allowed to perform both read an write accesses concurrently on their images of the file, without delay
* Writes to an open file by a user are not visible immediately to other users opening the same file
* Once a file is closed, the changes made to it are visible only in sessions starting later

    $\to$ Already open instances of the file do not reflect these changes

**Immutable-shared-files semantics**. Once a file is declared as shared by its creator, it cannot be modified
* *Key properties of an immutable file*.
    * File name may not be reused
    * File contents may not be altered

## Protection
**Aspects of file system protection**.
* *Reliability*. We want to keep the information from physical damage
    * *Causes*. Hardware problems, power surges or failures, head crashes, dirt, etc.
    * *Idea*. Use duplicate copies of files
* *Protection*. We want to keep the information from improper access
    * *Idea*.
        * *Small single-user system*. Provide protection by physically removing the floppy disks and locking them in a desk drawer or file cabinet
        * *Multiuser system*. Other mechanisms are needed

### Types of access
**Controlled access**. The need to protect files is a direct result of the ability to access files
* *Idea*. Limit the types of file access which can be made

**File access**. A factor affecting the access of a file
* *File access types*. Read, write, execute, append, delete, list (liust the name and attributes of the file)

### Access control
**Most common approach**. Make access dependent on the identity of the user

$\to$ Different users may need different types of access to a file or directory
* *Idea*. Associate with each file and directory an access-control list (ACL)
    * *Access-control list (ACL)*. Specify user names and the types of access allowed for each user
* *Mechanism*.
    1. A user requests access to a particular file
    2. The OS checks the access list associated with the file
    3. If the user is listed for the requested access, the access is allowed

        $\to$ Otherwise, a protection violation occurs, and the user job is denied access to the file
* *Pros and cons*.
    * *Pros*. Enable complex access methodologies
    * *Cons*. The access lists' lengths may be large

**Consequences of the most comment approach**.
* *Consequences*.
    * Constructing a list may be tedious and unrewarding task, especially if we do not know in advance the list of users in the system
    * The directory entry, previously of fixed size, now must be of variable size, resulting in more complicated space management
* *Solution*. Use a condensed version of access list
    * *Idea*. Recognize three classifications of users in connection with each file, i.e.
        * *Owner*. The user who created the file
        * *Group*. A set of users who sharing the file and need similar access
        * *Universe*. All other users in the system
    * *Implementation*. Combine access-control lists with the more general owner, group, and universe access-control scheme described above

### Other protection approaches
**Password-based protection**. Associate a password with each file

**Directory protection**. Sometimes we need to protect directories

# Appendix
## Concepts
**File locking in Java**.
* *Locking file in Java*.
    1. Obtain the `FileChannel` for the file to be locked
    2. `lock()` method of `FileChannel` is used to acquire the lock
* *Methods*.
    * *API of `lock()` method*.

        ```java
        // begin: The begining position of the region being locked
        // end: The ending position of the region being locked
        // shared: True for shared locks, otherwise exclusive lock
        FileLock lock(long begin, long end, boolean shared)
        ```

    * *Releasing locked file*. Invoke `release()` of the `FileLock` returned by `lock()`
* *Shared and exclusive locks*.
    * *Shared lock*. Akin to a reader lock, in which several processes can acquire the lock concurrently
    * *Exclusive lock*. Akin to a writer lock, where only one process at a time can acquire the lock

    >**NOTE**. Not all OSes provide both types of locks, some only provide exclusive file locking

* *Locking mechanisms*.
    * *Mandatory locking*. Once a process acquires an exclusive lock

        $\to$ The OS will prevent any other process from accessing the locked file
    * *Advisory locking*. The OS will not prevent other processes from accessing the locked file

>**NOTE**. The use of file locks requires the same precautions as ordinary process synchronization

>**NOTE**. Some measures must be taken to ensure that two or more processes do not become involved in a deadlock, while trying to acquire file locks

**Autocompilation**. If the user tries to execute an object program, whose source file has been edited since th eobject file was produced

$\to$ The source file will be recompiled automatically

**Mac OS X file types**. Each file has
* *Type*. `TEXT` (text) or `APPL` (application)
* *Creator*. The name of the program creating it

**Magic number in UNIX**. Stored at the beginning of some files to indicate roughly the type of the file

**Macintosh OS file structures**. Support a minimal number of file structures
* *Idea*. A file contains two parts
    * *Resource fork*. Contain information of interest to the user
        * *Example*. Labels of any buttons displayed by the program
    * *Data fork*. Contain program code or data, i.e. the traditional file contents

**UNIX and its network file system (NFS)**. Authentication takes place via the client networking information, by default
* *Explain*. THe user's IDs on the client and server must match

    $\to$ Otherwise, the server will be unable to determine access rights to files

    >**NOTE**. The server must trust the client to present the correct user ID

>**NOTE**. NFS protocols allow many-to-many relationships

**File session**. A series of accesses between `open()` and `close()` operations on a fil