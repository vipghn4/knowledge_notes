<!-- TOC titleSize:1 tabSpaces:2 depthFrom:1 depthTo:6 withLinks:1 updateOnSave:1 orderedList:0 skip:0 title:1 charForUnorderedList:* -->
# Table of Contents
- [Table of Contents](#table-of-contents)
- [Context-free grammars](#context-free-grammars)
  - [Formal definition of a context-free grammar](#formal-definition-of-a-context-free-grammar)
  - [Designing context-free grammars](#designing-context-free-grammars)
  - [Ambiguity](#ambiguity)
  - [Chomsky normal form](#chomsky-normal-form)
<!-- /TOC -->

# Context-free grammars
**Context-free grammars**. A powerful method of describing languages, i.e. they can describe certain features with a recursive structure
* *Motivation*. CFGs were first used in the study of human languages, as a way of understanding the relationship of terms, e.g. noun, verb, and preposition
    
    $\to$ Their respective phrases leads to natural recursion, since noun phrases may appear inside verb phrases and vice versa
    * *Explain*. CFGs can capture important aspects of these relationships
* *Usage*. CFGs are applied in th specification and compilation of programming languages
    * *Programming language grammar*. Appear as a reference for people trying to learn the language syntax

        $\to$ Designers of compilers and interpreters for programming languages often start by obtaining a grammar for the language
    * *Parser*. A component in most compilers and interpreter, which extracts the meaning of a program prior to generating the compiled code or performing the interpreted execution

**Context-free languages**. The collection of languages associated with CFGs, i.e. they include all regular languages and many additional languages
* *Pushdown automata*. A class of machines recognizing the CFLs, hence allows us to gain insight into the power of CFGs

**Grammar**. Consist of a collection of substitution rules, i.e. productions
* *Substitution rules*. Each rule appears as a line in the grammar, comprising a symbol and a string separated by an arrow
    * *Variable*. The symbol in the rule, which are often represented by capital letters
    * *Terminals*. The string consist of variables and other symbols, which are analogous to the input alphabet, and often represented by lowercase letters, numbers, or special symbols
    * *Start variable*. One variable is designated as the start variable, which usuall occurs on the left-hand side of the topmost rule
* *Example*. Consider a CFG $G$
    
    $$\begin{aligned}A&\to 0A1\\ A&\to B\\B&\to \#\end{aligned}$$

    >**NOTE**. We can use abbreviate $A\to 0A1$ and $A\to B$ as $A\to 0A1 | B$

* *Language description by grammar*. A grammar can be used to describe a language by generating each string of the language in the following manner
    1. Write the start variable
    2. Find a variable, which is written down, and a rule, which starts with the variable
    3. Replace the written down variable with the right-hand side of the rule
    4. Repeat step 2 until no variables remain
* *Derivation*. The sequence of substitutions to obtain a string from a grammar
    * *Parse tree*. An ordered rooted tree representing the syntactic structure of a string according to some context-free grammar
* *Language of a grammar*. The collection $L(G)$ of all strings generated by derivation from a grammar $G$
    * *Context-free language*. Any language, which can be generated by some CFG

**CFG for English**.

$$\begin{aligned}
\langle\text{SENTENCE}\rangle &\to \langle\text{NOUN-PHRASE}\rangle \langle\text{VERB-PHRASE}\rangle\\
\langle\text{NOUN-PHRASE}\rangle &\to \langle\text{CMPLX-NOUN}\rangle | \langle\text{CMPLX-NOUN}\rangle \langle\text{PREP-PHRASE}\rangle\\
\langle\text{VERB-PHRASE}\rangle &\to \langle\text{CMPLX-VERB}\rangle | \langle\text{CMPLX-VERB}\rangle \langle\text{PREP-PHRASE}\rangle\\
\langle\text{PREP-PHRASE}\rangle &\to \langle\text{PRERP}\rangle \langle\text{CMPLX-NOUN}\rangle\\
\langle\text{CMPLX-NOUN}\rangle &\to \langle\text{ARTICLE}\rangle \langle\text{NOUN}\rangle\\
\langle\text{CMPLX-VERB}\rangle &\to \langle\text{VERB}\rangle | \langle\text{VERB}\rangle \langle\text{NOUN-PHRASE}\rangle\\
\langle\text{ARTICLE}\rangle &\to \text{a} | \text{the}\\
\langle\text{NOUN}\rangle &\to \text{boy} | \text{girl} | \text{flower}\\
\langle\text{VERB}\rangle &\to \text{touches} | \text{likes} | \text{sees}\\
\langle\text{PREP}\rangle &\to \text{with}\\
\end{aligned}$$

## Formal definition of a context-free grammar
**Formal definition of a context-free grammar**. A 4-tuple $(V,\Sigma,R,S)$ where
* $V$ is a finite set of variables
* $\Sigma$ is a finite set of terminals, which is disjoint from $V$
* $R$ is a finite set of rules, each of which is a variable and a string of variables and terminals
* $S\in V$ is the start variable

**Yielding and derivation**.
* *Assumptions*.
    * $u,v,w$ are strings of variables and terminals
    * $A\to w$ is a rule of the grammar
* *Conclusion*.
    * $uAv$ yields $uwv$, i.e. $uAv\implies uwv$
    * $u$ derives $v$, i.e. $u\overset{*}{\implies} v$, if $u=v$, or if a sequence $u_1,\dots,u_k$ exists for $k\geq 0$ and

        $$u\implies u_1\implies\dots\implies u_k\implies v$$

**Language of the grammar**. $\{w\in\Sigma^*:S\overset{*}{\implies} w\}$

**Compiler and programming languages**. A compiler translates code written in a programming language into another form, usually one more suiable for execution

$\to$ To do this, the compiler extracts the meaning of the code to be compiled in the parsing process
* *Idea*. Use the parse tree for the code, in the CFG for the programming language

## Designing context-free grammars
**Brief**. The deigdeso CFGs requires creativity, and they are even trickier to construct than finite automata
* *Explain*. We are more accustomed to programming a machine for specific tasks, than we are to describing languages with grammars

**CFLs as the union of simpler CFLs**. If we must construct a CFG for a CFL, then we can break into simpler pieces, then construct individual grammars for each piece

$\to$ Solving several simpler problems is easier than solving a complex one
* *Combining CFGs into a CFG*. Accomplished by combining the rules of the CFGs and adding the new rule

    $$S\to S_1|S_2|\dots |S_k$$

    where $S_i$ is the start variable for CFG $i$

**Construction of CFG from DFA**. Constructing a CFG for a language, which happens to be regular, is easy if we can construct a DFA for the language
* *Conversion from DFA to CFG*.
    1. Make a variable $R_i$ for each state $q_i$ of the DFA
    2. Add the rule $R_i\to aR_j$ to the CFG if $\delta(q_i,a)=q_j$ is a transition in the DFA
    3. Add the rule $R_i\to\varepsilon$ if $q_i$ is an accept state of the DFA
    4. Make $R_0$ the start variable of the grammar, where $q_0$ is the start state of the machine

**Construction of CFLs from substrings**. Some CFLs contain strings with two substrings linked in the sense that a machine for the language would need to remember an unbounded amount of information about one substring to verify that ir corresponds properly to the other
* *Example*. The language $\{0^n1^n:n\geq 0\}$
* *Construction of a CFG*. Use a rule of the form $R\to uRv$, which generates strings where the portion containing the $u$'s corresponds to the portion containing the $v$'s

**Construction of CFLs for strings with recursive structures**. In complex languages, the strings may contain structures, which appear recursively as part of other, or the same, structures

## Ambiguity
**Brief**. A grammar can generate the same string in different ways, hence the string will have several different parse tree and thus different meanings

$\to$ This is undesirable for certain applications, e.g. programming languages

**Ambiguity**. A string is derived ambiguously in a grammar if the grammar generates the same string in different ways

$\to$ A grammar is ambiguous if it generates some string ambiguously
* *Derivation and parse trees*. WHen a grammar generates a string ambiguously, it means that the string has two different parse trees, not two different derivations
    * *Explain*. Two derivations may differ merely in the order, in which they replace variables, yet not in their overall structure
* *Leftmost derivation of a string $w$*. A derivation of $w$ in a grammar $G$, where at every step, the leftmost remaining variable is replaced

    $\to$ This is introduced to focus on structure
* *Formal definition of ambiguity*.
    * A string $w$ is derived ambiguously in a CFG $G$ if it has two or more different leftmost derivations
    * Grammar $G$ is ambiguous if it generates some string ambiguously

>**NOTE**. For some ambiguous grammar, we can find an unambiguous grammar generating the same language

**Inherently ambiguous language**. CFLs which can be generated only by ambiguous grammars

## Chomsky normal form
**Brief**. It is convenient to have CFGs in simplified form

**Chomsky normal form**. One of the simplest and most useful forms
* *Chomsky normal form*. A CFG is in Chomsky normal form if eveyr rule has the form

    $$A\to BC,\quad A\to a,\quad S\to\varepsilon$$

    where $a$ is any terminal, $A,B,C$ are any variables, and $B,C$ are not the start variable $S$

**Conversion from CFG to Chomsky normal form**. The conversion has several stages, where rules violating the conditions are replaced with equivalent satisfying ones
* *Idea*.
    1. Add a new start variable $S_0$
    2. Eliminate all $\varepsilon$ rules of the form $A\to\varepsilon$, where $A\neq S$, and patch up the grammar accordingly
    3. Eliminate all unit rules $A\to B$, and patch up the grammar accordingly
    4. Convert the remaining rules into the proper form
* *Patching $A\to\varepsilon$ rules*. For each occurrence of an $A$ on the right-hand side of a rule

    $\to$ We add a new rule with that occurrence deleted, i.e. $R\to uAv$ to $R\to uv$
* *Patching $A\to B$*. For each rule $B\to u$, we add $A\to u$ unless this was a unit rule previously removed
* *Conversion of $A\to u_1u_2\dots u_k$ where $k\geq 3$*. Replace $A\to u_1u_2\dots u_k$ by
    
    $$A\to u_1A_1,A_1\to u_2A_2\dots,A_{k-2}\to u_{k-1}u_k$$

* *Conclusion*. Any CFL is genrated by a CFG in Chomsky normal form