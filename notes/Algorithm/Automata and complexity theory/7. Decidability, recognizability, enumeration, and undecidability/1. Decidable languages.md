<!-- TOC titleSize:1 tabSpaces:2 depthFrom:1 depthTo:6 withLinks:1 updateOnSave:1 orderedList:0 skip:0 title:1 charForUnorderedList:* -->
# Table of Contents
- [Table of Contents](#table-of-contents)
- [Decidable language](#decidable-language)
  - [Decidable problems concerning regular languages](#decidable-problems-concerning-regular-languages)
    - [Acceptance problem](#acceptance-problem)
    - [Emptiness testing](#emptiness-testing)
    - [Equivalence testing](#equivalence-testing)
  - [Decidable problems concerning context-free languages](#decidable-problems-concerning-context-free-languages)
<!-- /TOC -->

# Decidable language
**Brief**. This chapter investigates the power of algorithms to solve problems, i.e. we demonstrate certain problems can be solved algorithmically and others that cannot

$\to$ The objective is to explore the limits of algorithmic solvability
* *Needs for studying unsolvability*.
    * Knowing when a problem is algorithmically unsolvable is useful
        * *Explain*. We realize that the problem must be simplified or altered before being able to find an algorithmic solution

            $\to$ Like any tool, computers have capabilities and limitations which must be appreciated if they are to be used well
    * Cultural reasons, i.e. even if we deal with clearly solvable problems

        $\to$ A glimpse of the unsolvable can stimulate our imagination and help us gain an important perspective on computation

**Section introduction**. This section focuses on languages concerning automata and grammars
* *Context-free language (CFL)*. Interesting for several reasons
    * Certain problems related to CFL are related to application
        * *Example*. Testing whether a CFL generates a string is related to the problem of recognizing and compiling programs in a programming language
    * Certain other problems concerning automata and grammars are not decidable by algorithms

## Decidable problems concerning regular languages
**Brief**. We begin with certain computational problems concerning finite automata, i.e. we give algorithms for testing 
* Whether a finite automaton accepts a string
* Whether the language of a finite automaton is empty
* Whether two finite automata are equivalent

**Computational problem representation using languages**. This representation is convenient, since we already set up terminology for dealing with languages

### Acceptance problem
**Acceptance problem for DFAs**. Test whether a DFA accepts a given string
* *Language representation of the problem*. The language contains the encodings of all DFAs and the strings that the DFAs accept, i.e.

    $$A_\text{DFA}=\{\langle B,w\rangle:B\text{ is a DFA accepting input string }w\}$$

    * *Explain*. Testing whether a DFA $B$ accepts an input $w$ is equivalent to testing whether $\langle B,w\rangle$ is a member of $A_\text{DFA}$
    * *Consequence*. Showing that $A_\text{DFA}$ is decidable is equivalent to showing that the computational problem is decidable

**Theorem**. $A_\text{DFA}$ is a decidable language
* *Proof*. $\TODO$

**Theorem**. Consider the similar language for NFAs

$$A_\text{NFA}=\{\langle B,w\rangle:B\text{ is an NFA accepting input string }w\}$$

then $A_\text{NFA}$ is a decidable language

**Theorem**. Consider the similar language for regular expression

$$A_\text{REX}=\{\langle R,w\rangle:R\text{ is a RE generating string }w\}$$

then $A_\text{REX}$ is a decidable language

**Corollary**. For decidability purposes, presenting the TM with a DFA, NFA, or RE are all equivalent, since the TM can convert one form of encoding to another

### Emptiness testing
**Emptiness testing for the language of finite automaton**. Determine whether a finite automaton accepts any string at all

**Theorem**. Consider the language

$$E_\text{DFA}=\{\langle A\rangle:A\text{ is a DFA and }L(A)=\emptyset\}$$

then $E_\text{DFA}$ is a decidable language

### Equivalence testing
**Equivalence testing for DFAs**. Determine whether two DFAs recognize the same language

**Theorem**. Consider the language

$$\text{EQ}_\text{DFA}=\{\langle A,B\rangle:A,B\text{ are DFAs and }L(A)=L(B)\}$$

then $\text{EQ}_\text{DFA}$ is a decidable language

## Decidable problems concerning context-free languages
**Brief**. This section describes algorithms to determine whether a CFG generates a particular string, and to determine whether the language of a CFG is empty

**Acceptance testing**.Consider a language

$$A_\text{CFG}=\{\langle G,w\rangle:G\text{ is a CFG generating }w\}$$

then $A_\text{CFG}$ is a decidable language
* *Proof*. $\TODO$
* *Usage*. Used in compiling programming languages

**Emptiness testing** Consider a language

$$E_\text{CFG}=\{\langle G\rangle:G\text{ is a CFG and }L(G)=\emptyset\}$$

then $E_\text{CFG}$ is a decidable language

**Equivalence testing**. Consider a language

$$\text{EQ}_\text{CFG}=\{\langle G,H\rangle:G,H\text{ are CFGs and }L(G)=L(H)\}$$

then $\text{EQ}_\text{CFG}$ is not decidable

**Theorem**. Every context-free language is decidable by a TM
* *Consequence*. The following relationship among classes of languages is established

    IMAGE 4.10 FROM TEXT BOOK HERE ...