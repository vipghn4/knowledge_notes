<!-- TOC titleSize:1 tabSpaces:2 depthFrom:1 depthTo:6 withLinks:1 updateOnSave:1 orderedList:0 skip:0 title:1 charForUnorderedList:* -->
# Table of Contents
- [Table of Contents](#table-of-contents)
- [Reliable group communication](#reliable-group-communication)
  - [Scalability in reliable multicasting](#scalability-in-reliable-multicasting)
  - [Atomic multicast](#atomic-multicast)
    - [Virtual synchrony](#virtual-synchrony)
    - [Message ordering](#message-ordering)
- [Appendix](#appendix)
  - [Discussion](#discussion)
<!-- /TOC -->

# Reliable group communication
**Brief**. 
* *Importance of reliable group communication*. Considering how important process resilience by replication is

    $\to$ It is not surprising that reliable multicast services are important as well
    * *Explain*. Such services guarantee that messages are delivered to all members in a process group
* *Issue*. Reliable multicasting is tricky

**Reliable group communication**.
* *Reliable group communication*. A message sent to a process group should be delivered to each member of that group
* *Receiving versus delivering a message*. If we separate the logic of handling messages from the core functionality of a group member
    
    $\to$ We can make the distinction between receiving messages and delivering messages

    <div style="text-align:center">
        <img src="https://i.imgur.com/dpJFbyH.png">
        <figcaption>Receiving and delivering a message</figcaption>
    </div>

    * *Idea*. A message is received by a message-handling component, which delivers a message to the component containing the core functionality of a group member
        
        $\to$ A message received by process $P$ will also be delivered by $P$
* *Message-handling component*. Responsible for
    * Ensure that messages from the same sender are delivered in the same order as they were sent
    * Provide reliable message-passing, i.e. if not by the underlying OS

**Reliable communication in case of faulty processes**. Group communication is reliable when a message is ensured to be received and delivered by all nonfaulty group members
* *Problem*. Agreement should be reached on what the group looks like before a message can be delivered
    * *Explain*. If a sender intended to have a message delivered by each member of a group $G$, but at the time of delivery we actually have another group $G'\neq G$
        
        $\to$ We should wonder if the message can be delivered or not
    
    >**NOTE**. The situation becomes simpler if we can ignore consensus on group  membership

**Solutions to reliable communication in case of faulty processes**. Consider a sending process with a list of intended recipients
* *Reliable communication with reliable transport-level protocol*. The sender can deploy reliable transport-level protocols, e.g. TCP
    * *Procedure*.
        1. The sender sends its message to each recipient, one by one
        2. If a receiving process fails, the message may be resent later when the process recovers, or ignored altogether, e.g. because the sender had left the group
        3. In case a group member is expected to send a response, even if it is just an acknowledgement
            
            $\to$ Communication can be speeded up by  separating the sending of a request from receiving a response, i.e. overlapping messsage transfers
    * *Drawback*. Most transport layers offer reliable point-to-point channels
        
        $\to$ They rarely offer reliable communication to a group of processes
        * *Explain*. The best they offer is to let a process set up a point-to-point connection to each other process it wants to communicate with
        * *Consequence*. When process groups are relatively small, this approach is straightforward and practical
* *Reliable communication with unreliable transport-level protocol*. Consider a communication system with unreliable multicasting
    
    $\to$ A multicast message may be lost part way and delivered by some, but not all, of the intended receivers
    * *Idea*. The sending process assigns a sequence number to each message it multicasts and stores the message locally in a history buffer, i.e.
        * Assuming that the receivers are known to the sender
            
            $\to$ The sender simply keeps the message in its history buffer until each receiver has returned an acknowledgment
        * A receiver can suspect it is missing a message $m$ with sequence number $s$ when it has received messages with sequence numbers higher than $s$
            
            $\to$ It returns a negative acknowledgement to the sender, requesting for a retransmission of $m$

**Trade-offs**. There are various design trade-offs to be made, e.g. 
* To reduce the number of messages returned to the sender
    
    $\to$ Acknowledgments could possibly be piggybacked with other messages
* Retransmitting a message can be done using point-to-point communication to each requesting process, or using a single multicast message sent to all processes

## Scalability in reliable multicasting
**Brief**. The reliable multicast scheme described above has several problems, i.e.

**Scaling problem**.
* *Problems*.
    * The scheme cannot support large numbers of receivers, i.e. if there are $N$ receivers

        $\to$ The sender must be prepared to accept at least $N$ acknowledgments
    * The receivers may be spread across a wide-area network
* *Feedback implosion*. With many receivers, the sender may be swamped with feedback messages
* *Examples*.
    * When replicating processes for fault tolerance, this situation is not likely to occur as process groups are relatively small
    * When replicating for performance, we have a different case
* *Solution*. * Rather than acknowledging the receipt of a message
    
    $\to$ A receiver returns a feedback message only to inform the sender it is missing a message
    * *Benefits*. The system generally scales better
    * *Drawbacks*. 
        * No hard guarantees can be given that feedback implosions will never happen
        * The sender will, in theory, be forced to keep a message in its history buffer forever
            * *Explain*. The sender can never know if a message has been correctly delivered to all receivers
                
                $\to$ It should always be prepared for a receiver requesting the retransmission of an old message
    * *Improvement*. The sender will remove a message from its history buffer after some time has elapsed to prevent the buffer from overflowing
        
        >**NOTE**. Removing a message is done at the risk of a request for a retransmission not being honored

**Nonhierarchical feedback control**. A representative solution to scalable reliable multicasting
* *Motivation*. The key issue to scalable solutions for  reliable multicasting is to reduce the number of feedback messages returned to the sender
* *Feedback suppression*. A popular model that has been applied to several wide-area
applications
    
    $\to$ This underlies the Scalable Reliable Multicasting (SRM) protocol developed by Floyd et al. in 1997
* *Key idea of SRM*. Receivers never acknowledge the successful delivery of a  multicast message
    
    $\to$ They report only when they are missing a message, i.e. only negative acknowledgments are returned as feedback
    
    >**NOTE**. How message loss is detected is left to the application
    
* *Key idea of feedback suppression*. Whenever a receiver notices that it missed a message, it multicasts its feedback to the rest of the group
    
    $\to$ This allows another group member to suppress its own feedback
    * *Explain*.
        * If several receivers missed message $m$
            
            $\to$ Each of them returns a negative acknowledgment to the sender $S$ for the retransmissions of $m$
        * If we assume that retransmissions are multicast to the entire group
            
            $\to$ Only one request for retransmission reaching $S$ is required
* *Implementation*. 
    1. A receiver $R$, which did not receive message $m$ schedules a feedback message with some random delay
        * *Explain*. The request for retransmission is not sent until some random time has elapsed
    2. If, in the meantime, another request for retransmission for $m$ reaches $R$
        
        $\to$ $R$ will suppress its own feedback, knowing that $m$ will be retransmitted shortly
    3. Only a single feedback message will reach $S$, which in turn subsequently retransmits $m$
* *Usage*. Feedback suppression has shown to scale reasonably well
    
    $\to$ It has been used as the underlying mechanism for some collaborative Internet applications, e.g. a shared whiteboard
* *Drawbacks*.
    * Ensuring that only one request for retransmission is returned to the sender requires a reasonably accurate scheduling of feedback messages at each receiver
        
        $\to$ Otherwise, many receivers will still return their feedback at the same time
        * *Problem*. Setting timers accordingly in a group of processes dispersed across a wide-area network is tricky
    * Multicasting feedback also interrupts processes, to which the message has been successfully delivered
        * *Explain*. Other receivers are forced to receive and process messages, which are useless to them
        * *Solution*. Receivers, which have not received message $m$, join a separate multicast group for $m$
            * *Drawback*. Groups must be managed in a highly efficient manner, which is hard to accomplish in a wide-area system
        * *Improved solution*. Receivers, which tend to miss the same messages, team up and share the same multicast channel for feedback messages and retransmissions
* *Improvement*. To enhance the scalability of SRM, receivers should assist in local recovery
    * *Explain*. If a receiver, to which message $m$ has been successfully delivered, receives a request for retransmission
        
        $\to$ It can decide to multicast $m$, even before the retransmission request reaches the original sender

**Hierarchical feedback control**. Feedback suppression is a nonhierarchical solution. 

$\to$ However, achieving scalability for very large groups of receivers requires hierarchical approaches
* *Idea*. The group of receivers is partitioned into a number of subgroups, which are subsequently organized into a tree
* *Subgroup intra-communication*. Within each subgroup, any reliable multicasting scheme working for small groups can be used
* *Subgroup coordinator*. Each subgroup appoints a local coordinator representing that group in the multicast tree
    
    $\to$ A link in the tree between two nodes corresponds to a reliable connection between the coordinators of the respective subgroups
* *Subgroup inter-communication*. When a process $S$ in group $G$ wants to send a message
    1. It uses the reliable multicast scheme for $G4 to reach all its members, including the group's coordinator $C$
    2. $C$ forwards the message to its neighboring coordinators
    3. A coordinator will forward an incoming message $m$ to all its neighboring coordinators, except the one from which it received $m$
    4. A coordinator will reliably multicast the incoming message to all members of the subgroup it represents
        
        >**NOTE**. The group coordinator also handle retransmissions for the group

* *Hierarchical feedback control in ACK-based scheme*. If coordinator $C$ of group $G$ sends a message $m$ to coordinator $C'$ of another neighboring group $G'$
    
    $\to$ It will keep $m$ in its history buffer at least until $C'$ has sent an acknowledgement
* *Hierarchical feedback control in NACK-based scheme*. Only if $G'$ detects it has missed m
    
    $\to$ It will send a NACK message to $C$
* *Benefits*. A single ACK or NACK message from a coordinator aggregates many feedback control messages from other processes
    
    $\to$ This leads to a much more scalable reliable multicasting scheme
* *Improvement*. Scalability is further improved by 
    * Let a coordinator handle the retransmissions to neighboring coordinators, to which it had forwarded a message
    * Combine with nonhierarchical feedback control to combine relatively large reliable-multicast subgroups into potentially large trees
        
        $\to$ We can support reliable multicasting for very large groups of processes
* *Drawback*. 
    * The construction and management of the tree are sophisticated,, i.e.
        * How are subgroups formed
        * Which processes are appointed to be coordinator
        * How are the subgroups organized in a tree
    * In many cases, a tree needs to be constructed dynamically
        
        $\to$ Traditional network-level solutions provide almost no adequate services for tree management
* *Consequence*. Application-level multicasting solutions have gained popularity

**Gossip-based scalable reliable multicasting**. Consider the push-pull anti-entropy scheme 
* *Idea*. A node $P$ picks another node $Q$ at random, and exchanges updates with $Q$
    * *Explain*. $P$ pushes updates that $Q$ has not seen before to $Q$, and pulls in any updates that $Q$ has, but which were missed by $P$
    * *Consequence*. After the exchange, both processes have the same data
* *Robustness*. This scheme is inherently robust
    * *Explain*. If the communication between $P$ and $Q$ fails, $P$ will pick some other node to exchange updates
* *Drawback*. The speed, by which an update propagates through the system, slows down

    $\to$ This slowdown is considered important for some applications

## Atomic multicast


### Virtual synchrony

### Message ordering

# Appendix
## Discussion
**Implementing virtual synchrony**.
Let us now consider a possible implementation of a virtually synchronous reliable
multicast. An example of such an implementation appears in Isis, a fault-tolerant
distributed system that has been in practical use in industry for several years. We
will focus on some of the implementation issues of this technique as described in
Birman et al. [1991].
Reliable multicasting in Isis makes use of available reliable point-to-point 
communication facilities of the underlying network, in particular, TCP. Multicasting a
message m to a group of processes is implemented by reliably sending m to each
group member. As a consequence, although each transmission is guaranteed to
succeed, there are no guarantees that all group members receive m. In particular,
the sender may fail before having transmitted m to each member.
Besides reliable point-to-point communication, Isis also assumes that messages
from the same source are received by a communication layer in the order they
were sent by that source. In practice, this requirement is solved by using TCP
connections for point-to-point communication.
The main problem that needs to be solved is to guarantee that all messages
sent to view G are delivered to all nonfaulty processes in G before the next group
membership change takes place. The first issue that needs to be taken care of
is making sure that each process in G has received all messages that were sent
to G. Note that because the sender of a message m to G may have failed before
completing its multicast, there may indeed be processes in G that will never
receive m. Because the sender has crashed, these processes should get m from
somewhere else.
The solution to this problem is to let every process in G keep m until it knows
for sure that all members in G have received it. If m has been received by all
members in G, m is said to be stable. Only stable messages are allowed to be
delivered. To ensure stability, it is sufficient to select an arbitrary live process in
G and request it to send m to all other processes in G.
To be more specific, assume the current view is Gi, but that it is necessary
to install the next view Gi+1. Without loss of generality, we assume that Gx and
Gi+1 differ by at most one process. A process P notices the view change when
it receives a view-change message. Such a message may come from the process
wanting to join or leave the group, or from a process that had detected the failure
of a process in Gi that is now to be removed, as shown in Figure 8.29(a).
When a process P receives the view-change message for Gi+1, it first forwards
a copy of any unstable message from Gi it still has to every process in Gi+i, and
subsequently marks it as being stable. Recall that Isis assumes point-to-point
communication is reliable, so that forwarded messages are never lost. Such
forwarding guarantees that all messages in Gi that have been received by at least
one process are received by all nonfaulty processes in Gi. Note that it would also
have been sufficient to elect a single coordinator to forward unstable messages.
To indicate that P no longer has any unstable messages and that it is prepared
to install Gi+1 as soon as the other processes can do that as well, it multicasts a
flush message for Gi+1, as shown in Figure 8.29(b). After P has received a flush
...