<!-- TOC titleSize:1 tabSpaces:2 depthFrom:1 depthTo:6 withLinks:1 updateOnSave:1 orderedList:0 skip:0 title:1 charForUnorderedList:* -->
# Table of Contents
- [Table of Contents](#table-of-contents)
- [Reliable group communication](#reliable-group-communication)
  - [Atomic multicast](#atomic-multicast)
    - [Virtual synchrony](#virtual-synchrony)
    - [Message ordering](#message-ordering)
- [Appendix](#appendix)
  - [Discussion](#discussion)
<!-- /TOC -->

# Reliable group communication
Considering how important process resilience by replication is, it is not 
surprising that reliable multicast services are important as well. Such services
guarantee that messages are delivered to all members in a process group.
Unfortunately, reliable multicasting turns out to be surprisingly tricky. In
this section, we take a closer look at the issues involved in reliably delivering
messages to a process group. Let us first define what reliable group 
communication actually is. Intuitively, it means that a message that is sent to a process
group should be delivered to each member of that group. If we separate the
logic of handling messages from the core functionality of a group member,
we can conveniently make the distinction between receiving messages and
delivering messages, as illustrated in Figure 8.20. A message is received by
a message-handling component, which, in turn, delivers a message to the
component containing the core functionality of a group member. Informally,
a message that is received by process P will also be delivered by P.

IMAGE

As an example, ensuring that messages from the same sender are delivered
in the same order as they were sent, is typically taken care of by a message-
handling component. Likewise, providing reliable message-passing is a
feature that can and should be separated from the core functionality of a group
member, and is typically implemented by a message-handling component (if
not by the underlying operating system).
With this separation between receiving and delivering messages, we can be
more precise about what reliable group communication means. Let us make a
distinction between reliable communication in the presence of faulty processes,
and reliable communication when processes are assumed to operate correctly.
In the first case, group communication is considered to be reliable when it can
be guaranteed that a message is received and subsequently delivered by all
nonfaulty group members.
The tricky part here is that agreement should be reached on what the
group actually looks like before a message can be delivered. If a sender
intended to have a message delivered by each member of a group G, but that,
for whatever reason, at the time of delivery we actually have another group
G' 7^ G, we should ask ourselves if the message can be delivered or not.
The situation becomes simpler if we can ignore consensus on group 
membership. In particular, let us first assume that a sending process has a list of
intended recipients. In that case, it can simply deploy reliable transport-level
protocols such as TCP and, one by one, sends its message to each recipient. If
a receiving process fails, the message may be resent later when the process
recovers, or ignored altogether (for example, because the sender had left the
group). In case a group member is expected to send a response, even if it
is just an acknowledgement, communication can be speeded up by 
separating the sending of a request from receiving a response, as illustrated by the
message sequence charts in Figure 8.21.

IMAGE

Most transport layers offer reliable point-to-point channels; they rarely
offer reliable communication to a group of processes. The best they offer is to
let a process set up a point-to-point connection to each other process it wants
to communicate with. When process groups are relatively small, this approach
to establishing reliability is a straightforward and practical solution. On the
other hand, we can often assume that the underlying communication system
does offer unreliable multicasting, meaning that a multicast message may be
lost part way and delivered by some, but not all, of the intended receivers.
A simple solution to reach reliable group communication is shown in
Figure 8.22. The sending process assigns a sequence number to each message
it multicasts and stores the message locally in a history buffer. Assuming
the receivers are known to the sender, the sender simply keeps the message
in its history buffer until each receiver has returned an acknowledgment.
A receiver can suspect it is missing a message m with sequence number s
when it has received messages with sequence numbers higher than s. In that
case, it returns a negative acknowledgement to the sender, requesting for a
retransmission of m.

IMAGE

There are various design trade-offs to be made. For example, to reduce the
number of messages returned to the sender, acknowledgments could possibly
be piggybacked with other messages. Also, retransmitting a message can be
done using point-to-point communication to each requesting process, or using
a single multicast message sent to all processes. General issues on reliable
multicasting are discussed by Popescu et al. [2007]. A survey and overview
of reliable multicasting in the context of publish/subscribe systems, which is
also relevant here is [Esposito et al., 2013].

**Scalability in reliable multicasting**.
The main problem with the reliable multicast scheme just described is that it
cannot support large numbers of receivers. If there are N receivers, the sender
must be prepared to accept at least N acknowledgments. With many receivers,
the sender may be swamped with such feedback messages, which is also referred
to as a feedback implosion. When replicating processes for fault tolerance, this
situation is not likely to occur as process groups are relatively small. When
replicating for performance, we have a different case. Moreover, we may then also
need to take into account that the receivers are spread across a wide-area network.
One solution to the problem of a feedback implosion is not to have receivers
acknowledge the receipt of a message. Instead, a receiver returns a feedback
message only to inform the sender it is missing a message. Returning only such
negative acknowledgments can be shown to generally scale better [Towsley et al.,
1997], but no hard guarantees can be given that feedback implosions will never
happen.
Another problem with returning only negative acknowledgments is that
the sender will, in theory, be forced to keep a message in its history buffer
forever. Because the sender can never know if a message has been correctly
delivered to all receivers, it should always be prepared for a receiver requesting
the retransmission of an old message. In practice, the sender will remove a
message from its history buffer after some time has elapsed to prevent the buffer
from overflowing. However, removing a message is done at the risk of a request
for a retransmission not being honored.
Several proposals for scalable reliable multicasting exist. A comparison 
between different schemes can be found in [Levine and Garcia-Luna-Aceves, 1998].
We now briefly discuss two very different approaches that are representative of
many existing solutions.
Nonhierarchical feedback control The key issue to scalable solutions for 
reliable multicasting is to reduce the number of feedback messages that are returned
to the sender. A popular model that has been applied to several wide-area
applications is feedback suppression. This scheme underlies the Scalable 
Reliable Multicasting (SRM) protocol developed by Floyd et al. [1997] and works as
follows.
First, in SRM, receivers never acknowledge the successful delivery of a 
multicast message, but instead, report only when they are missing a message. How
message loss is detected is left to the application. Only negative acknowledgments
are returned as feedback. Whenever a receiver notices that it missed a message, it
multicasts its feedback to the rest of the group.
Multicasting feedback allows another group member to suppress its own
feedback. Suppose several receivers missed message m. Each of them will need to
return a negative acknowledgment to the sender, S, so that m can be retransmitted.
However, if we assume that retransmissions are always multicast to the entire
group, it is sufficient that only a single request for retransmission reaches S.
For this reason, a receiver R that did not receive message m schedules a
feedback message with some random delay. That is, the request for retransmission
is not sent until some random time has elapsed. If, in the meantime, another
request for retransmission for m reaches R, R will suppress its own feedback,
knowing that m will be retransmitted shortly. In this way, ideally, only a single
feedback message will reach S, which in turn subsequently retransmits m. This
scheme is shown in Figure 8.23.

IMAGE

Feedback suppression has shown to scale reasonably well, and has been used
as the underlying mechanism for a number of collaborative Internet applications,
such as a shared whiteboard. However, the approach also introduces a number
of serious problems. First, ensuring that only one request for retransmission is
returned to the sender requires a reasonably accurate scheduling of feedback
messages at each receiver. Otherwise, many receivers will still return their
feedback at the same time. Setting timers accordingly in a group of processes that
is dispersed across a wide-area network is not that easy.
Another problem is that multicasting feedback also interrupts those processes
to which the message has been successfully delivered. In other words, other
receivers are forced to receive and process messages that are useless to them. The
only solution to this problem is to let receivers that have not received message
m join a separate multicast group for m, as explained by Kasera et al. [1997].
Unfortunately, this solution requires that groups can be managed in a highly
efficient manner, which is hard to accomplish in a wide-area system. A better
approach is therefore to let receivers that tend to miss the same messages team up
and share the same multicast channel for feedback messages and retransmissions.
Details on this approach are found in [Liu et al., 1998].
To enhance the scalability of SRM, it is useful to let receivers assist in local
recovery. In particular, if a receiver to which message m has been successfully
delivered, receives a request for retransmission, it can decide to multicast m even
before the retransmission request reaches the original sender. Further details can
be found in [Floyd et al., 1997] and [Liu et al, 1998].
Hierarchical feedback control Feedback suppression as just described is 
basically a nonhierarchical solution. However, achieving scalability for very large
groups of receivers requires that hierarchical approaches are adopted. A solution
is shown in Figure 8.24. The group of receivers is partitioned into a number
of subgroups, which are subsequently organized into a tree. Within each 
subgroup, any reliable multicasting scheme that works for small groups can be used.
Each subgroup appoints a local coordinator, which represents that group in the
multicast tree. A link in the tree between two nodes corresponds to a reliable
connection between the coordinators of the respective subgroups.
When a process S in group G wants to send a message, it simply uses the
reliable multicast scheme for G to reach all its members, including the group's
coordinator, say C. C, in turn, will forward the message to its neighboring
coordinators. As a general rule, a coordinator will forward an incoming message
m to all its neighboring coordinators, except the one from which it received m.
In addition, a coordinator will reliably multicast the incoming message to all
members of the subgroup it represents, and notably also handle retransmissions
for that group.
In an ACK-based scheme, if coordinator C of group G sends a message m to
coordinator C of another, neighboring group G', it will keep m in its history buffer
at least until C has sent an acknowledgement. In a NACK-based scheme, only if
G' detects it has missed m (and thus also all members of G', and all coordinators
to which Gf would have forwarded m), it will send a nack message to C. It
is thus seen that a single ack or nack message from a coordinator, aggregates
many feedback control messages from other processes, leading to a much more
scalable reliable multicasting scheme. Scalability is further improved by letting a
coordinator handle the retransmissions to neighboring coordinators to which it
had forwarded a message.

IMAGE

Note that the nonhierarchical feedback control which we discussed before
can be used to improve the scalability of a single multicast group. Together
with hierarchical feedback control, we would combine relatively large reliable-
multicast subgroups into potentially large trees, thus being able to support reliable
multicasting for very large groups of processes.
The main problem with hierarchical solutions is the construction and 
management of the tree: how are subgroups formed, which processes are appointed to
be coordinator, and how are the subgroups organized in a tree. In many cases, a
tree needs to be constructed dynamically. Unfortunately, traditional network-level
solutions provide almost no adequate services for tree management. For this
reason, application-level multicasting solutions as we discussed in Section 4.4
Gossip-based scalable reliable multicasting Finally, let us briefly consider
gossip-based multicasting schemes, in particular the following push-pull anti-
entropy scheme that we discussed extensively in Section 4.4 .
In this scheme, a node P picks another node Q at random, and subsequently
exchanges updates with Q. In other words, P pushes updates that Q has not seen
before to Q, and pulls in any updates that Q has, but which were missed by P.
After the exchange, both processes have the same data. Clearly, this scheme is
already inherently robust, for if the communication between P and Q fails for
whatever reason, P will simply pick some other node to exchange updates. The
net effect is that the speed by which an update propagates through the system
slows down, but the reliability is affected only in extreme cases. Nevertheless,
this slowdown is considered important for some applications. In this light,
the comparison between traditional tree-based multicasting and gossip-based
multicasting for the purpose of aggregation as discussed by Nyers and Jelasity
[2015] may be of interest.
In conclusion, building reliable multicast schemes that can scale to a large
number of receivers spread across large networks, is a difficult problem. No single
best solution exists, and each solution introduces new problems.

## Atomic multicast

### Virtual synchrony

### Message ordering

# Appendix
## Discussion
**Implementing virtual synchrony**.
Let us now consider a possible implementation of a virtually synchronous reliable
multicast. An example of such an implementation appears in Isis, a fault-tolerant
distributed system that has been in practical use in industry for several years. We
will focus on some of the implementation issues of this technique as described in
Birman et al. [1991].
Reliable multicasting in Isis makes use of available reliable point-to-point 
communication facilities of the underlying network, in particular, TCP. Multicasting a
message m to a group of processes is implemented by reliably sending m to each
group member. As a consequence, although each transmission is guaranteed to
succeed, there are no guarantees that all group members receive m. In particular,
the sender may fail before having transmitted m to each member.
Besides reliable point-to-point communication, Isis also assumes that messages
from the same source are received by a communication layer in the order they
were sent by that source. In practice, this requirement is solved by using TCP
connections for point-to-point communication.
The main problem that needs to be solved is to guarantee that all messages
sent to view G are delivered to all nonfaulty processes in G before the next group
membership change takes place. The first issue that needs to be taken care of
is making sure that each process in G has received all messages that were sent
to G. Note that because the sender of a message m to G may have failed before
completing its multicast, there may indeed be processes in G that will never
receive m. Because the sender has crashed, these processes should get m from
somewhere else.
The solution to this problem is to let every process in G keep m until it knows
for sure that all members in G have received it. If m has been received by all
members in G, m is said to be stable. Only stable messages are allowed to be
delivered. To ensure stability, it is sufficient to select an arbitrary live process in
G and request it to send m to all other processes in G.
To be more specific, assume the current view is Gi, but that it is necessary
to install the next view Gi+1. Without loss of generality, we assume that Gx and
Gi+1 differ by at most one process. A process P notices the view change when
it receives a view-change message. Such a message may come from the process
wanting to join or leave the group, or from a process that had detected the failure
of a process in Gi that is now to be removed, as shown in Figure 8.29(a).
When a process P receives the view-change message for Gi+1, it first forwards
a copy of any unstable message from Gi it still has to every process in Gi+i, and
subsequently marks it as being stable. Recall that Isis assumes point-to-point
communication is reliable, so that forwarded messages are never lost. Such
forwarding guarantees that all messages in Gi that have been received by at least
one process are received by all nonfaulty processes in Gi. Note that it would also
have been sufficient to elect a single coordinator to forward unstable messages.
To indicate that P no longer has any unstable messages and that it is prepared
to install Gi+1 as soon as the other processes can do that as well, it multicasts a
flush message for Gi+1, as shown in Figure 8.29(b). After P has received a flush
...