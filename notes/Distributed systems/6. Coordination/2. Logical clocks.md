<!-- TOC titleSize:1 tabSpaces:2 depthFrom:1 depthTo:6 withLinks:1 updateOnSave:1 orderedList:0 skip:0 title:1 charForUnorderedList:* -->
# Table of Contents
- [Table of Contents](#table-of-contents)
- [Logical clocks](#logical-clocks)
  - [Lamport's logical clocks](#lamports-logical-clocks)
    - [Total-ordered multicasting](#total-ordered-multicasting)
  - [Vector clocks](#vector-clocks)
- [Appendix](#appendix)
  - [Concepts](#concepts)
<!-- /TOC -->

# Logical clocks
**Lamport's reasonings for the needs of a logical clock**. 
* Although clock synchronization is possible, it need not be absolute
    * *Explain*.
        * If two processes do not interact, it is not necessary that their clocks be synchronized
            * *Explain*. Lack of synchronization would not be observable, and hence could not cause problems
* What usually matters is not that all processes agree on exactly what time it is, but on the order, in which events occur

## Lamport's logical clocks
**Logical clock**. A clock keeping track of nodes' events, e.g. producing a new version of a file

**Happen-before relation**. $a\to b$ means "event $a$ happens before event $b$" and all processes agree that first event $a$ occurs, then event $b$ occurs
* *Direct observations of happens-before relation*. Can be observed in two situations
    * *Situation 1*. If $a$ and $b$ are events in the same process, and $a$ occurs before $b$, then $a\to b$ is true
    * *Situation 2*. If $a$ is the event of a message being sent by one process, and $b$ is the event of the message being received by another message

        $\to$ Then $a\to b$ is also true
* *Rules*.
    * If $a\to b$ and $b\to c$ then $a\to c$
    * If two events $x$ and $y$ happen in different processes, which do not exchange messages, not even indirectly via third parties

        $\to$ Neither $x\to y$ nor $y\to x$ is true, i.e. they are concurrent (no order exists)

**Time assignment**. We need a way of measuring a notion of time so that for evey event $a$, we can assign it a time value $C(a)$, on which all processes agree
* *Required property*. 
    * If $a\to b$ then $C(a) < C(b)$
    * The clock time $C$ must always go forward, never backward

        $\to$ Corrections to time can be made by adding a positive value, nevery by substracting one

**Lamport's proposed time assignment algorithm for events**.

<div style="text-align:center">
    <img src="https://i.imgur.com/cI82Ct6.png">
    <figcaption>Three processes, each with its own logical clock. The clocks run at different rates (a), and Lamport's algorithm for time correction (b)</figcaption>
</div>

* *Scenario*.
    * There are three processes running on different machines, each with its own logical clock
    * Each clock is implemented as a software counter, which is incremented by a specific value every $T$ time units
        * $T$ differs per process
* *Lamport clock (event counter)*. Follow directly from the happen-before relation
    * *Idea*. 
        * Each message carries the sending time according to the sender's clock
        * When a message arrives and the receiver's clock shows a value prior to the time the message was sent

            $\to$ The receiver fast forwards its clock to be one more than the sending time
    * *Requirements*. Each process $P_i$ maintains a local counter $C_i$, which are updated according to the following procedure
* *Implementation*. Lamport's clock is implemented as part of the middleware layer

    <div style="text-align:center">
        <img src="https://i.imgur.com/1092ruS.png">
        <figcaption>The positioning of Lamport's logical clocks in distributed systems</figcaption>
    </div>

    1. Before executing an event, e.g. sending a message over the network, delivering a message to an application, etc.

        $\to$ $P_i$ increments $C_i = C_i + 1$
    2. When $P_i$ sends a message $m$ to $P_j$, it sets $m$'s timestamp $\text{ts}(m)= C_i$
    3. Upon the receipt of $m$, $P_j$ adjusts its own local counter as $C_j = \max\{C_j, \text{ts}(m)\}$

        $\to$ After this, $P_j$ executes the first step and delivers the message to the application
* *Optional additional requirement*. No two events ever occur at exactly the same time
    * *Realization*. Use the unique process identifier to break ties and use tuples instead of only the counter's values
    * *Example*. An event at time $40$ at process $P_i$ is timestamped as $\langle 40, i\rangle$

        $\to$ If $i<j$ then $\langle 40, i\rangle < \langle 40, j\rangle$

### Total-ordered multicasting
**Scenario**. Consider a database, which has been replicated across several sites

$\to$ A query is always forwarded to the nearest copy
* *Trade-off*. Fast response results in higher update costs, since each update operation must be carried out at each replica
* *Scenario*.

    <div style="text-align:center">
        <img src="https://i.imgur.com/WKeZSDw.png">
        <figcaption>Updating a replicated database and leaving it in an consistent state</figcaption>
    </div>

    * A customer in San Francisco wants to add $100 to his account, which currently contains $1,000
    * A bank employee in NYC initiates an update, by which the customer's account is increased with 1% interest
    * Both updates should be carried out at both copies of the database
    *  Due to communication delays, the updates may arrive differently at the two replicas as given in the figure above
* *Problem*. Two update operations should have been performed in the same order at each copy

    $\to$ This requires a total-ordered multicast

**Total-ordered multicast**. A multicast operation, by which all messages are delivered in the same order to each receiver

$\to$ Lamport's logical clocks can be used to implement total-ordered multicasts in a completely distributed fashion
* *Assumptions*. Consider a group of processes multicasting messages to each other
    * Each message is always timestamped with the current logical time of its sender
    * When a message is multicast, it is conceptually also sent to the sender
    * Messages from the same sender are received in the order they were sent
    * No message is lost
* *Idea*.
    1. When a process receives a message, it is put into a local queue, ordered according to its timestamp
    2. The receiver multicasts an ACK to the other processes, with ACK timestamp higher than received message's timestamp

        $\to$ All processes will eventually have the same copy of the local queue, provided no message are removed
    3. A process can deliver a queued message to the application it is running only when the message is at the queue's head, and has been acknowledged by each other process

        $\to$ At this point, the message is removed from the queue and handed over to the application
    4. The associated ACKs can be removed then
* *Consequences*. Since each process has the same copy of the queue, all messages are delivered in the same order everywhere

    $\to$ We have established total-ordered multicasting
* *Message ACK*. It is not strictly necessary that each multicast message has been explicitly acknowledged

    $\to$ It is sufficient that a process reacts to an incoming message by returning an ACK, or sending its own multicast message

**Application of total-ordered multicasting**. An important vehicle for replicated services, where replicas are kept consistent by letting them execute the same operations in the same order everywhere
* *State machine replication*. As the replicas essentially follow the same transitions in the same finite state machine

    $\to$ TOM is also known as state machine replication

## Vector clocks

# Appendix
## Concepts
**Using Lamport clocks to achieve mutual exclusion**.