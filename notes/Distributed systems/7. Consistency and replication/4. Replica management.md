<!-- TOC titleSize:1 tabSpaces:2 depthFrom:1 depthTo:6 withLinks:1 updateOnSave:1 orderedList:0 skip:0 title:1 charForUnorderedList:* -->
# Table of Contents
- [Table of Contents](#table-of-contents)
- [Replica management](#replica-management)
  - [Finding the best server location](#finding-the-best-server-location)
  - [Content replication and placement](#content-replication-and-placement)
    - [Permanent replicas](#permanent-replicas)
    - [Server-initiated replicas](#server-initiated-replicas)
    - [Client-initiated replicas](#client-initiated-replicas)
  - [Content distribution](#content-distribution)
  - [Managing replicated objects](#managing-replicated-objects)
- [Appendix](#appendix)
  - [Concepts](#concepts)
<!-- /TOC -->

# Replica management
**Key issue for any distributed system supporting replication**.
* *Placement problem*. Decide where, when, and by whom replicas should be placed

    $\to$ This problem can be split into two subproblems
    * Problem of placing replica servers, i.e. finding the best locations to the place a server, which can host part of a data store
    * Problem of placing content, i.e. finding the best servers for placing content

        $\to$ This often means that we are looking for the optimal placement of only a single data item

    >**NOTE**. The difference is a subtle one, and the two issues are often not clearly separated

* *Consistency problem*. Which mechanisms to use for keeping the replicas consistent

## Finding the best server location
**Finding the best server location**. 
* Over a decode ago, one could be concerned about where to place an individual server

    $\to$ Matters have changed considerably with the advent of many large-scale data centers located across the Internet
* Connectivity continues to improve, making precisely locating servers less critical

## Content replication and placement
**Types of replicas**. When it comes to content replication and placement

$\to$ Three types of replicas can be distinguished logically

<div style="text-align:center">
    <img src="https://i.imgur.com/M2oofXB.png">
    <figcaption>The logical organization of different kinds of copies of a data store into three concentric rings</figcaption>
</div>

### Permanent replicas
**Permanent replicas**. The initial set of replicas, which constitute a distributed data store
* *Number of permanent replicas*. In many cases, this number is small

**Example**. Distribution of a Web site generally comes in one of several forms
* *Option 1 - Clustering*. The files constituting a site are replicated across a limited number of servers at a single location

    $\to$ Whenever a request comes in, it is forwarded to one of the servers, e.g. using a round-robin strategy
* *Option 2 - Mirroring*. A Web site is copied to a limited number of servers, i.e. mirror sites, which are geographically spread across the Internet

    $\to$ Clients choose one of the various mirror sites from a list offered to them
    * *Similar to cluster-based Web sites*. There are only a few replicas, which are more or less statically configured
* *Option 3 - shared-nothing*. The database is distributed and replicated across a number of servers, which together form a cluster of servers
    * *"Shared-nothing"*. Neither disks nor main memory are shared by processors

    >**NOTE**. Alternatively, a database is distributed and possibly replicated across a number of geographically dispersed sites

### Server-initiated replicas

### Client-initiated replicas

## Content distribution

## Managing replicated objects

# Appendix
## Concepts
**Replica-server placement**. The placement of replica servers is not an intensively studied problem since it is often more of a management and commercial issue than an optimization problem

$\to$ However, analysis of client and network properties are useful to come to informed decisions
* *Computing the best placement of replica servers*. Boil down to an optimization problem, in which the best $K$ out of $N$ locations need to be selected

    $\to$ These problems are known to be computationally complex, and can be solved only through heuristics
* *Qiu et. a. (2001) solution*. Take the distance between clients and locations as their starting point
    * *Idea*. Given that $k$ servers have been placed, i.e. there are $N-k$ locations left 
        
        $\to$ This solution selects one server at a time, so that the average distance between that server and its client is minimal
* *Radoslavov et. al. (2001) solution*. Propose to ignore the position of clients, and only take the topology of the Internet as formed by the autonomous systems (AS)
    * *Idea*. Radoslavov first consider the largest AS and place a server on the router with the largest number of network interfaces, i.e. links

        $\to$ The algorithm repeats with the second largest AS, and so on
    * *Effect*. Under the assumption that clients are uniformly distributed across the Internet, relative to the existing topology
    
        $\to$ Client-unaware server placement turns out to achieve similar results as client-aware placement

        >**NOTE**. To what extent this assumption is true is unclear

* *Szymaniak et. al. (2006) solution*. Developed a method, by which a region for placing replicas can be quickly identified
    * *Problem with previous approaches*. These algorithms are computationally expensive
        * *Explain*. Both the previous algorithms have a complexity, which is higher than $O(N^2)$, where $N$ is the number of locations to inspect
    * *Region*. A collection of nodes accessing the same content, but for which the internode latency is low
    * *Objective*. Select the most demanding regions, i.e. the one with the most nodes

        $\to$ We then let one of the nodes in the region act as replica server
        * *Idea*. Assuming that nodes are positioned in an $m$-dimensional geometric space

            $\to$ We need to identify the $K$ largest clusters and assign a node from each cluster to host replicated
    * *Cluster identification*.
        1. Partition the entire space into cells, i.e. $m$-dimensional hypercubes
        2. The $K$ most dense cells are chosen for placing a replica server
    * *Choosing cell size*.
        * *Effects of cell size*.
            * *Large cells*. Multiple clusters of nodes can be contained in the same cell

                $\to$ Too few replica servers for those clusters would be chosen
            * *Small cells*. A single cluster is spread across a number of cells

                $\to$ Too many replica servers are chosen
        * *Appropriate cell size*. Computed as a function of
            * The average distance between two nodes
            * The number of required replicas
        * *Consequence*. With proper cell size, the algorithm performs as well as the close-to-optimal one described by Qiu et. al., but having a much lower complexity, i.e. $O(N\times \max\{\log N, K\})$