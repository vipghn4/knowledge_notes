<!-- TOC titleSize:1 tabSpaces:2 depthFrom:1 depthTo:6 withLinks:1 updateOnSave:1 orderedList:0 skip:0 title:1 charForUnorderedList:* -->
# Table of Contents
- [Table of Contents](#table-of-contents)
- [Remote procedure call](#remote-procedure-call)
  - [Basic RPC operation](#basic-rpc-operation)
  - [Parameter passing](#parameter-passing)
  - [RPC-based application support](#rpc-based-application-support)
    - [Stub generation](#stub-generation)
    - [Language-based support](#language-based-support)
  - [Variations on RPC](#variations-on-rpc)
    - [Asynchronous RPC](#asynchronous-rpc)
    - [Multicast RPC](#multicast-rpc)
  - [Example - Distributed computing environment (DCE) RPC](#example---distributed-computing-environment-dce-rpc)
- [Appendix](#appendix)
  - [Discussion](#discussion)
<!-- /TOC -->

# Remote procedure call
**Commucation concealation**. In explicit message exchange betwen processes, the operations `send` and `receive` do not conceal communication at all, which is important to achieve access transparency in distributed systems
* *Idea of RPC*. Allow programs to call procedures located on other machines
    * *Explain*. When a process on machine A calls a procedure on machine B, the calling process on A is suspended, and the execution of the called procedure takes place on B
        * *Information propagation*. Information can be transported from the caller to the callee in the parameters and can come back in the procedure result

            $\to$ No message passing is visible to the programmer
* *Problems*.
    * Since the calling and called procedures run on different machines, they execute in different address spaces, causing complications
    * Parameters and results also have to be passed, i.e. complicated, especially if the machines are not identical
    * Either or both machines can crash, and each of the possible failures causes different problems

## Basic RPC operation
**Idea behind RPC**. Make a remote procedure call look as much as possible like a local one, i.e. RPC should be tranparent
* *Explain*. The calling procedure should not be aware that the called procedure is executing on a different machine or vice versa
* *Example*. Suppose that a program has access to a database allowing it to append data to a stored list, after which it returns a reference to the modified list

    ```python
    newlist = append(data, dblist)
    ```

    * *`append` function in traditional single-processor systems*. `append` is extracted from a library by the linker, and inserted into the object program

        >**NOTE**. In principle, it can be a short procedure, which could be implemented by a few file operations for accessing the database

        * *Function invocation*. `append` is called in the usual way, by pushing its parameters onto the stack

            $\to$ The programmer does not know the implementation details of `append`, and this is how it is supposed to be
    * *Transparency of RPC*. RPC achieves it transparency in an analogous way

        <div style="text-align:center">
            <img src="https://i.imgur.com/CNsxfmG.png">
            <figcaption>The principle of RPC between a client and server program</figcaption>
        </div>

        <div style="text-align:center">
            <img src="https://i.imgur.com/pHvTB8f.png">
            <figcaption>The steps in calling a remote procedure doit(a,b). The return path for the result is not shown</figcaption>
        </div>

        * *Client-to-server request procedure*.
            1. When `append` is actual`ly a remote procedure, a different version of `append`, called client stub, is offered to the calling client
            2. The client stub does not perform an append operation, but it packs the parameters into a message and requests the message to be sent to the server
            3. When the message arrives at the server, the server's OS passes it to a server stub, which is the server-side equivalent of a client stub

                $\to$ Server stub is a` piece of code, which transforms requests coming in over the network into local procedure calls
        * *Server-side procedure*.
            1. Typically the server stub will call `receive` and be blocked waiting for incoming messages
            2. The server stub unpacks the parameters from the message, then calls the server procedure in the usual way
            3. The server performs its work and returns the result to the caller, i.e. the server stub, in the usual way
            4. When the server stub gets control back, after the call has completed, it packs the result in a message and calls `send` to return it to the client
            5. After this, the server stub usually does a call to `receive` again, to wait for the next incoming request
        * *Server-to-client response procedure*.
            1. When the result message arrives at the client's machine, the OS passes it through the `receive` operation, which had been called previously, to the client sub
            2. The client process is then unblocked
            3. The client stub inspects the message, unpacks the result, copies it to its caller, and returns in the usual way
            4. When the caller gets control following the call to `append`, all it knows is that it appended some data to a list

                $\to$ It has no idea that the work was done remotely at another machine

## Parameter passing
**Parameter marshaling**. The action of packing parameters into a message

$\to$ We need to ensure that the parameters are sent over the network and correctly interpreted by the server
* *Problem 1*. The server will just be seeing a series of bytes coming in, which constitute the original message sent by the client

    $\to$ No additional information on what those bytes mean is normally provided with the message
    * *Consequence*. How should the meta-information be recognized by the server?
* *Problem 2*. We need to handle the case, where the placement of bytes in memory may differe between machine architectures
    * *Example*. We need to account for the fact some machines number their bytes from right to left, whereas many others number them the other way
* *Solution*. 
    * Transform data, which is to be sent, to a machine- and network-independent format

        $\to$ This can be solved using machine-dependent routines transforming data to and from machine- and network-independent formats
    * Make sure that both communicating parties expect the same message data type to be transmitted
        
        $\to$ This can be solved at the level of programming languages
* *Conclusion*. Marshaling and unmarshaling is about the transformation of messages to neutral formats and hence forms an essential part of RPCs

**Passing pointers**. How are pointers, or in general, references passed
* *Problem*. A pointer is meaningful only within the address space of the process, in which it is being used

    $\to$ If the pointer refers to a local data structure, somewhere in the caller's main memory, we cannot simply pass it to the server
    * *Consequence*. The transferred pointer value will most likely be referring to something completely different
* *Solution 1*. Forbid pointers and reference parameters in general
    * *Drawback*. This solution is highly undesirable, in it is often not necessary, i.e.
* *Solution 2*. Reference parameters are often used with fixed-sized data types, e.g. static arrays, or with dynamic data types, for which it is easy to compute their size at runtime, e.g. strings or dynamic arrays

    $\to$ We can simply copy the entire data structure, to which the parameter is referring, effectively replacing the copy-by-reference mechanism by copy-by-value / restore
    * *Optimization*. When the referred data is read-only, there is no need to copy it back when the call has finished
    * *Drawback*. If we are dealing with very large, nested, or otherwise intricate dynamic data structures

        $\to$ Automatic (un)marshaling may not be available, or even desirable
* *Solution 3*. Use pointers to global references, i.e. references which are meaningful to the calling and teh called process
    * *Problems*. 
        * Both processes need to know exactly what to do when a global reference is passed
            * *Explain*. If we consider a global reference having an associated data type, the calling and called processes should have exactly the same picture of the operations, which can be performed
        * Both processes should have agreement on exactly what to do when a file handle is passed
    * *Solution*. The problems above can be solved by proper programming-language support

## RPC-based application support
**Methods to support RPC-based application development**.
* *Option 1*. Let a developer specify exactly what needs to be called remotely, from which complete client-side and server-side stubs can be generated
* *Option 2*. Embed remote procedure calling as part of a programming-language environment

### Stub generation
**Requirements to define a RPC protocol**.
* Message format definition
* Agree on the representation of simple data structures, e.g. integers, characters, Booleans, etc.

    $\to$ This makes messages to be unambiguously interpreted
* The called and callee agree on the actual exchange of messages
    * *Example*. It may be decided to use TCP/IP or UDP for transport-layer protocol

**Implementation of client and server stubs**. Stubs for the same protocol but different procedures normally differ only in their interface to the applications
* *API*. ConistCoo a collection of procedures, which can be called by a client, and which are implemented by a server
    * *Programming languages*. An interface is usually available in the same programming language, as the one used to implement the client or server
* *Interface definition language (IDL)*. Used to specify interfaces, to simplify matters
    * *Examples*. gRPC and protobuf
    * *Idea*. An interface specified in an IDL is then subsequently compiled into a client stub and a server stub, along with the appropriate compile-time or run-time interfaces
    * *Benefits*. Practice shows that using an IDL considerably simplifies client-server applications based on RPCs
        * *Consequence*. Since it is easy to fully generate client and server stubs, all RPC-based middleware systems offer an IDL to support application development

        >**NOTE**. In some cases, using the IDL is even mandatory

### Language-based support
**Language-based support**. Stub generation is largely independent of a specific programming language, but we can embed RPCs into a language itself
* *Benefits*. 
    * Application development becomes much simpler
    * Reaching a high degree of access transparency is often simpler, as many issues related to parameter passing can be circumvented altogether
* *Example*. RPC is fully embedded in Java, where an RPC is referred to as a remote method invocation (RMI)
    * *Idea*. A client being executed by its own JVM can invoke a method of an object managed by another VM

        $\to$ By simply reading an application's source code, it can be hard, or even impossible, to see whether a method invocation is to a local or to a remote object

## Variations on RPC
**Traditional RPC**. When a client calls a remote procedure, the client will block until a reply is returned

$\to$ This is unnecessary when there is no result to return, or may hinder efficiency when multiple RPCs need to be performed

### Asynchronous RPC
**Asynchronous RPCs**. The server, in principle, immediately sends a reply back to the client, at the moment the RPC request is recevied

$\to$ After that, the server locally calls the requested procedure

<div style="text-align:center">
    <img src="https://i.imgur.com/6163xuf.png">
    <figcaption>The interaction between client and server in a traditional RPC (a), and the interaction using asynchronous RPC (b)</figcaption>
</div>

* *Consequence*. The reply acts as an ACK to the client that the server is going to process the RPC

    $\to$ The client will continue without further blocking, as soon as it has received the server's ACK
* *Usage*. When the client does not expect a response from server,  or when a reply will be returned but the client is not prepared to wait for it and do nothing in the meantime

**Deferred synchronous RPC**. The client calls the server, waits for the acceptance, and continues

$\to$ When the results is available, the server sends a response message leading to a callback at the client's side

<div style="text-align:center">
    <img src="https://i.imgur.com/BiewHB6.png">
    <figcaption>A client and server interacting through asynchronous RPCs</figcaption>
</div>

* *Callback*. A user-defined function, which is invoked when a special event happends
    * *Straightforward implementation*. Spawn a separate thread and let it block on the occurrence of the event, while the main process continues

        $\to$ When the event occurs, the thread is unblocked and calls the function

**One-way RPCs**. The client continues executing immediately after sending the request to the server, i.e. the client does not wait for an ACK of the server's acceptance of the request
* *Problem*. When reliability is not guaranteed, the client cannot know for sure whether or not its request will be processed
* *Solution*. The client polls the server to see whether the results are available yet, instead of letting the server calling back the client

### Multicast RPC
**Multicast RPC**. Adopting the one-way RPCs, a multicast RPC boilds down to sending a RPC request to a group of servers

<div style="text-align:center">
    <img src="https://i.imgur.com/16CaCwX.png">
    <figcaption>The principle of multicast RPC</figcaption>
</div>

* *Issues to consider*.
    * The client application may be unaware of the fact that an RPC is actually being forwarded to more than one server
    * What to do with the responses from the servers

## Example - Distributed computing environment (DCE) RPC

# Appendix
## Discussion
**Conventional procedure calls**.

**RPC example in Python**.

**Parameter passing in object-based systems**.

**Language-based RPC in Python**.