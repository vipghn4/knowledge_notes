<!-- TOC titleSize:1 tabSpaces:2 depthFrom:1 depthTo:6 withLinks:1 updateOnSave:1 orderedList:0 skip:0 title:1 charForUnorderedList:* -->
# Table of Contents
- [Table of Contents](#table-of-contents)
- [Remote procedure call](#remote-procedure-call)
  - [Basic RPC operation](#basic-rpc-operation)
- [Appendix](#appendix)
  - [Discussion](#discussion)
<!-- /TOC -->

# Remote procedure call
**Commucation concealation**. In explicit message exchange betwen processes, the operations `send` and `receive` do not conceal communication at all, which is important to achieve access transparency in distributed systems
* *Idea of RPC*. Allow programs to call procedures located on other machines
    * *Explain*. When a process on machine A calls a procedure on machine B, the calling process on A is suspended, and the execution of the called procedure takes place on B
        * *Information propagation*. Information can be transported from the caller to the callee in the parameters and can come back in the procedure result

            $\to$ No message passing is visible to the programmer
* *Problems*.
    * Since the calling and called procedures run on different machines, they execute in different address spaces, causing complications
    * Parameters and results also have to be passed, i.e. complicated, especially if the machines are not identical
    * Either or both machines can crash, and each of the possible failures causes different problems

## Basic RPC operation
**Idea behind RPC**. Make a remote procedure call look as much as possible like a local one, i.e. RPC should be tranparent
* *Explain*. The calling procedure should not be aware that the called procedure is executing on a different machine or vice versa
* *Example*. Suppose that a program has access to a database allowing it to append data to a stored list, after which it returns a reference to the modified list

    ```python
    newlist = append(data, dblist)
    ```

    * *`append` function in traditional single-processor systems*. `append` is extracted from a library by the linker, and inserted into the object program

        >**NOTE**. In principle, it can be a short procedure, which could be implemented by a few file operations for accessing the database

        * *Function invocation*. `append` is called in the usual way, by pushing its parameters onto the stack

            $\to$ The programmer does not know the implementation details of `append`, and this is how it is supposed to be

    * *Transparency of RPC*. 
        1. When `append` is actually a remote procedure, a different version of `append`, called client stub, is offered to the calling client
        2. The client stub does not perform an append operation, but it packs the parameters into a message and requests the message to be sent to the server
        3. When the message arrives at the server, the server's OS passes it to a server stub, which is the server-side equivalent of a client stub

            $\to$ Server stub is a piece of code, which transforms requests coming in over the network into local procedure calls

# Appendix
## Discussion
**Conventional procedure calls**.