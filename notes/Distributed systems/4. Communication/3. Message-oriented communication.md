<!-- TOC titleSize:1 tabSpaces:2 depthFrom:1 depthTo:6 withLinks:1 updateOnSave:1 orderedList:0 skip:0 title:1 charForUnorderedList:* -->
# Table of Contents
- [Table of Contents](#table-of-contents)
- [Message-oriented communication](#message-oriented-communication)
  - [Simple transient messaging with sockets](#simple-transient-messaging-with-sockets)
  - [Advanced transient messaging](#advanced-transient-messaging)
    - [Using messaging patterns - ZeroMQ](#using-messaging-patterns---zeromq)
    - [The message-passing interface (MPI)](#the-message-passing-interface-mpi)
  - [Message-oriented persistent communication](#message-oriented-persistent-communication)
- [Appendix](#appendix)
  - [Discussions](#discussions)
<!-- /TOC -->

# Message-oriented communication
**Access transparency**. RPCs and remote object invocations contribute to hiding communication in distributed systems, i.e. they enhance access transparency
* *Problems*. 
    * When it cannot be assumed that the receiving side is executing at the time a request is issued

        $\to$ Alternative communication services are required
    * The inherent synchronous nature of RPCs, by which a client is blocked until its request has been processed, may need to be replaced by something else

## Simple transient messaging with sockets
**Interface standardization**. Special attention has been paid to standardizing the interface of the transport layer 
* *Purposes*.
    * Allow programmers to make use of its entire suit of messaging protocols through a simple set of operations
    * Standard interfaces make it easier to port an application to a different machine

**Socket interface**.
* *Socket*. A communication end point, to which an application can write data, which are to be sent out over the underlying network, and from which incoming data can be read

    $\to$ A socket forms an abstraction over the actual port, which is used by the local OS for a specific transport protocol
* *Basic operations*.

    | Operation | Description |
    | --- | --- |
    | `socket` | Create a new communication end point |
    | `bind` | Attach a local address to a socket |
    | `listen` | Tell OS what the maximum number of pending connection requests should be |
    | `accept` | Block caller until a connection request arrives |
    | `connect` | Actively attempt to establish a connection |
    | `send` | Send some data over the connection |
    | `receive` | Receive some data over the connection |
    | `close` | Release the connection |


**Server-side operations**. Generally execute the first four operations, normally in the order given
* *Socket creation*. When calling `socket` operation, the caller creates a new communication end point for a specific transport protocol
    * *Connection end point creation*. Internally, creating a communication end point means that the local OS reserves resources for sending and receiving messages for the specified protocol
* *Binding operation*. Associate a local address with the newly created socket

    $\to$ Binding tells the OS that the server wants to receive messages only on the specified address and port
* *Listen operation*. A nonblocking call allowing the local OS to reserve enough buffers for a specified maximum number of pending connection requests, which the caller is willing to accept
    
    $\to$ This is called only in case of connection-oriented communication
* *Accept operation*. Block the caller until a connection request arrives
    * *Request arrival*. When a request arrives, the local OS creates a new socket with the same properties as the original one, and returns it to the caller
        * *Purpose* This allows th server to, e.g. fork off a process, which will subsequently handle the actual communication through the new connection

            $\to$ The server can go back and wait for another connection request on the original socket
    * *Explain*. Refer to TCP connection initiation in socket programming

**Client-side operations**.

<div style="text-align:center">
    <img src="https://i.imgur.com/gMJ9csO.png">
    <figcaption>Connection-oriented communication pattern using sockets</figcaption>
</div>

* *Socket creation*. A socket must be created using `socket` operation, but explicitly binding the socket to a local address is not necessary, since the OS can dynamically allocate a port when the connection is set up
* *Connection setup*. The `connection` operation requires that the caller specifies the transport-level address, to which a conneciton request is to be sent

    $\to$ The client is blocked until a connection has been set up successfully, after which both sides can start exchanging information through the `send` and `receive` operations
* *Connection close*. Closing a connection is symmetric when using sockets, and is established by having both the client and server call the `close` operation

## Advanced transient messaging
**Problems with sockets**. 
* *Problems*.
    * The standard socket-based approach toward transient messaging is very basic and brittle, i.e. a mistake can easily made
    * Sockets essentially support only TCP and UDP, i.e. any extra facility for messaging needs to be implemented separately by an application programminer
* *Consequence*. We often need more advanced approaches for message-oriented communication to make network programming easier

    $\to$ To expand beyond the functionality offered by existing networking protocols, and to make better use of local resources, etc.

### Using messaging patterns - ZeroMQ
**Key observation**. Many messaging applications, or their components, can be effectively organized according to a few simple communication patterns

$\to$ By subsequently providing enhancements to sockets for each of the patterns, it may be easier to develop a networked, distributed application

**ZeroMQ**. Provide sockets, through which all communication takes place

$\to$ Actual message transmission generally takes place over TCP connections, and like TCP, all communication is essentially connection-oriented
* *Key points*. 
    * Setting up, and maintaining connections is kept mostly under the hood, i.e. an application developer need not bother with those issues
    * To further simplify matters, a socket may be bound to multiple addresses, effectively allowing a server to handle messages from very different sources through a single interface

        $\to$ ZeroMQ sockets can support many-to-one communication, instead of one-to-one communication as is the standard Berkeley's sockets
* *Asynchronous communication in ZeroMQ*. A sender will normally continue after having submitted a message to the underlying communication subsystem

    $\to$ Asynchronous communication combined with connection-oriented communication enable a process to request a connection setup, and subsequently send a message, even if the recipient is not yet up-and-running and ready to acccept incoming connection requests
    * *Consequence*. A connection request and subsequent messages are queued at the sender's side
        
        $\to$ There will be separate thread, as part of ZeroMQ's library, will take care that eventually the connection is set up, and messages are transmitted to the recipient
* *Socket pairing*. Simplifying matters, ZeroMQ establishes a higher level of abstraction in socket-based communication by pairing sockets
    * *Pairing sockets*. A specific type of socket used for sending messages is paired with a corresponding socket type for receiving messages

        $\to$ Each pair of socket types corresponds to a communication pattern
    * *Supported patterns*. Request-reply, publish-subscribe, and pipeline

**Request-reply pattern**. Used in traditional client-server communication, like the ones normally used for RPCs
* *Request and reply sockets*.
    * *Request socket*. A client application uses a request socket, i.e. of type REQ, to send a request message to a server

        $\to$ The client expects the server to respond with an appropriate response
    * *Reply socket*. The server is assumed to use a reply socket, i.e. of type REP
* *Benefits*. 
    * This pattern simplifies matters for developers by avoiding the need to call the `listen` operation, and the `accept` operation
    * When a client calls the `recv` operation, after having sent a message, ZeroMQ assumes the client is waiting for a response from the original recipient

**Publish-subscribe pattern**. Clients subscribe to specific messages, which are published by servers
* *Message selection*. Only the messages, to which the client has subscribed, will be transmitted

    $\to$ If a server is publishing messages, to which no one has subscribed, these messages will be lost
* *Simplest form*. This pattern establishes multicasting messages from a server to several clients
    * *Socket types*.
        * The server is assumed to use a socket of type PUB
        * Each client must use SUB type sockets
    * *Client-server connection*. Each client socket is connected to the socket of the server
        * *Default message subscription*. A client subscribes to no specific message by default

            $\to$ There must be explicit subscription

**Pipeline pattern**. A process wants to push out its results, assuming that there are other processes, which want to pull in those results
* *Key idea*. 
    * A pushing process does not care which other process pulls in its results, i.e. the first available one will do just fine
    * Any process pulling in results from multiple other processes will do so from the first pushing process making its results available
* *Purpose*. Keep as many processes working as possible, pushing results through a pipeline of proceses as quickly as possible

### The message-passing interface (MPI)
**Problem**. How to write highly efficient applications
* *Objectives*. 
    * The operations should be at a convenient level of abstraction, i.e. to ease application development
    * The implementation incurs only minimal overhead
* *Problems with sockets*. Sockets were deemed insufficient for several reasons
    * They were at the wrong level of abstraction by supporting only simple send and receive operations
    * Sockets had been designed to communicate across networks using general-purpose protocol stacks, e.g. TCP/IP

        $\to$ They were not considered suitable for the proprietary protocols developed for high-speed interconnection networks, e.g. those used in high-performance server clusters
        * *Explain*. Such protocols required an interface, which could handle more advanced features, e.g. buffering and synchronization
* *Consequence*. Most interconnection networks and high-performance multicomputers were shipped with proprietary communication libraries

    $\to$ These libraries offered a wealth of high-level and generally efficient communication operations
    * *Portability problem*. All libraries were mutually incompatible

**Message passing interface (MPI)**. Result from the need to be hardware and platform independent
* *Idea*. MPI is designed for parallel applications and is tailored to transient communication, making direct use of the underlying network
* *Assumptions*
    * Serious failures, e.g. process crashes or network partitions, are fatal and do not require automatic recovery
    * Communication takes place within a known group of processes
    * There may be several, possibly overlapping groups of processes involved in a computation, which are executing at the same time
* *Group and process identifiers*. A `(groupID, processID)` pair uniquely identifies the source or destination of a message, and is used instead of a transport-level address
    * Each group is assigned an identifier
    * Each process within a group is assigned a local identifier
* *MPI core*. Consist of messaging operations to support transient communication

    | Operation | Description |
    | --- | --- |
    | `MPI_bsend` | Append outgoing message to a local send buffer |
    | `MPI_send` | Send a message and wait until copied to local or remote buffer |
    | `MPI_ssend` | Send a message and wait until transmission starts |
    | `MPI_sendrecv` | Send a message and wait for reply |
    | `MPI_isend` | Pass reference to outgoing message, and continue |
    | `MPI_issend` | Pass reference to outgoing message, and wait until receipt starts |
    | `MPI_recv` | Receive a message, block if there is one |
    | `MPI_irecv` | Check if there is an incoming message, but do not block |


**MPI operations**.
* *`MPI_bsend`*. Support transient asynchronous communication
    * *Explain*. 
        1. The sender submits a message for transmission, which is generally first copied to a local buffer in the MPI runtime system

            $\to$ When the message has been copied, the sender continues
        2. The local MPI runtime system will remove the message from its local buffer, and take care of transmission as soon as a receiver has called a receive operation
* *`MPI_send`*. A blocking send operation, of which the semantics are implementation dependent
    * *Blocking*. The operation may either block the caller, until the specified message has been copied to the MPI runtime system at the sender's side, or until the receiver has initiated a receiver operation
* *`MPI_ssend`*. Synchronous communication, by which the sender blocks until its request is accepted for further processing
* *`MPI_sendrecv`*. The strongest form of synchronous communication, i.e. when a sender calls `MPI_sendrecv`

    $\to$ It sends a rquest to the receiver and blocks until the receiver returns a reply, i.e. this operation corresponds to a normal RPC
* *`MPI_isend` and `MPI_issend`*. Both `MPI_send` and `MPI_ssend` have variants which avoid copying messages from user buffers to buffers internal to the local MPI system
    * *`MPI_isend`*. A sender passes a pointer to the message, after which the MPI runtime system takes care of communication

        $\to$ The sender immediately continues
        * *Message overwriting prevention*. To prevent overwriting the message before communication completes, MPI offers operations to check for completion, or to block if required
        * *Consequence*. Whether the message has actually been transferred to the receiver, or that it has merely been copied by the local MPI runtime system to an internal buffer, is left unspecified
    * *`MPI_issend`*. A sender passes only a pointer to the MPI runtime system
        * *Idea*. When the runtime system indicates that it has processed the message

            $\to$ The sender is then guaranteed that the receiver has accepted the message, and is now working on it
* *`MPI_recv`*. Used to receive a message, i.e. it blocks the caller until a message arrives
* *`MPI_irecv`*. A receiver indicates that it is prepared to accept a message, then it can check whether or not a message has arrived, or block until one does

**Benefits of MPI**. MPI gives implementers of MPI systems enough possibilities for optimizing performance

## Message-oriented persistent communication

# Appendix
## Discussions
**A simple socket-based client-server system**.

**A simple socket-based client-server system**.

**Implementing stubs as global references**.

**The request-reply pattern**.

**The pipeline pattern**.