<!-- TOC titleSize:1 tabSpaces:2 depthFrom:1 depthTo:6 withLinks:1 updateOnSave:1 orderedList:0 skip:0 title:1 charForUnorderedList:* -->
# Table of Contents
- [Table of Contents](#table-of-contents)
- [Servers](#servers)
  - [General design issues](#general-design-issues)
    - [Concurrent versus iterative servers](#concurrent-versus-iterative-servers)
    - [Contacting a server - end points](#contacting-a-server---end-points)
    - [Interrupting a server](#interrupting-a-server)
    - [Stateless versus stateful servers](#stateless-versus-stateful-servers)
<!-- /TOC -->

# Servers
## General design issues
**Server**. A process implementing a specific service on behalf of a collection of clients

$\to$ In essence, each server is organized in the same way, i.e. it waits for an incoming request from a client and subsequently ensures that the request is served

### Concurrent versus iterative servers
**Types of servers**.
* *Iterative server*. The server handles the request and, if required, returns a response to the requesting client
* *Concurrent server*. Do not handle the request, but pass it to a separate thread or another process, after which it immediately wait for the next incoming request
    * *Examples*.
        * Multithreaded server
        * A server, which forks a new process for each new incoming request

            $\to$ This is followed in many Unix systems
    * *Consequence*. The thread or process handling the request is responsible for returning a response to the requesting client

### Contacting a server - end points
**Contact points of a server**. 
* *Idea*.
    * Clients send request to an end point, i.e. a port, at the matching hosting the server
    * Each server listens to a specific end point
* *Clients getting to know service end points*.
    * *Option 1*. Globally assign end points for well-known services

        $\to$ The client needs to find only the network address of the server machine, using name services
        * *Examples*. Port 21 for FTP requiests, and port 80 for HTTP requests
    * *Option 2*. No global end points for the service, i.e. a client needs to look up the end point

        <div style="text-align:center">
            <img src="https://i.imgur.com/lPKB2F3.png">
            <figcaption>Client-to-server binding using a daemon (a), and client-to-server binding using a superserver (b)</figcaption>
        </div>

        * *Solution*. Have a special daemon running on each machine, which runs the server, to keep track oif the current end point of each service implemented by a co-located server
            * *Daemon end point*. The daemon listens to a well-known end point

                $\to$ The client contacts the daemon, requests the end point, then contacts the specific server
    * *Option 3*. Use a superserver listening to each end point associated with a specific service
        * *Motivation*. It is common to associate an end point with a specific service, but implementing each service by means of a separate server may waste resources
            * *Example*. In a typical Unix system, it is common to have lots of servers running simultaneously, with most of them passively waiting for a client request

                $\to$ Using a superserver removes the burden of keeping track so many passive processes
        * *Example*. The `inetd` daemon in Unix listens to a number of well-known ports for Internet services
            * *Request processing*. When a request comes in, the daemon forks a process to handle it, which will exit when finished

### Interrupting a server
**Question**. Whether and how a server can be interrupted

**Option 1**. Work only too well in the current Internet, and is sometimes the only alternative
* *Idea*. The user abruptly exit the client application, which will automatically break the connection to the server, immediately restart it, and pretend nothing happened

    $\to$ The server will eventually tear down the old connection, thinking the client has probably crashed

**Option 2**. Develop the client and server, so that it is possible to send out-of-band data
* *Out-of-band data*. Data which is to be processed by the server, before any other data from the client
* *Implementation approaches*.
    * *Option 1*. Let the server listen to a separate control end point, to which the client sends out-of-band data

        $\to$ At the same time, the server listens, with a lower priority, to the end point, through which the normal data passes
    * *Option 2*. Send out-of-band data across the same connection, through which the client is sending the original request

        $\to$ When urgen data are received at the server, the original data is interrupted, through a signal in Unix system, after which it can inspect the data and handle them accordingly

### Stateless versus stateful servers
**Question**. Whether or not the server is stateless

**Stateless server**. Do not keep information on the state of the clients, and can change its own state without having to inform any client

$\to$ It merely responds to incoming requests, handle them, and forgets the client completely
* *Maintaining client information*. In many stateless designs, the server actually does maintain information on its clients

    $\to$ However, if this information is lost, it will not lead to a disruption of the server offered by the server
* *Soft state*. A particular form of a stateless design
    * *Idea*. The server promises to maintain state on behalf of the client, but only for a limited time

        $\to$ After the time has expired, the server falls back to default behavior, discarding any information it kept on account of the associated client
    * *History*. Originate from protocol design in computer networks

**Stateful server**. Generally maintain persistent information on its clients

$\to$ The information needs to be explicitly deleted by the server
* *Benefits*. Improve the performance of read and write operations as perceived by the client
* *Drawback*. If the server crashes, it has to recover its entire state, as it was just before the crash

    $\to$ Enabling recovery can introduce considerable compplexity
* *Session (temporary) state and permanent state*.
    * *Session state*. Associated with a series of operations by a single user, and should be maintained for some time, but not infinitely

        $\to$ Session state is often maintained in three-tiered client-server architectures
        * *Three-tiered client-server architectures*. The application server actually needs to access a database server, through a series of queries, before being able to respond to the requesting client
        * *State lost*. There is no real harm if session state is lost, provided that the client can simply re-issue the original request

            $\to$ This allows for simpler and less reliable storage of state
    * *Permanent state*. Information is maintained in databases

**Client state and provided service**. The choice of a stateless or stateful design should not affect the services provided by the server

**Cookie**. A server may want to keep a record on a client's behavior, so that it can more effectively respond to its requests
* *Common solution*. When the server cannot maintain state, the client sends along additional information on its previous accesses
    * *Example*. In Web, this information is often transparently stored by the client's browser in a cookie
* *Cookie*. A small piece of data containing client-specific information of interest to the server

    >**NOTE**. Cookies are never executed by a browser, they are merely stored

* *Idea*. The first time a client accesses a server, the server sends a cookie along with the requested Web pages back to the browser

    $\to$ The browser then safely tucks the cookie away
    * *Consequence*. Each subsequent time the client accesses the server, its cookie for the server is sent along with the request