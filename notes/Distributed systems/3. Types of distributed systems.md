<!-- TOC titleSize:1 tabSpaces:2 depthFrom:1 depthTo:6 withLinks:1 updateOnSave:1 orderedList:0 skip:0 title:1 charForUnorderedList:* -->
# Table of Contents
- [Table of Contents](#table-of-contents)
- [Types of distributed systems](#types-of-distributed-systems)
  - [High performance distributed computing](#high-performance-distributed-computing)
    - [Cluster computing](#cluster-computing)
    - [Grid computing](#grid-computing)
    - [Cloud computing](#cloud-computing)
  - [Distributed information systems](#distributed-information-systems)
    - [Distributed transaction processing](#distributed-transaction-processing)
    - [Enterprise application integration](#enterprise-application-integration)
  - [Pervasive systems](#pervasive-systems)
    - [Ubiquitous computing systems](#ubiquitous-computing-systems)
      - [Distribution](#distribution)
      - [Interaction](#interaction)
      - [Context awareness](#context-awareness)
      - [Autonomy](#autonomy)
      - [Intelligence](#intelligence)
    - [Mobile systems](#mobile-systems)
    - [Sensor networks](#sensor-networks)
- [Appendix](#appendix)
  - [Concepts](#concepts)
  - [Discussion](#discussion)
<!-- /TOC -->

# Types of distributed systems
## High performance distributed computing
**High performance distributed computing**. A class of distributed systems used for high-performance computing tasks
* *Cluster computing*. The underlying hardware consists of a collection of similar workstations or PCs running the same OS, closely connected by means of a high-speed LAN
* *Grid computing*. Consist of distributed systems which are often constructed as a federation of computer systems
    
    $\to$ Each computer system may fall under a different administrative domain, and may be very different when it comes to hardware, software. and deployed network technology
* *Cloud computing*. From the perspective of grid computing, a next logical step is to simply outsource the entire infrastructure needed for compute-intensive applications

    $\to$ This is what cloud computing is all about
    * *Idea*. Provide the facilities to dynamically construct an infrastructure and compose what required from available services
    * *Differences from grid computing*. 
        * Grid computing is strongly associated with high-perofmrance computing
        * Cloud computing is much more than just providing lots of resources

### Cluster computing
**Cluster computing**. Used for parallel programming, in which a single, compute intensive program is run in parallel on multiple machines

**Linux-based Beowulf clusters**. Example of a cluster computer

<div style="text-align:center">
    <img src="https://i.imgur.com/l9onMHm.png">
    <figcaption>An example of a cluster computing system</figcaption>
</div>

* *Cluster structure*. Each cluster consists of a collection of compute nodes, which are controlled and accessed by means of a single master node
    * *Master node*. Typically 
        * Handle the allocation of nodes to a particular parallel program
        * Maintain a batch queue of submitted jobs
        * Provide an interface for the users of the system
    * *Middleware for program execution and cluster management*. Actually run by the master
    * *Slave nodes*. Compute nodes equipped with a standard OS extended with typical middleware functions for communication, storage, fault tolerance, etc.

        $\to$ Apart from the master node, the compute nodes are seen to be highly identical

**The MOSIX system**. Example of a cluster compute, which attempts to provide a single-system image of a cluster

$\to$ To a process, a cluster computer offers the ultimate distribution transparency by appearing to be a single computer
* *Idea*. MOSIX provides the high degree of transparency by allowing processes to dynamically and preemptively migrate betwen the nodes making up the cluster
* *Consequence*. Process migration allows a user to start an application on any node, i.e. referred as the home node

    $\to$ After which, it can transparently move to other nodes, e.g. to make efficient use of resources

**Hybrid solutions for modern cluster**. Several modern cluster computers have been moving away from the symmetric architectures to more hybrid solution
* *Symmetric architectures*. Architectures which are fully decentralized
    * *Example*. Fully distributed file systems do not distinguished between the client machines and servers
    * *Idea*. Most proposed systems are based on a distributed hash table (DHT) approach for data distribution across nodes
* *Idea*. The middleware is functionally partitioned across different nodes
* *Advantage*. Having compute nodes with dedicated, lightweight OSes will most likely provide optimal performance for compute-intensive applications
    * *Example*. Storage functionality can most likely be optically handled by other specially configured nodes, e.g. file and directory servers

        $\to$ The same holds for other dedicated middleware services, e.g. job management, database services, etc.
* *Consequence*. This leads to grid computing

### Grid computing
**Motivation**. As previously discussed, there has been a trend towards more hybrid architectures, in which nodes are specially configured for certain tasks
* *Advantage of grid computing*. No assumptions are made concerning similarity of hardware, OSes, networks, administrative domains, security policies, etc.

**Key issue in grid computing**. Resources from different organizations are brought together to allow the collaboration of a group of people from different institutions

$\to$ This forms a federation of systems
* *Virtual organization*. Such a collaboration described above
    * *Access rights*. Processes belonging to the same virtual organization have access rights to the resources provided to that organization
    * *Organization's resources*. Typically computer servers, storage facilities, databases, special networked devices, etc.
* *Consequence*. Much of the software for realizing grid computing evolves around providing access to resources from different administrative domains, and to only those users and applications belonging to a specific virtual organization

    $\to$ Focus is often on architectural issues

**Founding architecture for many grid computing systems**. The architecture consists of four layers

<div style="text-align:center">
    <img src="https://i.imgur.com/T7hmJ87.png">
    <figcaption>A layered architecture for grid computing systems</figcaption>
</div>

* *Fabric layer*. Provide the resources, to which shared access is mediated by grid protocols
    * *Responsibilities*. Provide interfaces to local resources at a specific site
        * *Explain*. Implement the local, resource-specific operations which occur on specific resources, as a result of sharing operations at higher levels

        >**NOTE**. These interfaces are tailored to allow sharing of resources within a virtual organization

    * *Typically provided functions*. 
        * Query the state and capabilities of a resource
        * Functions for actual resource management, e.g. locking resources
* *Connectivity layer*. Consist of communication protocols for supporting grid transactions spanning the usage of multiple resources
    * *Example provided protocols*.
        * Protocols required to transfer data between resources in the fabric layer
        * Protocols required to simply access a resource from a remote location
        * Security protocols to authenticate users and resources

            >**NOTE**. In many cases, human users are not authenticated, but program acting on behalf of the users are authenticated
            >$\to$ Delegating rights from a user to programs is an important function required to be supported in the connectivity layer

* *Resource layer*. Responsible for managing a single resource
    * *Idea*. Use the functions provided by the connectivity layer and calls directly the interfaces provided by the fabric layer
        * *Explain*. 
            * Build on connectivity layer communication and authentication protocols 
            
                $\to$ To provide protocols, APIs, and SDKs, for secure initiation, monitoring, and control of sharing operations on individual resources
            * Call fabric layer functions to access and control local resources

        >**NOTE**. Resource layer protocols are concerned entirely with individual resources, and ignore issues of global state and atomic actions across distributed collections
        >$\to$ Such issues are the concern of the collective layer

    * *Protocols provided*. This layer may offer functions for 
        * *Information protocols*. Obtaining configuration information, current load, usage policy, etc. on a specific resource
        * *Management protocols*.
            * Negotiate access to a shared resource
            * Specify, for example resource requirements, and the operations to be performed, e.g. creating a process or reading data
    * *Consequence*. This layer is seen to be responsible for access control

        $\to$ This layer will rely on the authentication performed as part of the connectivity layer
* *Collective layer*. Deal with handling access to multiple resources
    * *Typically provided services*. Resource discovery, allocation, and scheduling tasks onto multiple resources, data replication, etc.
    * *"Collective" meanings*. This layer indicates that the hardware and software resources are aggregated to run the user applications under the collective operations
* *Application layer*. Consist of the applications operating within a virtual organization, and make use of the grid computing environment

>**NOTE**. Typically, the collective, connectivity, and resource layer form the heart of what could be called wa grid middleware layer
>* *Explain*. These layers jointly provide access to and management of resources which are potentially dispersed across multiple sites

**Similarities between grid computing layers and Internet protocol layers**.

| Grid computing layer | Internet protocol layer |
| --- | --- |
| Application | Application |
| Collective | Application |
| Resource | Application |
| Connectivity | Transport |
| Connectivity | Internet |
| Fabric | Link |

**Administrative unit in grid computing**. From a middleware perspective, in grid computing, the notion of a site, or administrative unit, is common

$\to$ This prevalance is emphasized by the gradual shift toward a service-oriented architecture
* *Service-oriented architecture*. Architecture, in which sites offer access to the various layers through a collection of Web services

    $\to$ This lead to the definition of an alternative architecture known as the Open grid service architecture (OGSA)
* *Open grid service architecture*. Based on the original ideas of four-layer architecture above, and go through a standardization process, thus the architecture is complex
    
    >**NOTE**. OGSA implementations generally follow Web service standards

### Cloud computing
**Problem with computational grids**. Organizations in charge of running data centers were facing the problem of opening up their resources to customers

$t\to$ This lead to the concept of utility computing
* *Utility computing*. A customer can upload tasks to a data center and be charged on a per-resource basis

    $\to$ This is the basis for cloud computing

**Cloud computing**. Characterized by an easily usable and accessible pool of virtualized resources

<div style="text-align:center">
    <img src="https://i.imgur.com/TzshR5e.png">
    <figcaption>The organization of clouds</figcaption>
</div>

* *Idea*. Which and how resources are used can be configured dynamically, providing the basis for scalability, i.e. if more work needs to be done, a customer can simply acquire more resources
* *Relation to utility computing*. Cloud computing is generally based on a pay-per-use model, in which guarantees are offered by means of customized service level agreements (SLAs)

**Layers of cloud architecture**. 
* *Hardware*. Formed by the means to manage the necessary hardware, e.g. processors, routers, power, cooling systems, etc.

    $\to$ It is generally implemented at data centers and contains the resources which customers normally never get to see directly
* *Infrastructure*. The backbone for most cloud computing platforms
    * *Responsibility*. Deploy virtualization techniques to provide customers an infrastructure consisting of virtual storage and computing resources

    >**NOTE**. Indeed, cloud computing evolves around allocating and managing virtual storage devices and virtual servers

* *Platform*. Provide to a customer what an OS provides to application developers

    $\to$ The platform layer provides the means to easily develop and deploy applications required to run in a cloud
    * *Practical idea*. 
        * An application developer is offered a vendor-specific API, which includes calls to uploading and executing a program in that vendor's cloud

            $\to$ This is similar to `exec` in Linux, which takes an executable file as parameter and passes it to the OS to be executed
        * The layer provides higher-level abstractions for storage and such, e.g. AMZ S3 storage system provides an API allowing files to be organized and stored in buckets
            * *Bucket*. Somewhat comparable to a directory
* *Application*. Actual applications run in this layer and are offered to users for further customization
      * *Execution*. The applications are executed in the vendor's cloud

**Cloud interfaces**. Cloud-computing providers offer the layers to their customers through various interfaces, leading to several types of services
* *Infrastructure-as-a-Service (IaaS)*. Cover the hardware and infrastructure layer
* *Platform-as-a-Service (PaaS)*. Cover the platform layer
* *Software-as-a-Service (SaaS)*. Cover the application layer

**Problems with cloud computing**. 
* Provider lock-in ,security and privary issues, and dependency on the availability of services
* The details on how specific cloud computations are actually carried out are generally hidden, even unknown or unpredictable

    $\to$ Meeting performance demands may be impossible to arrange in advance
* Different provides may easily show very different performance profiles

**Future of cloud computing**. Cloud computing is a serious alternative to maintaining huge local infrastructures, thus there is still a lot of room for improvement

## Distributed information systems
**Distributed information systems**. A technique of implementing a single logical set of processing functions across a number of phyhsical devices

$\to$ Each device performs some part of the total processing required
* *Usage*. Found in organizations confronted with a wealth of networked applications, for which interoperability turned out to be a painful experience
* *Problem*. Many of the existing middleware solutions are the results of working with an infrastructure, in which it was easier to integrate applications into an enterprise-wide information system

**Integration levels**. 
* *Lowest level*. A networked application consists of a server running the application, often including a database
    
    $\to$ The server is made available to remote programs, called clients
    * *Clients*. Send a request to the server for executing a specific operation, after which a response is sent back
    * *Integration*. Allow clients to wrap a number of requests, possibly for different servers, into a single larger request

        $\to$ The request is then executed as a distributed transaction
    * *Key idea*. All or none of the requests are executed
* *Higher level*. As applications become more sophisticated and are gradually separated into independent components, e.g. database components and processing components
    * *Integration*. Let applications communicate directly with each other

        $\to$ This leads to a huge industry concentrating on Enterprise application integration (EAI)

### Distributed transaction processing
**Transaction**. In practice, operations on a database are carried out in the form of transactions
* *Primitives for transactions*. Programming using transactions requires special primitives, which must be supplied by the underlying distributed system, or by the language runtime system
    * *Typical examples of transaction primitives*. 

        | Primitive | Description |
        | --- | --- |
        | `BEGIN_TRANSACTION` | Mark the start of a transaction |
        | `END_TRANSACTION` | Terminate the transaction and try to commit |
        | `ABORT_TRANSACTION` | Kill the transaction and restore the old values |
        | `READ` | Read data from a file, a table, or otherwise |
        | `WRITE` | Write data to a file, a table, or otherwise |
    
    * *The exact list of primitives*. Depend on the type of objects being used in the transaction
        * *Example*. In a mail system, there might be primitives to send, receive, and forward mail

    >**NOTE**. Ordinary statements, procedure calls, etc. are also allowed inside a transaction

    * *Transactional RPC*. RPC encapsulated in a transaction
* *ACID*. Transactions adhere to the so-called ACID properties
    * *Atomic*. To the outside world, the transaction happens indivisibly
    * *Consistent*. The transaction does not violate system invariants
    * *Isolated*. Concurrent transactions do not interfere with each other
    * *Durable*. Once a transaction commits, the changes are permanent

**Nested transaction**. In distributed systems, transactions are often constructed as a number of subtractions, jointly forming a nested transaction
* *Idea*.
    * The top-level transaction may fork off children running in parallel with one another, on different machines

        $\to$ This is to gain performance or simplify programming
    * Each of the children may also execute one or more subtransactions, or fork off its own children
* *Problem with subtransactions*. 
    * *Scenario*. A transaction starts several subtransactions in parallel
        * One of the subtransactions commits, making its result visible to the parent transaction
        * After further computation, the parent aborts, restoring the entire system to the state it had before the top-level transaction started
    * *Consequence*. The results of the commited subtransaction must be undone

        $\to$ The permanence property applies only to top-level transactions
    * *Problem*. Since transactions can be nested arbitrarily deep, considerable administration is required to get everything right
* *Implementation*. When any transaction or subtransaction starts
    
    $\to$ It is conceptually given a private copy of all data in the entire system for it to manipulate as it wishes
    * *Idea*.
        * If the subtransaction aborts, its private universe vanishes, as if it had never existed
        * If the subtransaction commits, its private universe replaces the parent's universe

            $\to$ If a subtransaction commits, then a new subtransaction is started, the second one sees the results produced by the first one
    * *Consequence*. 
        * If an enclosing transaction aborts, all its underlying subtransactions have to be aborted
        * If several transactions are started concurrently, the result is as if they ran sequentially in some unspecified order
* *Importance in distributed systems*. Nested transactions provide a natural way of distributing a transaction across multiple machines
    * *Explain*. Multiple machines follow a logical division of the work of the original transaction

**Transaction processing monitor (TP monitor)**. The component handling distributed (or nested) transactions

<div style="text-align:center">
    <img src="https://i.imgur.com/0KfErNE.png">
    <figcaption>The role of TP monitor in distributed systems</figcaption>
</div>

* *Role in distributed systems*. In the early days of enterprise middleware systems, TP monitor formed the core for integrating applications at the server or database level
* *Responsibilities*. Allow an application to access multiple servers or databases by offering it a transaction programming model

    $\to$ Eseentially, the TP monitor coordinates the commitment of subtransactions following a distributed commit
    * *Distributed commit*. A standard protocol for coordinating commitment of subtransactions
* *Benefits*. Applications wanting to coordinate several subtransactions into a single transaction did not have to implement the coordination of subtransactions
    * *Explain*. By simply making use of a TP monitor, the coordination was done for them
    * *Consequence*. TP monitor is part of the middleware, i.e. implement services useful for many applications avoiding that such services have to be reimplemented many times by application developers

### Enterprise application integration
**Problem**. The more applications become decoupled from the databases they were built upon

$\to$ Facilities are needed to integrate applications independently from their database

<div style="text-align:center">
    <img src="https://i.imgur.com/4mdLNTB.png">
    <figcaption>Middleware as a communication facilitator in enterprise application integration</figcaption>
</div>

* *Explain*. Application components should be able to communicate directly with each other, and not merely by means of the request-reply behavior supported by transaction processing systems
* *Communication models*. The need for interapplication communication lead to many different communication models
    * *Main idea*. Existing applications could directly exchange information

**RPC and RMI**. Several types of communication exist
* *Remote procedure calls (RPCs)*. An application component can effectively send a request to another application component via a local procedure call
    * *Idea*.
        * The call results in the request being packaged as a message and sent to the callee
        * The result is sent back and returned to the application as the result of the procedure call
* *Remote method invocations (RMIs)*. Essentially the same as RPC, but it operates on objects, instead of functions

    $\to$ RPC is like distributed functional programming, and RMI is like distributed OOP
* *Drawbacks*. The caller and the callee must be tightly coupled, which is a serious drawback
    * The caller and callee both need to be up and running at the time of communication
    * The caller and callee both need to know exactly how to refer to each other

**Message-oriented middleware (MOM)**. Born to fix the problem of tightly coupled components of RPC and RMI
* *Idea*. Applications send messages to logical contact points, often described by means of a subject

    $\to$ The communication middleware will take care that the messages are delivered to the applications

>**NOTE**. This model is also called publish/subscribe model, and is forming an important and expanding class of distributed systems

## Pervasive systems
**Problem**. Previous distributed systems are largely characterized by their stability, i.e. nodes are fixed and have a more or less permanent and high-quality connection to a network

$\to$ Since the introduction of mobile and embedded devices, pervasive systems appeared
* *Pervasive systems*. Intended to naturally blend into our environment

**Pervasive systems**. A computing system which is available everywhere within a company, i.e. the growing trend of embedding computational capability, generally in the form of microprocessors, into everyday objects

$\to$ The separation of users and system components is much more blurred, compared to computing and information systems
* *Interfaces to pervasive systems*. There is no single dedicated interface, e.g. screen-keyboard combination
    * *Sensors*. A pervasive system is often equipped with many sensors pikcing up various aspects of a user's behavior
    * *Actuators*. A pervasive system may have a lot of actuators providing information and feedback, often even purposefully aiming to steer behavior
* *Characteristics*. Small, battery-powered, mobile, and having only a wireless connection

    $\to$ Wireless and mobile communication will require special solutions to make a pervasive system as transparent or unobtrusive as possible

**Types of pervasive systems**. The three types will be given in details below
* Ubiquitous computing system
* Mobile system
* Sensor network

### Ubiquitous computing systems
**Ubiquitous computing systems**. The system is pervasive and continuously present, i.e. a user will be continuously interacting with the system, often not even being aware that interaction is taking place
* *Core requirements for a ubiquitous computing system*.
    * *Distribution*. Devices are networked, distributed, and accessible in a transparent manner
    * *Interaction*. Interaction between useers and devices is highly unobtrusive
    * *Context awareness*. The system is aware of a user's context to optimize interaction
    * *Autonomy*. Device operate autonomously without human intervention, and are thus highly self-managed
    * *Intelligence*. The system as a whole can handle a wide range of dynamic actions and interactions

#### Distribution
**Distribution requirement**. The devices and other computers form the nodes of a system which are simply networked and work together to form the illusion of a single coherent system
* *More natural view*. There will be devices close to users, e.g. sensors and actuators, connected to computers hidden from view and perhaps even operating remotely in a cloud

    $\to$ Most, if not all, of the requirements regarding distribution transparency should hold

#### Interaction
**Interaction requirement**. End users play a prominent role in the design of ubiquitous systems, i.e. special attention needs to be paid to how the interaction between users and core system takes place
* *Implicit action*. For ubiquitous computing systems, much of the interaction by humans will be implicit

    $\to$ A user could be mostly unaware of the fact that input is being provided to a computer system
* *Hidden interface*. Ubiquitous computing is said to seemingly hide interfaces

#### Context awareness
**Context requirement**. A ubiquitous computing system needs to take the context, in which interactions take place, into account
* *Characterization of context in practice*. Location, identity, time, and activity, i.e. where, who, when, and what

    $\to$ A system will need to have the necessary, i.e. sensory, input to determine one or several of these context types
* *Processing place*. Raw data collected by various sensors is lefted to a level of abstraction which can be used by applications

    $\to$ Where this processing of sensory input take place, e.g. central server or user's smartphone

#### Autonomy
**System management**. An important aspect of most ubiquitous computing systems is that explicit systems management has been reduced to a minimum
* *Explain*. There is no room for a systems administrator to keep everything up and running

    $\to$ The system as a whole should be able to act autonomously, and automatically react to changes

#### Intelligence
**Intelligence requirement**. Ubiquitous computing systems often use methods and techniques from the field of AI

$\to$ The extent to which this can or should be done in a distributed fashion is crucial from the perspective of distributed systems

### Mobile systems

### Sensor networks

# Appendix
## Concepts
**Parallel processing**. High-performance computing more or less started with the introduction of multiprocessor machines

$\to$ Multiple CPUs are organized so that they all have access to the same physical memory
* *Difference from multicomputer system*. In multicomputer systems, several computers are connected through a network, and there is no sharing of main memory
    * *Benefits of shared memory model*. Proved to be highly convenient for improving the performance of programs, and it was relatively easy to program
* *Essence of parallel computing*. Multiple threads of control are executing at the same time, while all threads have access to shared data
    * *Data access*. Controlled through well-understood synchronization mechanisms, e.g. semaphores
    * *Drawback*. The model of shared-memory system does not easily scale
* *High-performance distributed computing*. To overcome the limitations of shared-memory model

    $\to$ Many programs had to make use of message passing instead of modifying shared data as means of communication and synchronization between threads
    * *Message passing model's drawbacks*. Error-prone and much more difficult compared to shared-memory programming models
    * *Consequence*. There has been significant research in attempting to build distributed shared-memory multicomputers (DSM system)
* *DSM system*. Allow a process to address a memory location at another computer, as if it were local memory
    
    $\to$ This can be achieved using existing techniques available to the OS, e.g. memory mapping
    * *Problem*. The performance could never meet the expectations of programmers

        $\to$ Programmers resort to performing message-passing programming models

**Four ways to intergrate applications**. Application integration is generally not siple

$\to$ But middleware can significantly help by providing the right facilities, e.g. support for RPCs for messaging
* *File transfer*. An application produces a file containing shared data, which is subsequently read by other applications
    * *Pros*. Technically very simple, thus appealing
    * *Cons*. There are lots of things to be agreed upon
        * *File format and layout*. XML has become popular as its files are, in principle, self-describing
        * *File management*. Where are they stored, how are they named, who is responsible for deleting files?
        * *Update propagation*. When an application produces a file, there may be several applications needing to read that file to provide a view of single coherent system

            $\to$ Sometimes, separate programs need to be implemented to notify applications of file updates
* *Shared database*. Solve many problems of integration through files
    * *Idea*. All applications have access to the same data, e.g. SQL database
    * *Pros*. Easy to notify applications when changes occur, as triggers are often part of modern databases
    * *Cons*.
        * There is still a need to design a common data schema, which may be far from trivial of the set of applications to be integrated is not known in advance
        * When there are many reads an updates, a shared database can easily become a performance bottleneck
* *RPC*. 
    * *Drawback of shared databases*. Assume that changes by one application can easily trigger other applications to take action
    * *Idea of RPC*. Practice shows that sometimes small changes should actually trigger many applications to take actions

        $\to$ In such cases, it is not really the change of data is important, but the execution of a series of actions
    * *Motivation*. Series of actions are best captured through the execution of a procedure
        * *Consequence*. Present that every application needs to know all the internals of the actions, as implemented by another application

            $\to$ Standard encapsulation techniques should be used, as deployed with RPCs or RMIs
* *Messaging*. Described previously

## Discussion
**Is cloud computing cheaper**.

**Distributed transaction processing vs enterprise application integration**.
* *Distributed transaction processing*. Focus on interoperability of distributed databases or servers
* *Enterprise application integration*. Focus on interoperability of distributed clients or application components