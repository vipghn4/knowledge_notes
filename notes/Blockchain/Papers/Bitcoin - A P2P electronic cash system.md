<!-- TOC titleSize:1 tabSpaces:2 depthFrom:1 depthTo:6 withLinks:1 updateOnSave:1 orderedList:0 skip:0 title:1 charForUnorderedList:* -->
# Table of Contents
- [Table of Contents](#table-of-contents)
- [Bitcoin - A P2P electronic cash system](#bitcoin---a-p2p-electronic-cash-system)
  - [Introduction](#introduction)
  - [Transaction](#transaction)
  - [Timestamp server](#timestamp-server)
  - [Proof-of-Work](#proof-of-work)
  - [Network](#network)
  - [Incentive](#incentive)
  - [Reclaiming the disk](#reclaiming-the-disk)
  - [Simplified payment verification](#simplified-payment-verification)
- [Appendix](#appendix)
  - [Concepts](#concepts)
  - [Discussion](#discussion)
<!-- /TOC -->

# Bitcoin - A P2P electronic cash system
## Introduction
**Problem with e-commerce**. Rely almost exclusively on financial institutions serving as trusted third parties to process electronic payments
* *Pros*. The system works well enough for most transactions
* *Cons*.
    * The still suffers from the inherent weaknesses of the trust based model
    * Completely non-reversible transactions are not really possible, since financial institutions cannot avoid mediating disputes
    * The cost of mediation increases transaction costs, limiting the minimum practical transaction size, and cutting off the possibility for small causal transactions
    * There is a broader cost in the loss of ability to make non-reversible payments for non-reversible services
    * With the possibility of reversal, the need for trust spreads
        
        $\to$ Merchants must be wary of their customers, hassling them for more information than they would otherwise need
    * A certain percentage of fraud is accepted as unavoidable
* *Existing solution*. Use physical currency, i.e. no mechanism exists to make payments over a communications channel without a trusted party

**Desired solution**. An electronic payment system based on cryptographic proof, rather than trust

$\to$ This allows any two willing parties to transact directly with each other, without the need for a trusted third party
* *Computationally irreversible transactions*. Protect sellers from fraud, and routine escrow mechanisms could be easily be implemented to protect buyers
* *Requirements for security*. Honest nodes collectively control more CPU power than any cooperating group of attacker nodes

## Transaction
**Transaction (tx)**. A transfer of bitcoin value from one or more inputs to one or more outputs
* *Number of I/O*. A bitcoin transaction can have many inputs and many outputs
    * *Explain*. Bitcoin has a transaction oriented logic, where amounts are transferred from previous transactions
        * *Example 1*. Neglecting the fees, to be able to spend 1 bitcoin
            * When the wallet has 2 previous tx with amounts of 0.5 BTC
                
                $\to$ A new tx is created with two inputs
            * Same logic would apply, if 4 previous tx existed, each @0.25 BTC
                
                $\to$ A tx with 4 inputs would be created
        * *Example 2*. For the outputs, we can create tx with one or more outputs
            * *Explain*. Faucets pay to many outputs, instead of creating single transactions, to save fee

**Electronic coin**. A chain of digital signatures

<div style="text-align:center">
    <img src="https://i.imgur.com/noqUBWC.png">
    <figcaption>Chain of one-in-one-out transactions</figcaption>
</div>

* *Coin transfer and receiving*.
    * *Coin transfer*. Each owner transfers the coin to the next by 
        1. Digitally sign a hash of the previous transaction and the public key of the next owner
        2. Add these to the end of the coin
    * *Coin receiving*. A payee can verify the signatures to verify the chain of ownership
* *Example*.
    * *Coin transfer*.
        1. Owner 1 is generating the transaction on the right
        2. Owner 1 uses the public of the person he is sending bitcoin to, i.e. Owner 2's public key, and the previous Tx to produce a hash
            * *Explain*. The bigger the thing we are signing through ECDSA, the slower it gets

                $\to$ We want a fixed size string to be quicker
        3. Owner 1 signs the hash with his private key
    * *Coin receiving*. For Owner 1 to generated a Tx, he must know that he is entitled to spend the bitcoin pointing to him from the previous Tx, i.e.
        1. Owner 0 included Owner 1's public key in his signature as he transfer money to Owner 1

            $\to$ Owner 0 has signed the declaration that Owner 1 is entitled to spend a certain amount
        2. Owner 1 can verify this fact through ECDSA given the original Tx, its signature by Owner 0, and Owner 0's public key

**Bitcoin addresses**. Generated by several hash functions on a ECDSA public key

$\to$ Any one can generate unique bitcoin addresses, since they can generate their own unique public / private key pair
* *Purpose*. To provide an extra layer of security, i.e. the address is a hash of the public key
    * If ECDSA was compromised and we did not spend our bitcoins yet
        
        $\to$ Our money would be safe since people only see the address the money is supposed to go, not the actual public key
    * When we spend bitcoin and generate a transaction with our public key, we would get compromised
* *Consequence*. The common best practice, which is automatically done by wallets, is to use a different address / public-private key for each separate transaction

**Double-spending problem**. The payee cannot verify that one of the owners did not double-spend the coin
* *Examples*. Someone walks into a clothing store with only $10 and buys a $10 shirt
    
    $\to$ He then concurrently buys another $10 shirt with the same $10 already paid to the cashier
* *Root of problem*. Someone could add two transactions that consume from the same output
    * *Intuition*. The blockchain is branching into two concurrent chain
* *Centralized solution*. Have a trusted central authority, or mint, checking every transaction for double spending
    * *Idea*. After each transaction, the coin must be returned to the mint to issue a new coin

        $\to$ Only coins issued directly from the mint are trusted not to be double-spent
    * *Drawback*. The fate of the entire money system depends on the company running the mint, i.e. every transaction has to go through them like a bank
* *Decentralized solution*. We need a way for the payee to know that the previous owners did not sign any earlier transactions
    * *Idea*. The earliest transaction is the one that counts, i.e. we do not care about later attempts to double-spend
    * *Absent transaction confirmation*. The only way to confirm the absense of a transaction is to be aware of all transactions

        $\to$ In mint based model, the mint was aware of all transactions, and decided which arrived first
        * *Consequence*. To accompish this without a trusted party, transactions must be publicly announced

            $\to$ We need a system for participants to agree on a single history of the order, in which transactions were received
    * *Consequence*. The payee needs proof that, at the time of each transaction, the majority of nodes agreed it was the first received

## Timestamp server
**Timestamp server**. A solution to handle double-spending problem

<div style="text-align:center">
    <img src="https://i.imgur.com/hovUU08.png">
    <figcaption>Timestamp chaining</figcaption>
</div>

* *Timestamp server*. Work by taking a hash of a block of items to be timestamped, and widely publishing the hash, e.g. in a newspaper or Usenet post

    $\to$ The timestamp proves that the data must have existed at the time, in order to get into the hash
    * *Explain*. A timestamp determines when an event occurred by using a sequence of characters, e.g. the UNIX time

        $\to$ If we introduce this value in the hash generation of the transactions / blocks, we make sure the data existed at that moment
    * *Consequence*. There is no way to generate a hash with the same data for different timestamp

        $\to$ No one can pretend something happened in a different order maliciously
* *Timestamp chaining*. Each timestamp includes the previous timestamp in its hash, forming a chain

    $\to$ Each additional timestamp reinforces the ones before it

## Proof-of-Work
**Proof-of-Work**. Required to implement a distributed timestamp server on a P2P basis
* *Idea*. Involve scanning for a value when hashed, e.g. with SHA-256, the hash begins with a number of zero bits

    $\to$ The average work required is exponential in the number of zero bits required and can be verified by executing a single hash

**Hashcash PoW**. The motivation for Bitcoin PoW
* *I/O asymmetry of SHA-256 hash function*. The output drastically changes for small changes on the input but remain the same when nothing changes

    $\to$ This is exploited in Hashcash to ensure a certain operation has a cost associated with it
* *Example*. Consider reducing email spam
    * *Idea*. I give you a challenge to be resolved before sending the email which will cost you some computing power, i.e. electricity hence money

        $\to$ It will be small enough so that sending one email is cheap but costly enough to avoid a spammer send many
    * *Example challenge*. Find a number which when appended to the content, i.e. `Alice` to `Alice24`, will produce a binary output with certain amount of `0`â€™s in the beginning
        * *Analysis*, The chance to get one `0` from a certain number appended to `Alice` is $0.5$

            $\to$ $n$ consecutive `0`'s is $0.5^n$

**Bitcoin PoW**. We need to find a way to give incentives to distributed machines to find consensus, i.e. vote, on what is the current state and order of the transactions within the blocks forming the blockchain

<div style="text-align:center">
    <img src="https://i.imgur.com/Iwc17jA.png">
    <figcaption>Bitcoin PoW</figcaption>
</div>

* *Purpose of block generation cost*. If there was no cost associated in generating each block
    
    $\to$ It would be costless for anyone to manipulate it and the system would be hackable by definition
    * *Explain*. Since the longest chain is considered to be the truth, to modify an existing block in the middle of the chain

        $\to$ The hacker only have to modify that block, compute the hash, then repeat for subsequent blocks, and all the things happen in seconds 
* *Idea*. Increment a nonce in the block until a value is found, which gives the block's hash the required zero bits
    * *Consequence*. Once the CPU effort has been expended to make it satisfy the PoW, the block cannot be changed without redoing the work

        $\to$ As later blocks are chained after the existing block, the work to change the block would include redoing all the blocks after it
* *Implementation*. Apply the hash function on the headers of the block, i.e. including the previous block hash, the timestamp, and the nonce among others
* *Extra nonce*. The nonce is a number defined by 32 bits, which is easy to solve for a miner with current technology

    $\to$ There should be an extra nonce in every block, which has to be modified by the miner

**Consensus machanism**. PoW solves the problem of determining representation in majority decision making
* *One-IP-address-one-vote majority*. This system can be subverted by anyone able to allocate many IPs
* *One-CPU-one-vote*. PoW is one-CPU-one-vote
    * *Idea*. The majority decision is represented by the longest chain, which has the greatest PoW effort invested in it

        $\to$ If a majority of CPU power is controlled by honest nodes, the honest chain will grow the fastest and outpace any competing chains
* *Past block modification*. To do this, an attacker would have to redo the PoW of the block, and all subsequent blocks after it, then catch up and surpass the work of the honest nodes

    $\to$ It is shown that the probability of a slower attacker catching up diminishes exponentially as subsequent blocks are added

**PoW difficulty**. To compensate for increasing hardware speed and varying interest in running nodes over time

$\to$ PoW difficulty is determined by a moving average targeting an average number of blocks per hour
* *Idea*. If blocks are generated too fast, the difficulty increases
* *Fact*. There is a desired average mining speed of one block each 10 minutes

## Network
**Steps to run the network**.
1. New transactions are broadcast to all nodes
2. Each node collects new transactions into a block

    $\to$ Once enough transactions are found, they are validated, on which PoW will be executed to form block
3. Each node works on finding a difficult PoW for its block
4. When a node finds a PoW, it broadcasts the block to all nodes
5. Nodes accept the block only if all transactions in it are valid and not already spent
6. Nodes express their acceptance of the block by working on creating the next block in the chain, using the hash of the accepted block as the previous hash

**Consensus mechanism**. Nodes always consider the longest chain to be the correct one and will keep working on extending it
* *Race condition handling*. If two nodes broadcast different versions of the next block simultaneously, some
nodes may receive one or the other 
    
    $\to$ They work on the first one they received, but save the other branch in case it becomes longer

**Missing block handling**. Block broadcasts are tolerant of dropped messages, i.e. if a node does not receive a block

$\to$ It will request it when it receives the next block and realizes it missed one

## Incentive
**New block creation**. By convention, the first transaction in a block is a special transaction that starts a new coin owned by the creator of the block

$\to$ This is the reward to the miner for doing its PoW
* *Purposes*.
    * Add an incentive for nodes to support the network
    * Provide a way to initially distribute coins into circulation, since there is no central authority to issue them
* *Analogy*. The steady addition of a constant of amount of new coins is analogous to gold miners expending resources to add gold to circulation
    
    $\to$ In our case, it is CPU time and electricity that is expended

**Transaction fee**. The incentive can also be funded with transaction fees
* *Idea*. If the output value of a transaction is less than its input value
    
    $\to$ The difference is a transaction fee, which is added to the incentive value of the block containing the transaction
* *Consequence*. Once a predetermined number of coins have entered circulation
    
    $\to$ The incentive can transition entirely to transaction fees and be completely inflation free

**Effects**. Playing the rules ensures profit, while not doing so can easily get an attacker into trouble

## Reclaiming the disk
**Transaction size**. Vary depending on the number of I/O
* *Rule of thumb for transaction size calculation*.
    
    ```
    n_inputs*180B + n_outputs*34B + 10B + (+-n_inputs)
    ```

    * *Average transaction size*. 520 bytes (by `tradeblock.com` in 2014)

        $\to$ There are around 277 mil. transactions for that period, leading to 144 GB of storage
* *Block header with no transactions*. Occupy 80 bytes

    $\to$ There are around 240000 blocks at the period, leading to 19 MB of storage
* *Consequence*. We need to reduce transaction size

**Merkle tree**. We can reduce all transactions, e.g. Tx0 to Tx3, to a single hash, i.e. root hash, to save disk space without breaking the block hashes

<div style="text-align:center">
    <img src="https://i.imgur.com/TNyvf9U.png">
    <figcaption>Merkle tree</figcaption>
</div>

* *Idea*. Once the latest transaction in a coin is buried under enough blocks

    $\to$ The spent transactions before it can be discarded to save disk space
    * *Merkle tree in Bitcoin*. Only the root node of the Merkle tree is included in the block's hash
* *Optimization*.

    <div style="text-align:center">
        <img src="https://i.imgur.com/9Q6fHP2.png">
        <figcaption>Merkle tree pruning</figcaption>
    </div>

    * Old blocks can be compacted by stubbing off branches of the tree
    * The interior hashes do not need to be stored

## Simplified payment verification

# Appendix
## Concepts
**Proof (truth)**. A sufficient evidence or a sufficient argument for the truth of a proposition
* *Example*. Zero-knowledge proof is a method, by which one party, i.e. the prover, can prove to another party, i.e. the verifier, that a given statement is true, without conveying any additional information

**Escrow**. A contractual arrangment, in which a third party, i.e. the stakeholder or escrow agent, receives and distributes money or property for the primary transacting parties, with the discursement dependent on conditions agreed to by the transacting parties

**Digital signature**. A mathematical scheme for verifying the authenticity of digital messages or documents
* *Purpose*. A valid digital signature, where the prerequisites are satisfied, gives a recipient very strong reason to believe that 
    * The message was created by a known sender, i.e. authenticity, and
    * The message was not altered in transit, i.e. integrity

**Race condition in mining bitcoin**. 
* *Scenario*. Two nodes, one in Amsterdam, one in Barcelona, mine a block at the same time so there is a race condition, i.e. called fork
    
    $\to$ Surrounding nodes to each location will receive one of the two chains first and start working immediately on top of it
    * *Explain*. 
        * Nodes close to Amsterdam will keep working on chain A, i.e. they received quicker the new block
        * Barcelona ones will work on top of another chain B
* *Problem*. Both chains latest block hash will differ, i.e. due to different headers
    * *Explain*. Transactions might not be the same, in the same order or the timestamp slightly differs
* *Solution*. Decision making is achieved by the longest chain
    1. As soon as another block is mined on a chain (i.e. A) the node will propagate it to the whole network
    2. Nodes believing the other chain (B) was the correct one will see they are not on the longest chain to date anymore
        
        $\to$ Their latest blocks become orphan as they are out of the main chain
    3. The nodes believing in chain B will have to start working on chain A and later add their transactions into chain A
        * *Explain*. Transactions from reverted blocks are added back to mempools
        * *Reference*. https://bitcoin.stackexchange.com/questions/106709/how-does-bitcoin-prevent-race-conditions

**Genesis block**. The first block within the blockchain, which is hardcoded within bitcoin core by Satoshi Nakamoto

**Account versus address**.
* *Accounts*. Used for the convenience of people to track their funds, i.e. this is primarily used to track the source of funds
    * *Consequence*. Since this is just for tracking, we can move Bitcoins from one account to another by moving a number from one column to another

        $\to$ No transactions are required
* *Addresses*. Used to receive Bitcoins in transactions, i.e. the coins are sent to an address

    $\to$ The client associates each address with an account, and adds received funds to the account
    * *Purpose*. Done for convenience to allow people to track indirectly which address funds were sent to
    * *Number of addresses*. Each client can have any number of addresses associated with the same account, i.e. they are generating public-private key for each transaction

**Change in Bitcoins**.
* *Spending Bitcoins*. To spend a certain number of Bitcoins, we must pull in Bitcoins from transaction outputs to accounts we control
    * *Source of Bitcoin*. When we spend Bitcoins from a particular account, that just means we debit that account for the amount we send
        
        $\to$ It does not mean the funds come from addresses associated with that account
        * *Explain*. The association between addresses and accounts is for receiving only, not sending
    * *Change in Bitcoin*. When we pull in transaction outputs, you form a pile of Bitcoins big enough for the number we are trying to send
        
        $\to$ Usually, it will not be exact, since you must claim an entire output
        * *Consequence*. So the excess forms the change
* *Change handling*. Since there is no address associated with sending Bitcoins, there is no particular address the change should be sent to
    
    $\to$ To preserve anonymity, the client creates a new address to receive the change from this transaction
    * *Display*. Since this address isn't really associated with an account and shouldn't be used to receive any more Bitcoins 
        
        $\to$ The client does not display it
    * *Change verification*. The change is a transaction like any other, hence we need to wait for confirmations

        >**NOTE**. We can still use the change to spend another transaction immediately, we will just need to wait for the first transaction to confirm, before the second one can
* *Examples*. 
    * *Example 1*. Assume that we have a single \$20 bill and want to buy a \$1 candy bar from a store
        * *Input*. \$20 bill
        * *Output*. \$1 newly created bill to cashier, and \$19 newly created bill to ourself
    * *Example 2*. https://www.blockchain.com/btc/tx/0a1c0b1ec0ac55a45b1555202daf2e08419648096f5bcc4267898d420dffef87

## Discussion
**Changing blockchain history**. Consider hacking a blockchain, if modify a middle block of the chain and all subsequent blocks

$\to$ We can modify the blocks so that PoW can be made very quickly, i.e. since we can decide the hash of each block
* *Question*. How this can be prevented?
* *Answer*. The longest chain would always be considered to be the truth

    $\to$ If we want to modify a block in the middle, we need to make our branch longer than the existing longest one, assuming that the longest one is continuously appended by new blocks